continue 2003 review and tests
docs: how to run the tests
touch up the expr hack as best as can
left factor as much as possible (see below on notes)
table expression in syntax:
  QueryExpr = Select SelectList (Maybe TableExpr)
  and the TableExpr contains all the other bits?
finish off ansi 2003 support or specific subset
start looking at error messages
change the booleans in the ast to better types for less ambiguity
represent missing optional bits in the ast as nothing instead of the
   default
look at fixing the expression parsing completely
represent natural and using/on in the syntax more close to the
   concrete syntax - don't combine in the ast
review haddock in the syntax and update
review syntax names and representation
careful review of token parses wrt trailing delimiters/junk

decide how to handle character set literals and identifiers: don't
   have any intention of actually supporting switching character sets
   in the middle of parsing so maybe this would be better disabled?

review places in the parse which should allow only a fixed set of
   identifiers (e.g. in interval literals)

decide whether to represent numeric literals better, instead of a
   single string - break up into parts, or parse to a Decimal or
   something

refactor the typename parsing

reorder the parser and syntax (and the pretty)

remove the IsString for Name and [Name]

fixes:

keyword tree, add explicit result then can use for joins also

keyword tree support prefix mode so can start from already parsed
   token

do the final big left factor: typenames, interval lits, iden +
   suffixes

rough SQL 2003 todo, including tests to write:

idens: "", unicode
date and time literals
multisets
review window functions, window clause
review cases
search/cycle, exclusions
special operators
from clause review
table sample
unnest
filter in aggs
within group in aggs
rows review
matching simple partial full


LNR: maybe leave until after next release

LNR support needed MODULE syntax in identifiers - already covered?
LNR decide how to represent special identifiers including the session
   variables or whatever they are called like current_user
LNR grouping - needs special syntax?
LNR next value for
LNR subtypes, methods, new /routine, dereference
LNR double check associativity, precedence (value exprs, joins, set ops)
position expressions
length expressions
extract expression
cardinality expression?
check concatenations
substring expressions
regular expression substring function
convert
translate
trim
overlay
LNR specifictype
datetime value expressions
intervals
row value constructors, expressions review
review table value constructor exactly what is allowed
lots more tests for from clause variations
tablesamples
unnest
table function derived table
only spec
join variations, including union join
review group by
window clauses
all fields reference with alias 'select * as (a,b,c) ... '
search or cycle clause
between symmetric/asymmetric
in predicate review
escape for like
escape for [not] similar to
LNR regular expression syntax?
normalized predicate
overlaps predicate
distinct from predicate
member predicate
submultiset predicate
set predicate
LNR type predicate
additional stuff review:
interval stuff
aggregate functions: lots of missing bits
  especially: filter where, within group
complete list of keywords/reserved keywords
LNR select into
LNR other language format identifiers for host params?

----
above not marked LNR are for next release

review areas where this parser is too permissive, e.g. value
   expressions allowed where column reference names only should be
   allowed, such as group by, order by (perhaps there can be a flag or
   warnings or something), unqualified asterisk in select list


left factor/try removal:

character set literal: leading identifier
typed literal: leading identifier
special operators: needs some rewriting to remove try
  + left factor with iden( patterns
conflict with in suffix and in in position
conflict with not prefix op and not between??
multi word type names: left factor
quantified comparison: left factor with normal comparison
multi word operator names in expressions
hardcode all the symbols in the symbol parser/split?
left factor the not in 'not in' and 'not between', maybe others
rules for changing the multi keyword parsing:
  if a keyword must be followed by another
    e.g. left join, want to refactor to produce 'expected "left join"'
  if the keyword is optionally followed by another, e.g. with
   recursive, then don't do this.

future big feature summary:
all ansi sql queries
completely working expression tree parsing
error messages, left factor
dml, ddl, procedural sql
position annotation
type checker/ etc.
lexer
dialects
quasi quotes
typesafe sql dbms wrapper support for haskell
extensibility
performance analysis


= stuff

try and use the proper css theme
  create a header like in the haddock with simple-sql-parser +
    contents link
  change the toc gen so that it works the same as in haddock (same
    div, no links on the actual titles
  fix the page margins, and the table stuff: patches to the css?

release checklist:
hlint
haddock review
spell check
update changelog
update website text
regenerate the examples on the index.txt

= Later general tasks:

docs

add preamble to the rendered test page

add links from the supported sql page to the rendered test page for
   each section -> have to section up the tests some more

testing

review tests to copy from hssqlppp

add lots more tests using SQL from the xb2 manual

much more table reference tests, for joins and aliases etc.?

review internal sql collection for more syntax/tests

other

----

demo program: convert tpch to sql server syntax exe processor

run through other manuals for example queries and features: sql in a
   nutshell, sql guide, sql reference guide, sql standard, sql server
   manual, oracle manual, teradata manual + re-through postgresql
   manual and make notes in each case of all syntax and which isn't
   currently supported also.

check the order of exports, imports and functions/cases in the files
fix up the import namespaces/explicit names nicely

ast checker: checks the ast represents valid syntax, the parser
   doesn't check as much as it could, and this can also be used to
   check generated trees. Maybe this doesn't belong in this package
   though?

= other sql support

top
string literals
full number literals -> other bases?
apply, pivot

other dialect targets:
postgres
oracle
teradata
ms sql server
mysql?
db2?
what other major dialects are there?
sqlite
sap dbmss (can't work out what are separate products or what are the
   dialects)

