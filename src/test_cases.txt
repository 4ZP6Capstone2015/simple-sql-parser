# parserTest
## lexerTests
## valueExprTests
### literals
<table>
<tr><td>
~~~~{.sql}
3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.
~~~~
</td><td>
~~~~{.haskell}
NumLit "3."
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3.3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
.3
~~~~
</td><td>
~~~~{.haskell}
NumLit ".3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.e3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3.e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.3e3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3.3e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
.3e3
~~~~
</td><td>
~~~~{.haskell}
NumLit ".3e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3e3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3e+3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3e+3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3e-3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3e-3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'string'
~~~~
</td><td>
~~~~{.haskell}
StringLit "string"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'string with a '' quote'
~~~~
</td><td>
~~~~{.haskell}
StringLit "string with a ' quote"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'1'
~~~~
</td><td>
~~~~{.haskell}
StringLit "1"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '3' day
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Nothing
  , ilLiteral = "3"
  , ilFrom = Itf "day" Nothing
  , ilTo = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '3' day (3)
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Nothing
  , ilLiteral = "3"
  , ilFrom = Itf "day" (Just ( 3 , Nothing ))
  , ilTo = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '3 weeks'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "interval" ]) "3 weeks"
~~~~
</td></tr>
</table>
### identifiers
<table>
<tr><td>
~~~~{.sql}
iden1
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "iden1" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
"quoted identifier"
~~~~
</td><td>
~~~~{.haskell}
Iden [ QName "quoted identifier" ]
~~~~
</td></tr>
</table>
### star
<table>
<tr><td>
~~~~{.sql}
*
~~~~
</td><td>
~~~~{.haskell}
Star
~~~~
</td></tr>
</table>
### parameter
<table>
<tr><td>
~~~~{.sql}
?
~~~~
</td><td>
~~~~{.haskell}
Parameter
~~~~
</td></tr>
</table>
### dot
<table>
<tr><td>
~~~~{.sql}
t.a
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "t" , Name "a" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
t.*
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "t" ]) [ Name "." ] Star
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a.b.c
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "a" , Name "b" , Name "c" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
ROW(t.*,42)
~~~~
</td><td>
~~~~{.haskell}
App
  [ Name "ROW" ]
  [ BinOp (Iden [ Name "t" ]) [ Name "." ] Star , NumLit "42" ]
~~~~
</td></tr>
</table>
### app
<table>
<tr><td>
~~~~{.sql}
f()
~~~~
</td><td>
~~~~{.haskell}
App [ Name "f" ] []
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
f(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "f" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
f(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "f" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
</table>
### caseexp
<table>
<tr><td>
~~~~{.sql}
case a when 1 then 2 end
~~~~
</td><td>
~~~~{.haskell}
Case
  { caseTest = Just (Iden [ Name "a" ])
  , caseWhens = [ ( [ NumLit "1" ] , NumLit "2" ) ]
  , caseElse = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case a when 1 then 2 when 3 then 4 end
~~~~
</td><td>
~~~~{.haskell}
Case
  { caseTest = Just (Iden [ Name "a" ])
  , caseWhens =
      [ ( [ NumLit "1" ] , NumLit "2" )
      , ( [ NumLit "3" ] , NumLit "4" )
      ]
  , caseElse = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case a when 1 then 2 when 3 then 4 else 5 end
~~~~
</td><td>
~~~~{.haskell}
Case
  { caseTest = Just (Iden [ Name "a" ])
  , caseWhens =
      [ ( [ NumLit "1" ] , NumLit "2" )
      , ( [ NumLit "3" ] , NumLit "4" )
      ]
  , caseElse = Just (NumLit "5")
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case when a=1 then 2 when a=3 then 4 else 5 end
~~~~
</td><td>
~~~~{.haskell}
Case
  { caseTest = Nothing
  , caseWhens =
      [ ( [ BinOp (Iden [ Name "a" ]) [ Name "=" ] (NumLit "1") ]
        , NumLit "2"
        )
      , ( [ BinOp (Iden [ Name "a" ]) [ Name "=" ] (NumLit "3") ]
        , NumLit "4"
        )
      ]
  , caseElse = Just (NumLit "5")
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case a when 1,2 then 10 when 3,4 then 20 end
~~~~
</td><td>
~~~~{.haskell}
Case
  { caseTest = Just (Iden [ Name "a" ])
  , caseWhens =
      [ ( [ NumLit "1" , NumLit "2" ] , NumLit "10" )
      , ( [ NumLit "3" , NumLit "4" ] , NumLit "20" )
      ]
  , caseElse = Nothing
  }
~~~~
</td></tr>
</table>
### operators
#### binaryOperators
<table>
<tr><td>
~~~~{.sql}
a + b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "+" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a + b * c
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (Iden [ Name "a" ])
  [ Name "+" ]
  (BinOp (Iden [ Name "b" ]) [ Name "*" ] (Iden [ Name "c" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a * b + c
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (BinOp (Iden [ Name "a" ]) [ Name "*" ] (Iden [ Name "b" ]))
  [ Name "+" ]
  (Iden [ Name "c" ])
~~~~
</td></tr>
</table>
#### unaryOperators
<table>
<tr><td>
~~~~{.sql}
not a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "not" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
not not a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp
  [ Name "not" ] (PrefixOp [ Name "not" ] (Iden [ Name "a" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (Iden [ Name "a" ])
~~~~
</td></tr>
</table>
#### operators
<table>
<tr><td>
~~~~{.sql}
cast('1' as int)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (TypeName [ Name "int" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
int '3'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "int" ]) "3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('1' as double precision)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (TypeName [ Name "double precision" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('1' as float(8))
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (PrecTypeName [ Name "float" ] 8)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('1' as decimal(15,2))
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (PrecScaleTypeName [ Name "decimal" ] 15 2)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
double precision '3'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "double precision" ]) "3"
~~~~
</td></tr>
</table>
#### unaryOperators
<table>
<tr><td>
~~~~{.sql}
a in (1,2,3)
~~~~
</td><td>
~~~~{.haskell}
In
  True
  (Iden [ Name "a" ])
  (InList [ NumLit "1" , NumLit "2" , NumLit "3" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is null
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is null" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not null
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is not null" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is true
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is true" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not true
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is not true" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is false
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is false" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not false
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is not false" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is unknown
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is unknown" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not unknown
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is not unknown" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is distinct from b
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (Iden [ Name "a" ]) [ Name "is distinct from" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not distinct from b
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (Iden [ Name "a" ])
  [ Name "is not distinct from" ]
  (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a like b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "like" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a not like b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "not like" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is similar to b
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (Iden [ Name "a" ]) [ Name "is similar to" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not similar to b
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (Iden [ Name "a" ])
  [ Name "is not similar to" ]
  (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a overlaps b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "overlaps" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a between b and c
~~~~
</td><td>
~~~~{.haskell}
SpecialOp
  [ Name "between" ]
  [ Iden [ Name "a" ] , Iden [ Name "b" ] , Iden [ Name "c" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a not between b and c
~~~~
</td><td>
~~~~{.haskell}
SpecialOp
  [ Name "not between" ]
  [ Iden [ Name "a" ] , Iden [ Name "b" ] , Iden [ Name "c" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(1,2)
~~~~
</td><td>
~~~~{.haskell}
SpecialOp [ Name "rowctor" ] [ NumLit "1" , NumLit "2" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
extract(day from t)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "extract" ]
  (Just (Iden [ Name "day" ]))
  [ ( "from" , Iden [ Name "t" ] ) ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
substring(x from 1 for 2)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "substring" ]
  (Just (Iden [ Name "x" ]))
  [ ( "from" , NumLit "1" ) , ( "for" , NumLit "2" ) ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
substring(x from 1)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "substring" ]
  (Just (Iden [ Name "x" ]))
  [ ( "from" , NumLit "1" ) ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
substring(x for 2)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "substring" ]
  (Just (Iden [ Name "x" ]))
  [ ( "for" , NumLit "2" ) ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
substring(x from 1 for 2 collate C)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "substring" ]
  (Just (Iden [ Name "x" ]))
  [ ( "from" , NumLit "1" )
  , ( "for" , Collate (NumLit "2") [ Name "C" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
POSITION( string1 IN string2 )
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "position" ]
  (Just (Iden [ Name "string1" ]))
  [ ( "in" , Iden [ Name "string2" ] ) ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
CONVERT(char_value USING conversion_char_name)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "convert" ]
  (Just (Iden [ Name "char_value" ]))
  [ ( "using" , Iden [ Name "conversion_char_name" ] ) ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
TRANSLATE(char_value USING translation_name)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "translate" ]
  (Just (Iden [ Name "char_value" ]))
  [ ( "using" , Iden [ Name "translation_name" ] ) ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
OVERLAY(string PLACING embedded_string FROM start)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "overlay" ]
  (Just (Iden [ Name "string" ]))
  [ ( "placing" , Iden [ Name "embedded_string" ] )
  , ( "from" , Iden [ Name "start" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
OVERLAY(string PLACING embedded_string FROM start FOR length)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "overlay" ]
  (Just (Iden [ Name "string" ]))
  [ ( "placing" , Iden [ Name "embedded_string" ] )
  , ( "from" , Iden [ Name "start" ] )
  , ( "for" , Iden [ Name "length" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(from target_string)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "both" , StringLit " " )
  , ( "from" , Iden [ Name "target_string" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(leading from target_string)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "leading" , StringLit " " )
  , ( "from" , Iden [ Name "target_string" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(trailing from target_string)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "trailing" , StringLit " " )
  , ( "from" , Iden [ Name "target_string" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(both from target_string)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "both" , StringLit " " )
  , ( "from" , Iden [ Name "target_string" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(leading 'x' from target_string)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "leading" , StringLit "x" )
  , ( "from" , Iden [ Name "target_string" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(trailing 'y' from target_string)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "trailing" , StringLit "y" )
  , ( "from" , Iden [ Name "target_string" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(both 'z' from target_string collate C)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "both" , StringLit "z" )
  , ( "from" , Collate (Iden [ Name "target_string" ]) [ Name "C" ] )
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
trim(leading from target_string)
~~~~
</td><td>
~~~~{.haskell}
SpecialOpK
  [ Name "trim" ]
  Nothing
  [ ( "leading" , StringLit " " )
  , ( "from" , Iden [ Name "target_string" ] )
  ]
~~~~
</td></tr>
</table>
### parens
<table>
<tr><td>
~~~~{.sql}
(a)
~~~~
</td><td>
~~~~{.haskell}
Parens (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(a + b)
~~~~
</td><td>
~~~~{.haskell}
Parens (BinOp (Iden [ Name "a" ]) [ Name "+" ] (Iden [ Name "b" ]))
~~~~
</td></tr>
</table>
### unaryOperators
<table>
<tr><td>
~~~~{.sql}
exists (select a from t)
~~~~
</td><td>
~~~~{.haskell}
SubQueryExpr
  SqExists
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(select a from t)
~~~~
</td><td>
~~~~{.haskell}
SubQueryExpr
  SqSq
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a in (select a from t)
~~~~
</td><td>
~~~~{.haskell}
In
  True
  (Iden [ Name "a" ])
  (InQueryExpr
     Select
       { qeSetQuantifier = SQDefault
       , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
       , qeFrom = [ TRSimple [ Name "t" ] ]
       , qeWhere = Nothing
       , qeGroupBy = []
       , qeHaving = Nothing
       , qeOrderBy = []
       , qeOffset = Nothing
       , qeFetchFirst = Nothing
       })
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a not in (select a from t)
~~~~
</td><td>
~~~~{.haskell}
In
  False
  (Iden [ Name "a" ])
  (InQueryExpr
     Select
       { qeSetQuantifier = SQDefault
       , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
       , qeFrom = [ TRSimple [ Name "t" ] ]
       , qeWhere = Nothing
       , qeGroupBy = []
       , qeHaving = Nothing
       , qeOrderBy = []
       , qeOffset = Nothing
       , qeFetchFirst = Nothing
       })
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a > all (select a from t)
~~~~
</td><td>
~~~~{.haskell}
QuantifiedComparison
  (Iden [ Name "a" ])
  [ Name ">" ]
  CPAll
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a = some (select a from t)
~~~~
</td><td>
~~~~{.haskell}
QuantifiedComparison
  (Iden [ Name "a" ])
  [ Name "=" ]
  CPSome
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a <= any (select a from t)
~~~~
</td><td>
~~~~{.haskell}
QuantifiedComparison
  (Iden [ Name "a" ])
  [ Name "<=" ]
  CPAny
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
### aggregates
<table>
<tr><td>
~~~~{.sql}
count(*)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "count" ] [ Star ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a order by a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "sum" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy =
      [ SortSpec (Iden [ Name "a" ]) DirDefault NullsOrderDefault ]
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(all a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "sum" ]
  , aggDistinct = All
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "count" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
</table>
### windowFunctions
<table>
<tr><td>
~~~~{.sql}
max(a) over ()
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "max" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = []
  , wnOrderBy = []
  , wnFrame = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(*) over ()
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "count" ]
  , wnArgs = [ Star ]
  , wnPartition = []
  , wnOrderBy = []
  , wnFrame = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
max(a) over (partition by b)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "max" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy = []
  , wnFrame = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
max(a) over (partition by b,c)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "max" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] , Iden [ Name "c" ] ]
  , wnOrderBy = []
  , wnFrame = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (order by b)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = []
  , wnOrderBy =
      [ SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault ]
  , wnFrame = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (order by b desc,c)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = []
  , wnOrderBy =
      [ SortSpec (Iden [ Name "b" ]) Desc NullsOrderDefault
      , SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault
      ]
  , wnFrame = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy =
      [ SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault ]
  , wnFrame = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range unbounded preceding)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy =
      [ SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault ]
  , wnFrame = Just (FrameFrom FrameRange UnboundedPreceding)
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range 5 preceding)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy =
      [ SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault ]
  , wnFrame = Just (FrameFrom FrameRange (Preceding (NumLit "5")))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range current row)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy =
      [ SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault ]
  , wnFrame = Just (FrameFrom FrameRange Current)
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c rows 5 following)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy =
      [ SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault ]
  , wnFrame = Just (FrameFrom FrameRows (Following (NumLit "5")))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range unbounded following)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy =
      [ SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault ]
  , wnFrame = Just (FrameFrom FrameRange UnboundedFollowing)
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c 
range between 5 preceding and 5 following)
~~~~
</td><td>
~~~~{.haskell}
WindowApp
  { wnName = [ Name "sum" ]
  , wnArgs = [ Iden [ Name "a" ] ]
  , wnPartition = [ Iden [ Name "b" ] ]
  , wnOrderBy =
      [ SortSpec (Iden [ Name "c" ]) DirDefault NullsOrderDefault ]
  , wnFrame =
      Just
        (FrameBetween
           FrameRange (Preceding (NumLit "5")) (Following (NumLit "5")))
  }
~~~~
</td></tr>
</table>
## queryExprComponentTests
### duplicates
<table>
<tr><td>
~~~~{.sql}
select a from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select all a from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = All
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select distinct a from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = Distinct
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
### selectLists
<table>
<tr><td>
~~~~{.sql}
select 1
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( NumLit "1" , Nothing ) ]
  , qeFrom = []
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = []
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( Iden [ Name "b" ] , Nothing )
      ]
  , qeFrom = []
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select 1+2,3+4
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( BinOp (NumLit "1") [ Name "+" ] (NumLit "2") , Nothing )
      , ( BinOp (NumLit "3") [ Name "+" ] (NumLit "4") , Nothing )
      ]
  , qeFrom = []
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a as a, /*comment*/ b as b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Just (Name "a") )
      , ( Iden [ Name "b" ] , Just (Name "b") )
      ]
  , qeFrom = []
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a a, b b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Just (Name "a") )
      , ( Iden [ Name "b" ] , Just (Name "b") )
      ]
  , qeFrom = []
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a + b * c
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( BinOp
            (Iden [ Name "a" ])
            [ Name "+" ]
            (BinOp (Iden [ Name "b" ]) [ Name "*" ] (Iden [ Name "c" ]))
        , Nothing
        )
      ]
  , qeFrom = []
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
### whereClause
<table>
<tr><td>
~~~~{.sql}
select a from t where a = 5
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere =
      Just (BinOp (Iden [ Name "a" ]) [ Name "=" ] (NumLit "5"))
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
### having
<table>
<tr><td>
~~~~{.sql}
select a,sum(b) from t group by a having sum(b) > 5
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "b" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = [ SimpleGroup (Iden [ Name "a" ]) ]
  , qeHaving =
      Just
        (BinOp
           (App [ Name "sum" ] [ Iden [ Name "b" ] ])
           [ Name ">" ]
           (NumLit "5"))
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
### orderBy
<table>
<tr><td>
~~~~{.sql}
select a from t order by a
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) DirDefault NullsOrderDefault ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a, b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) DirDefault NullsOrderDefault
      , SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a asc
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) Asc NullsOrderDefault ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a desc, b desc
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) Desc NullsOrderDefault
      , SortSpec (Iden [ Name "b" ]) Desc NullsOrderDefault
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a desc nulls first, b desc nulls last
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) Desc NullsFirst
      , SortSpec (Iden [ Name "b" ]) Desc NullsLast
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
### offsetFetch
<table>
<tr><td>
~~~~{.sql}
select a from t offset 5 rows fetch next 10 rows only
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Just (NumLit "5")
  , qeFetchFirst = Just (NumLit "10")
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t offset 5 rows;
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Just (NumLit "5")
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t fetch next 10 row only;
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Just (NumLit "10")
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t offset 5 row fetch first 10 row only
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Just (NumLit "5")
  , qeFetchFirst = Just (NumLit "10")
  }
~~~~
</td></tr>
</table>
### combos
<table>
<tr><td>
~~~~{.sql}
select a from t union select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr
  { qe0 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "t" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  , qeCombOp = Union
  , qeSetQuantifier = SQDefault
  , qeCorresponding = Respectively
  , qe1 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "b" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t intersect select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr
  { qe0 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "t" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  , qeCombOp = Intersect
  , qeSetQuantifier = SQDefault
  , qeCorresponding = Respectively
  , qe1 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "b" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t except all select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr
  { qe0 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "t" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  , qeCombOp = Except
  , qeSetQuantifier = All
  , qeCorresponding = Respectively
  , qe1 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "b" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t union distinct corresponding select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr
  { qe0 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "t" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  , qeCombOp = Union
  , qeSetQuantifier = Distinct
  , qeCorresponding = Corresponding
  , qe1 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "b" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t union select a from t union select a from t
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr
  { qe0 =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "t" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  , qeCombOp = Union
  , qeSetQuantifier = SQDefault
  , qeCorresponding = Respectively
  , qe1 =
      CombineQueryExpr
        { qe0 =
            Select
              { qeSetQuantifier = SQDefault
              , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
              , qeFrom = [ TRSimple [ Name "t" ] ]
              , qeWhere = Nothing
              , qeGroupBy = []
              , qeHaving = Nothing
              , qeOrderBy = []
              , qeOffset = Nothing
              , qeFetchFirst = Nothing
              }
        , qeCombOp = Union
        , qeSetQuantifier = SQDefault
        , qeCorresponding = Respectively
        , qe1 =
            Select
              { qeSetQuantifier = SQDefault
              , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
              , qeFrom = [ TRSimple [ Name "t" ] ]
              , qeWhere = Nothing
              , qeGroupBy = []
              , qeHaving = Nothing
              , qeOrderBy = []
              , qeOffset = Nothing
              , qeFetchFirst = Nothing
              }
        }
  }
~~~~
</td></tr>
</table>
### with queries
<table>
<tr><td>
~~~~{.sql}
with u as (select a from t) select a from u
~~~~
</td><td>
~~~~{.haskell}
With
  { qeWithRecursive = False
  , qeViews =
      [ ( Alias (Name "u") Nothing
        , Select
            { qeSetQuantifier = SQDefault
            , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
            , qeFrom = [ TRSimple [ Name "t" ] ]
            , qeWhere = Nothing
            , qeGroupBy = []
            , qeHaving = Nothing
            , qeOrderBy = []
            , qeOffset = Nothing
            , qeFetchFirst = Nothing
            }
        )
      ]
  , qeQueryExpression =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
with u(b) as (select a from t) select a from u
~~~~
</td><td>
~~~~{.haskell}
With
  { qeWithRecursive = False
  , qeViews =
      [ ( Alias (Name "u") (Just [ Name "b" ])
        , Select
            { qeSetQuantifier = SQDefault
            , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
            , qeFrom = [ TRSimple [ Name "t" ] ]
            , qeWhere = Nothing
            , qeGroupBy = []
            , qeHaving = Nothing
            , qeOrderBy = []
            , qeOffset = Nothing
            , qeFetchFirst = Nothing
            }
        )
      ]
  , qeQueryExpression =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
with x as (select a from t),
     u as (select a from x)
select a from u
~~~~
</td><td>
~~~~{.haskell}
With
  { qeWithRecursive = False
  , qeViews =
      [ ( Alias (Name "x") Nothing
        , Select
            { qeSetQuantifier = SQDefault
            , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
            , qeFrom = [ TRSimple [ Name "t" ] ]
            , qeWhere = Nothing
            , qeGroupBy = []
            , qeHaving = Nothing
            , qeOrderBy = []
            , qeOffset = Nothing
            , qeFetchFirst = Nothing
            }
        )
      , ( Alias (Name "u") Nothing
        , Select
            { qeSetQuantifier = SQDefault
            , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
            , qeFrom = [ TRSimple [ Name "x" ] ]
            , qeWhere = Nothing
            , qeGroupBy = []
            , qeHaving = Nothing
            , qeOrderBy = []
            , qeOffset = Nothing
            , qeFetchFirst = Nothing
            }
        )
      ]
  , qeQueryExpression =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
with recursive u as (select a from t) select a from u
~~~~
</td><td>
~~~~{.haskell}
With
  { qeWithRecursive = True
  , qeViews =
      [ ( Alias (Name "u") Nothing
        , Select
            { qeSetQuantifier = SQDefault
            , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
            , qeFrom = [ TRSimple [ Name "t" ] ]
            , qeWhere = Nothing
            , qeGroupBy = []
            , qeHaving = Nothing
            , qeOrderBy = []
            , qeOffset = Nothing
            , qeFetchFirst = Nothing
            }
        )
      ]
  , qeQueryExpression =
      Select
        { qeSetQuantifier = SQDefault
        , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
        , qeFrom = [ TRSimple [ Name "u" ] ]
        , qeWhere = Nothing
        , qeGroupBy = []
        , qeHaving = Nothing
        , qeOrderBy = []
        , qeOffset = Nothing
        , qeFetchFirst = Nothing
        }
  }
~~~~
</td></tr>
</table>
### values
<table>
<tr><td>
~~~~{.sql}
values (1,2),(3,4)
~~~~
</td><td>
~~~~{.haskell}
Values
  [ [ NumLit "1" , NumLit "2" ] , [ NumLit "3" , NumLit "4" ] ]
~~~~
</td></tr>
</table>
### tables
<table>
<tr><td>
~~~~{.sql}
table tbl
~~~~
</td><td>
~~~~{.haskell}
Table [ Name "tbl" ]
~~~~
</td></tr>
</table>
## query exprs
<table>
<tr><td>
~~~~{.sql}
select 1
~~~~
</td><td>
~~~~{.haskell}
[ SelectStatement
    Select
      { qeSetQuantifier = SQDefault
      , qeSelectList = [ ( NumLit "1" , Nothing ) ]
      , qeFrom = []
      , qeWhere = Nothing
      , qeGroupBy = []
      , qeHaving = Nothing
      , qeOrderBy = []
      , qeOffset = Nothing
      , qeFetchFirst = Nothing
      }
]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select 1;
~~~~
</td><td>
~~~~{.haskell}
[ SelectStatement
    Select
      { qeSetQuantifier = SQDefault
      , qeSelectList = [ ( NumLit "1" , Nothing ) ]
      , qeFrom = []
      , qeWhere = Nothing
      , qeGroupBy = []
      , qeHaving = Nothing
      , qeOrderBy = []
      , qeOffset = Nothing
      , qeFetchFirst = Nothing
      }
]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select 1;select 1
~~~~
</td><td>
~~~~{.haskell}
[ SelectStatement
    Select
      { qeSetQuantifier = SQDefault
      , qeSelectList = [ ( NumLit "1" , Nothing ) ]
      , qeFrom = []
      , qeWhere = Nothing
      , qeGroupBy = []
      , qeHaving = Nothing
      , qeOrderBy = []
      , qeOffset = Nothing
      , qeFetchFirst = Nothing
      }
, SelectStatement
    Select
      { qeSetQuantifier = SQDefault
      , qeSelectList = [ ( NumLit "1" , Nothing ) ]
      , qeFrom = []
      , qeWhere = Nothing
      , qeGroupBy = []
      , qeHaving = Nothing
      , qeOrderBy = []
      , qeOffset = Nothing
      , qeFetchFirst = Nothing
      }
]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
 select 1;select 1; 
~~~~
</td><td>
~~~~{.haskell}
[ SelectStatement
    Select
      { qeSetQuantifier = SQDefault
      , qeSelectList = [ ( NumLit "1" , Nothing ) ]
      , qeFrom = []
      , qeWhere = Nothing
      , qeGroupBy = []
      , qeHaving = Nothing
      , qeOrderBy = []
      , qeOffset = Nothing
      , qeFetchFirst = Nothing
      }
, SelectStatement
    Select
      { qeSetQuantifier = SQDefault
      , qeSelectList = [ ( NumLit "1" , Nothing ) ]
      , qeFrom = []
      , qeWhere = Nothing
      , qeGroupBy = []
      , qeHaving = Nothing
      , qeOrderBy = []
      , qeOffset = Nothing
      , qeFetchFirst = Nothing
      }
]
~~~~
</td></tr>
</table>
## tableRefTests
<table>
<tr><td>
~~~~{.sql}
select a from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from f(a)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRFunction [ Name "f" ] [ Iden [ Name "a" ] ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t,u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] , TRSimple [ Name "u" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from s.t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "s" , Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from lateral a
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRLateral (TRSimple [ Name "a" ]) ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from lateral a,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRLateral (TRSimple [ Name "a" ]) , TRSimple [ Name "b" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from a, lateral b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRSimple [ Name "a" ] , TRLateral (TRSimple [ Name "b" ]) ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from a natural join lateral b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          True
          JInner
          (TRLateral (TRSimple [ Name "b" ]))
          Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from lateral a natural join lateral b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRLateral (TRSimple [ Name "a" ]))
          True
          JInner
          (TRLateral (TRSimple [ Name "b" ]))
          Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t inner join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ])
          False
          JInner
          (TRSimple [ Name "u" ])
          (Just (JoinOn (Iden [ Name "expr" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ])
          False
          JInner
          (TRSimple [ Name "u" ])
          (Just (JoinOn (Iden [ Name "expr" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t left join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ])
          False
          JLeft
          (TRSimple [ Name "u" ])
          (Just (JoinOn (Iden [ Name "expr" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t right join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ])
          False
          JRight
          (TRSimple [ Name "u" ])
          (Just (JoinOn (Iden [ Name "expr" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t full join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ])
          False
          JFull
          (TRSimple [ Name "u" ])
          (Just (JoinOn (Iden [ Name "expr" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t cross join u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ])
          False
          JCross
          (TRSimple [ Name "u" ])
          Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t natural inner join u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ]) True JInner (TRSimple [ Name "u" ]) Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t inner join u using(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "t" ])
          False
          JInner
          (TRSimple [ Name "u" ])
          (Just (JoinUsing [ Name "a" , Name "b" ]))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from (select a from t)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRQueryExpr
          Select
            { qeSetQuantifier = SQDefault
            , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
            , qeFrom = [ TRSimple [ Name "t" ] ]
            , qeWhere = Nothing
            , qeGroupBy = []
            , qeHaving = Nothing
            , qeOrderBy = []
            , qeOffset = Nothing
            , qeFetchFirst = Nothing
            }
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t as u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRAlias (TRSimple [ Name "t" ]) (Alias (Name "u") Nothing) ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRAlias (TRSimple [ Name "t" ]) (Alias (Name "u") Nothing) ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t u(b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRSimple [ Name "t" ]) (Alias (Name "u") (Just [ Name "b" ]))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from (t cross join u) as u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRParens
             (TRJoin
                (TRSimple [ Name "t" ])
                False
                JCross
                (TRSimple [ Name "u" ])
                Nothing))
          (Alias (Name "u") Nothing)
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t cross join u cross join v
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRJoin
             (TRSimple [ Name "t" ])
             False
             JCross
             (TRSimple [ Name "u" ])
             Nothing)
          False
          JCross
          (TRSimple [ Name "v" ])
          Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
## groupByTests
### simpleGroupBy
<table>
<tr><td>
~~~~{.sql}
select a,sum(b) from t group by a
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "b" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = [ SimpleGroup (Iden [ Name "a" ]) ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b,sum(c) from t group by a,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( Iden [ Name "b" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "c" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ SimpleGroup (Iden [ Name "a" ])
      , SimpleGroup (Iden [ Name "b" ])
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
### newGroupBy
<table>
<tr><td>
~~~~{.sql}
select * from t group by ()
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = [ GroupingParens [] ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t group by grouping sets ((), (a))
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ GroupingSets
          [ GroupingParens []
          , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
          ]
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t group by cube(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ Cube
          [ SimpleGroup (Iden [ Name "a" ])
          , SimpleGroup (Iden [ Name "b" ])
          ]
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t group by rollup(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ Rollup
          [ SimpleGroup (Iden [ Name "a" ])
          , SimpleGroup (Iden [ Name "b" ])
          ]
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
### randomGroupBy
<table>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "a" ]) ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a))
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ] ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a,b,c
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "a" ])
        , SimpleGroup (Iden [ Name "b" ])
        , SimpleGroup (Iden [ Name "c" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c))
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(a,b)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (Iden [ Name "a" ])
            , SimpleGroup (Iden [ Name "b" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b),
(a),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(b,a)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (Iden [ Name "b" ])
            , SimpleGroup (Iden [ Name "a" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((b,a),
(b),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "a" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "b" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY CUBE(a,b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Cube
            [ SimpleGroup (Iden [ Name "a" ])
            , SimpleGroup (Iden [ Name "b" ])
            , SimpleGroup (Iden [ Name "c" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a,c),
(b,c),
(a),
(b),
(c),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
            , GroupingParens [ SimpleGroup (Iden [ Name "b" ]) ]
            , GroupingParens [ SimpleGroup (Iden [ Name "c" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(Province, County, City)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (Iden [ Name "Province" ])
            , SimpleGroup (Iden [ Name "County" ])
            , SimpleGroup (Iden [ Name "City" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(Province, (County, City))
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (Iden [ Name "Province" ])
            , GroupingParens
                [ SimpleGroup (Iden [ Name "County" ])
                , SimpleGroup (Iden [ Name "City" ])
                ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(Province, (County, City))
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (Iden [ Name "Province" ])
            , GroupingParens
                [ SimpleGroup (Iden [ Name "County" ])
                , SimpleGroup (Iden [ Name "City" ])
                ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((Province, County, City),
(Province),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "Province" ])
                , SimpleGroup (Iden [ Name "County" ])
                , SimpleGroup (Iden [ Name "City" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "Province" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((Province, County, City),
(Province, County),
(Province),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "Province" ])
                , SimpleGroup (Iden [ Name "County" ])
                , SimpleGroup (Iden [ Name "City" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "Province" ])
                , SimpleGroup (Iden [ Name "County" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "Province" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a, ROLLUP(b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "a" ])
        , Rollup
            [ SimpleGroup (Iden [ Name "b" ])
            , SimpleGroup (Iden [ Name "c" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a) )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a, b, ROLLUP(c,d)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "a" ])
        , SimpleGroup (Iden [ Name "b" ])
        , Rollup
            [ SimpleGroup (Iden [ Name "c" ])
            , SimpleGroup (Iden [ Name "d" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c,d),
(a,b,c),
(a,b) )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                , SimpleGroup (Iden [ Name "d" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(a), ROLLUP(b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup [ SimpleGroup (Iden [ Name "a" ]) ]
        , Rollup
            [ SimpleGroup (Iden [ Name "b" ])
            , SimpleGroup (Iden [ Name "c" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a),
(b,c),
(b),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "b" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(a), CUBE(b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup [ SimpleGroup (Iden [ Name "a" ]) ]
        , Cube
            [ SimpleGroup (Iden [ Name "b" ])
            , SimpleGroup (Iden [ Name "c" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a,c),
(a),
(b,c),
(b),
(c),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "b" ]) ]
            , GroupingParens [ SimpleGroup (Iden [ Name "c" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY CUBE(a,b), ROLLUP(c,d)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Cube
            [ SimpleGroup (Iden [ Name "a" ])
            , SimpleGroup (Iden [ Name "b" ])
            ]
        , Rollup
            [ SimpleGroup (Iden [ Name "c" ])
            , SimpleGroup (Iden [ Name "d" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c,d),
(a,b,c),
(a,b),
(a,c,d),
(a,c),
(a),
(b,c,d),
(b,c),
(b),
(c,d),
(c),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                , SimpleGroup (Iden [ Name "d" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "c" ])
                , SimpleGroup (Iden [ Name "d" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                , SimpleGroup (Iden [ Name "d" ])
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "b" ])
                , SimpleGroup (Iden [ Name "c" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "b" ]) ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "c" ])
                , SimpleGroup (Iden [ Name "d" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "c" ]) ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a, ROLLUP(a,b)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "a" ])
        , Rollup
            [ SimpleGroup (Iden [ Name "a" ])
            , SimpleGroup (Iden [ Name "b" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b),
(a) )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "a" ])
                , SimpleGroup (Iden [ Name "b" ])
                ]
            , GroupingParens [ SimpleGroup (Iden [ Name "a" ]) ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY Region,
ROLLUP(Sales_Person, WEEK(Sales_Date)),
CUBE(YEAR(Sales_Date), MONTH (Sales_Date))
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "Region" ])
        , Rollup
            [ SimpleGroup (Iden [ Name "Sales_Person" ])
            , SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "Sales_Date" ] ])
            ]
        , Cube
            [ SimpleGroup (App [ Name "YEAR" ] [ Iden [ Name "Sales_Date" ] ])
            , SimpleGroup (App [ Name "MONTH" ] [ Iden [ Name "Sales_Date" ] ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP (Region, Sales_Person, WEEK(Sales_Date),
YEAR(Sales_Date), MONTH(Sales_Date) )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (Iden [ Name "Region" ])
            , SimpleGroup (Iden [ Name "Sales_Person" ])
            , SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "Sales_Date" ] ])
            , SimpleGroup (App [ Name "YEAR" ] [ Iden [ Name "Sales_Date" ] ])
            , SimpleGroup (App [ Name "MONTH" ] [ Iden [ Name "Sales_Date" ] ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "WEEK")
          )
        , ( App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "DAY_WEEK")
          )
        , ( Iden [ Name "SALES_PERSON" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere =
        Just
          (BinOp
             (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
             [ Name "=" ]
             (NumLit "13"))
    , qeGroupBy =
        [ SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
        , SimpleGroup
            (App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ])
        , SimpleGroup (Iden [ Name "SALES_PERSON" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "DAY_WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec
            (Iden [ Name "SALES_PERSON" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY GROUPING SETS ( (WEEK(SALES_DATE), SALES_PERSON),
(DAYOFWEEK(SALES_DATE), SALES_PERSON))
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "WEEK")
          )
        , ( App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "DAY_WEEK")
          )
        , ( Iden [ Name "SALES_PERSON" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere =
        Just
          (BinOp
             (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
             [ Name "=" ]
             (NumLit "13"))
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
                , SimpleGroup (Iden [ Name "SALES_PERSON" ])
                ]
            , GroupingParens
                [ SimpleGroup
                    (App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ])
                , SimpleGroup (Iden [ Name "SALES_PERSON" ])
                ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "DAY_WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec
            (Iden [ Name "SALES_PERSON" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY ROLLUP ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON )
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "WEEK")
          )
        , ( App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "DAY_WEEK")
          )
        , ( Iden [ Name "SALES_PERSON" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere =
        Just
          (BinOp
             (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
             [ Name "=" ]
             (NumLit "13"))
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
            , SimpleGroup
                (App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ])
            , SimpleGroup (Iden [ Name "SALES_PERSON" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "DAY_WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec
            (Iden [ Name "SALES_PERSON" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY CUBE ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON )
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "WEEK")
          )
        , ( App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "DAY_WEEK")
          )
        , ( Iden [ Name "SALES_PERSON" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere =
        Just
          (BinOp
             (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
             [ Name "=" ]
             (NumLit "13"))
    , qeGroupBy =
        [ Cube
            [ SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
            , SimpleGroup
                (App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ])
            , SimpleGroup (Iden [ Name "SALES_PERSON" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "DAY_WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec
            (Iden [ Name "SALES_PERSON" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT SALES_PERSON,
MONTH(SALES_DATE) AS MONTH,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY GROUPING SETS ( (SALES_PERSON, MONTH(SALES_DATE)),
()
)
ORDER BY SALES_PERSON, MONTH
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "SALES_PERSON" ] , Nothing )
        , ( App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "MONTH")
          )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "SALES_PERSON" ])
                , SimpleGroup (App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ])
                ]
            , GroupingParens []
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec
            (Iden [ Name "SALES_PERSON" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "MONTH" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY ROLLUP ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE) )
ORDER BY WEEK, DAY_WEEK
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "WEEK")
          )
        , ( App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "DAY_WEEK")
          )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
            , SimpleGroup
                (App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "DAY_WEEK" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT MONTH(SALES_DATE) AS MONTH,
REGION,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY ROLLUP ( MONTH(SALES_DATE), REGION )
ORDER BY MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "MONTH")
          )
        , ( Iden [ Name "REGION" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Rollup
            [ SimpleGroup (App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ])
            , SimpleGroup (Iden [ Name "REGION" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "MONTH" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "REGION" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
MONTH(SALES_DATE) AS MONTH,
REGION,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY GROUPING SETS ( ROLLUP( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE) ),
ROLLUP( MONTH(SALES_DATE), REGION ) )
ORDER BY WEEK, DAY_WEEK, MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "WEEK")
          )
        , ( App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "DAY_WEEK")
          )
        , ( App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "MONTH")
          )
        , ( Iden [ Name "REGION" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ Rollup
                [ SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
                , SimpleGroup
                    (App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ])
                ]
            , Rollup
                [ SimpleGroup (App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ])
                , SimpleGroup (Iden [ Name "REGION" ])
                ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "DAY_WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "MONTH" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "REGION" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT R1, R2,
WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
MONTH(SALES_DATE) AS MONTH,
REGION, SUM(SALES) AS UNITS_SOLD
FROM SALES,(VALUES('GROUP 1','GROUP 2')) AS X(R1,R2)
GROUP BY GROUPING SETS ((R1, ROLLUP(WEEK(SALES_DATE),
DAYOFWEEK(SALES_DATE))),
(R2,ROLLUP( MONTH(SALES_DATE), REGION ) ))
ORDER BY WEEK, DAY_WEEK, MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "R1" ] , Nothing )
        , ( Iden [ Name "R2" ] , Nothing )
        , ( App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "WEEK")
          )
        , ( App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "DAY_WEEK")
          )
        , ( App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "MONTH")
          )
        , ( Iden [ Name "REGION" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "SALES" ]
        , TRAlias
            (TRQueryExpr
               (Values [ [ StringLit "GROUP 1" , StringLit "GROUP 2" ] ]))
            (Alias (Name "X") (Just [ Name "R1" , Name "R2" ]))
        ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ GroupingSets
            [ GroupingParens
                [ SimpleGroup (Iden [ Name "R1" ])
                , Rollup
                    [ SimpleGroup (App [ Name "WEEK" ] [ Iden [ Name "SALES_DATE" ] ])
                    , SimpleGroup
                        (App [ Name "DAYOFWEEK" ] [ Iden [ Name "SALES_DATE" ] ])
                    ]
                ]
            , GroupingParens
                [ SimpleGroup (Iden [ Name "R2" ])
                , Rollup
                    [ SimpleGroup (App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ])
                    , SimpleGroup (Iden [ Name "REGION" ])
                    ]
                ]
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "DAY_WEEK" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "MONTH" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "REGION" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT MONTH(SALES_DATE) AS MONTH,
REGION,
SUM(SALES) AS UNITS_SOLD,
MAX(SALES) AS BEST_SALE,
CAST(ROUND(AVG(DECIMALx(SALES)),2) AS DECIMAL(5,2)) AS AVG_UNITS_SOLD
FROM SALES
GROUP BY CUBE(MONTH(SALES_DATE),REGION)
ORDER BY MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ]
          , Just (Name "MONTH")
          )
        , ( Iden [ Name "REGION" ] , Nothing )
        , ( App [ Name "SUM" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "UNITS_SOLD")
          )
        , ( App [ Name "MAX" ] [ Iden [ Name "SALES" ] ]
          , Just (Name "BEST_SALE")
          )
        , ( Cast
              (App
                 [ Name "ROUND" ]
                 [ App
                     [ Name "AVG" ]
                     [ App [ Name "DECIMALx" ] [ Iden [ Name "SALES" ] ] ]
                 , NumLit "2"
                 ])
              (PrecScaleTypeName [ Name "decimal" ] 5 2)
          , Just (Name "AVG_UNITS_SOLD")
          )
        ]
    , qeFrom = [ TRSimple [ Name "SALES" ] ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ Cube
            [ SimpleGroup (App [ Name "MONTH" ] [ Iden [ Name "SALES_DATE" ] ])
            , SimpleGroup (Iden [ Name "REGION" ])
            ]
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "MONTH" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "REGION" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
## queries
<table>
<tr><td>
~~~~{.sql}
select count(*) from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( App [ Name "count" ] [ Star ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a, sum(c+d) as s
  from t,u
  where a > 5
  group by a
  having count(1) > 5
  order by s
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( App
            [ Name "sum" ]
            [ BinOp (Iden [ Name "c" ]) [ Name "+" ] (Iden [ Name "d" ]) ]
        , Just (Name "s")
        )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] , TRSimple [ Name "u" ] ]
  , qeWhere =
      Just (BinOp (Iden [ Name "a" ]) [ Name ">" ] (NumLit "5"))
  , qeGroupBy = [ SimpleGroup (Iden [ Name "a" ]) ]
  , qeHaving =
      Just
        (BinOp
           (App [ Name "count" ] [ NumLit "1" ]) [ Name ">" ] (NumLit "5"))
  , qeOrderBy =
      [ SortSpec (Iden [ Name "s" ]) DirDefault NullsOrderDefault ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
## postgresTests
<table>
<tr><td>
~~~~{.sql}
SELECT name, (SELECT max(pop) FROM cities
 WHERE cities.state = states.name)
    FROM states;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "name" ] , Nothing )
        , ( SubQueryExpr
              SqSq
              Select
                { qeSetQuantifier = SQDefault
                , qeSelectList =
                    [ ( App [ Name "max" ] [ Iden [ Name "pop" ] ] , Nothing ) ]
                , qeFrom = [ TRSimple [ Name "cities" ] ]
                , qeWhere =
                    Just
                      (BinOp
                         (Iden [ Name "cities" , Name "state" ])
                         [ Name "=" ]
                         (Iden [ Name "states" , Name "name" ]))
                , qeGroupBy = []
                , qeHaving = Nothing
                , qeOrderBy = []
                , qeOffset = Nothing
                , qeFetchFirst = Nothing
                }
          , Nothing
          )
        ]
    , qeFrom = [ TRSimple [ Name "states" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(1,2.5,'this is a test');
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App
              [ Name "ROW" ]
              [ NumLit "1" , NumLit "2.5" , StringLit "this is a test" ]
          , Nothing
          )
        ]
    , qeFrom = []
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(t.*, 42) FROM t;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App
              [ Name "ROW" ]
              [ BinOp (Iden [ Name "t" ]) [ Name "." ] Star , NumLit "42" ]
          , Nothing
          )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(t.f1, t.f2, 42) FROM t;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App
              [ Name "ROW" ]
              [ Iden [ Name "t" , Name "f1" ]
              , Iden [ Name "t" , Name "f2" ]
              , NumLit "42"
              ]
          , Nothing
          )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App
              [ Name "getf1" ]
              [ Cast
                  (App
                     [ Name "ROW" ]
                     [ NumLit "11" , StringLit "this is a test" , NumLit "2.5" ])
                  (TypeName [ Name "myrowtype" ])
              ]
          , Nothing
          )
        ]
    , qeFrom = []
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( BinOp
              (App
                 [ Name "ROW" ]
                 [ NumLit "1" , NumLit "2.5" , StringLit "this is a test" ])
              [ Name "=" ]
              (App
                 [ Name "ROW" ]
                 [ NumLit "1" , NumLit "3" , StringLit "not the same" ])
          , Nothing
          )
        ]
    , qeFrom = []
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(tablex.*) IS NULL FROM tablex;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( PostfixOp
              [ Name "is null" ]
              (App
                 [ Name "ROW" ]
                 [ BinOp (Iden [ Name "tablex" ]) [ Name "." ] Star ])
          , Nothing
          )
        ]
    , qeFrom = [ TRSimple [ Name "tablex" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT true OR somefunc();
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( BinOp
              (Iden [ Name "true" ]) [ Name "or" ] (App [ Name "somefunc" ] [])
          , Nothing
          )
        ]
    , qeFrom = []
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT somefunc() OR true;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( BinOp
              (App [ Name "somefunc" ] []) [ Name "or" ] (Iden [ Name "true" ])
          , Nothing
          )
        ]
    , qeFrom = []
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 CROSS JOIN t2;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JCross
            (TRSimple [ Name "t2" ])
            Nothing
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JInner
            (TRSimple [ Name "t2" ])
            (Just
               (JoinOn
                  (BinOp
                     (Iden [ Name "t1" , Name "num" ])
                     [ Name "=" ]
                     (Iden [ Name "t2" , Name "num" ]))))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 INNER JOIN t2 USING (num);
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JInner
            (TRSimple [ Name "t2" ])
            (Just (JoinUsing [ Name "num" ]))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 NATURAL INNER JOIN t2;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            True
            JInner
            (TRSimple [ Name "t2" ])
            Nothing
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JLeft
            (TRSimple [ Name "t2" ])
            (Just
               (JoinOn
                  (BinOp
                     (Iden [ Name "t1" , Name "num" ])
                     [ Name "=" ]
                     (Iden [ Name "t2" , Name "num" ]))))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 USING (num);
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JLeft
            (TRSimple [ Name "t2" ])
            (Just (JoinUsing [ Name "num" ]))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JRight
            (TRSimple [ Name "t2" ])
            (Just
               (JoinOn
                  (BinOp
                     (Iden [ Name "t1" , Name "num" ])
                     [ Name "=" ]
                     (Iden [ Name "t2" , Name "num" ]))))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JFull
            (TRSimple [ Name "t2" ])
            (Just
               (JoinOn
                  (BinOp
                     (Iden [ Name "t1" , Name "num" ])
                     [ Name "=" ]
                     (Iden [ Name "t2" , Name "num" ]))))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JLeft
            (TRSimple [ Name "t2" ])
            (Just
               (JoinOn
                  (BinOp
                     (BinOp
                        (Iden [ Name "t1" , Name "num" ])
                        [ Name "=" ]
                        (Iden [ Name "t2" , Name "num" ]))
                     [ Name "and" ]
                     (BinOp
                        (Iden [ Name "t2" , Name "value" ])
                        [ Name "=" ]
                        (StringLit "xxx")))))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRSimple [ Name "t1" ])
            False
            JLeft
            (TRSimple [ Name "t2" ])
            (Just
               (JoinOn
                  (BinOp
                     (Iden [ Name "t1" , Name "num" ])
                     [ Name "=" ]
                     (Iden [ Name "t2" , Name "num" ]))))
        ]
    , qeWhere =
        Just
          (BinOp
             (Iden [ Name "t2" , Name "value" ]) [ Name "=" ] (StringLit "xxx"))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM some_very_long_table_name s
JOIN another_fairly_long_name a ON s.id = a.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRAlias
               (TRSimple [ Name "some_very_long_table_name" ])
               (Alias (Name "s") Nothing))
            False
            JInner
            (TRAlias
               (TRSimple [ Name "another_fairly_long_name" ])
               (Alias (Name "a") Nothing))
            (Just
               (JoinOn
                  (BinOp
                     (Iden [ Name "s" , Name "id" ])
                     [ Name "=" ]
                     (Iden [ Name "a" , Name "num" ]))))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM people AS mother JOIN people AS child
 ON mother.id = child.mother_id;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRAlias
               (TRSimple [ Name "people" ]) (Alias (Name "mother") Nothing))
            False
            JInner
            (TRAlias
               (TRSimple [ Name "people" ]) (Alias (Name "child") Nothing))
            (Just
               (JoinOn
                  (BinOp
                     (Iden [ Name "mother" , Name "id" ])
                     [ Name "=" ]
                     (Iden [ Name "child" , Name "mother_id" ]))))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM my_table AS a CROSS JOIN my_table AS b;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRAlias (TRSimple [ Name "my_table" ]) (Alias (Name "a") Nothing))
            False
            JCross
            (TRAlias (TRSimple [ Name "my_table" ]) (Alias (Name "b") Nothing))
            Nothing
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRAlias
            (TRParens
               (TRJoin
                  (TRAlias (TRSimple [ Name "my_table" ]) (Alias (Name "a") Nothing))
                  False
                  JCross
                  (TRSimple [ Name "my_table" ])
                  Nothing))
            (Alias (Name "b") Nothing)
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM getfoo(1) AS t1;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRAlias
            (TRFunction [ Name "getfoo" ] [ NumLit "1" ])
            (Alias (Name "t1") Nothing)
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "foo" ] ]
    , qeWhere =
        Just
          (In
             True
             (Iden [ Name "foosubid" ])
             (InQueryExpr
                Select
                  { qeSetQuantifier = SQDefault
                  , qeSelectList = [ ( Iden [ Name "foosubid" ] , Nothing ) ]
                  , qeFrom =
                      [ TRAlias
                          (TRFunction
                             [ Name "getfoo" ] [ Iden [ Name "foo" , Name "fooid" ] ])
                          (Alias (Name "z") Nothing)
                      ]
                  , qeWhere =
                      Just
                        (BinOp
                           (Iden [ Name "z" , Name "fooid" ])
                           [ Name "=" ]
                           (Iden [ Name "foo" , Name "fooid" ]))
                  , qeGroupBy = []
                  , qeHaving = Nothing
                  , qeOrderBy = []
                  , qeOffset = Nothing
                  , qeFetchFirst = Nothing
                  }))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRSimple [ Name "foo" ]
        , TRLateral
            (TRAlias
               (TRQueryExpr
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList = [ ( Star , Nothing ) ]
                    , qeFrom = [ TRSimple [ Name "bar" ] ]
                    , qeWhere =
                        Just
                          (BinOp
                             (Iden [ Name "bar" , Name "id" ])
                             [ Name "=" ]
                             (Iden [ Name "foo" , Name "bar_id" ]))
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    })
               (Alias (Name "ss") Nothing))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "foo" ] , TRSimple [ Name "bar" ] ]
    , qeWhere =
        Just
          (BinOp
             (Iden [ Name "bar" , Name "id" ])
             [ Name "=" ]
             (Iden [ Name "foo" , Name "bar_id" ]))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "m" , Name "name" ] , Nothing ) ]
    , qeFrom =
        [ TRJoin
            (TRAlias
               (TRSimple [ Name "manufacturers" ]) (Alias (Name "m") Nothing))
            False
            JLeft
            (TRLateral
               (TRAlias
                  (TRFunction
                     [ Name "get_product_names" ] [ Iden [ Name "m" , Name "id" ] ])
                  (Alias (Name "pname") Nothing)))
            (Just (JoinOn (Iden [ Name "true" ])))
        ]
    , qeWhere =
        Just (PostfixOp [ Name "is null" ] (Iden [ Name "pname" ]))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 > 5
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "fdt" ] ]
    , qeWhere =
        Just (BinOp (Iden [ Name "c1" ]) [ Name ">" ] (NumLit "5"))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 IN (1, 2, 3)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "fdt" ] ]
    , qeWhere =
        Just
          (In
             True
             (Iden [ Name "c1" ])
             (InList [ NumLit "1" , NumLit "2" , NumLit "3" ]))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 IN (SELECT c1 FROM t2)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "fdt" ] ]
    , qeWhere =
        Just
          (In
             True
             (Iden [ Name "c1" ])
             (InQueryExpr
                Select
                  { qeSetQuantifier = SQDefault
                  , qeSelectList = [ ( Iden [ Name "c1" ] , Nothing ) ]
                  , qeFrom = [ TRSimple [ Name "t2" ] ]
                  , qeWhere = Nothing
                  , qeGroupBy = []
                  , qeHaving = Nothing
                  , qeOrderBy = []
                  , qeOffset = Nothing
                  , qeFetchFirst = Nothing
                  }))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "fdt" ] ]
    , qeWhere =
        Just
          (In
             True
             (Iden [ Name "c1" ])
             (InQueryExpr
                Select
                  { qeSetQuantifier = SQDefault
                  , qeSelectList = [ ( Iden [ Name "c3" ] , Nothing ) ]
                  , qeFrom = [ TRSimple [ Name "t2" ] ]
                  , qeWhere =
                      Just
                        (BinOp
                           (Iden [ Name "c2" ])
                           [ Name "=" ]
                           (BinOp
                              (Iden [ Name "fdt" , Name "c1" ]) [ Name "+" ] (NumLit "10")))
                  , qeGroupBy = []
                  , qeHaving = Nothing
                  , qeOrderBy = []
                  , qeOffset = Nothing
                  , qeFetchFirst = Nothing
                  }))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 BETWEEN 
    (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "fdt" ] ]
    , qeWhere =
        Just
          (SpecialOp
             [ Name "between" ]
             [ Iden [ Name "c1" ]
             , SubQueryExpr
                 SqSq
                 Select
                   { qeSetQuantifier = SQDefault
                   , qeSelectList = [ ( Iden [ Name "c3" ] , Nothing ) ]
                   , qeFrom = [ TRSimple [ Name "t2" ] ]
                   , qeWhere =
                       Just
                         (BinOp
                            (Iden [ Name "c2" ])
                            [ Name "=" ]
                            (BinOp
                               (Iden [ Name "fdt" , Name "c1" ]) [ Name "+" ] (NumLit "10")))
                   , qeGroupBy = []
                   , qeHaving = Nothing
                   , qeOrderBy = []
                   , qeOffset = Nothing
                   , qeFetchFirst = Nothing
                   }
             , NumLit "100"
             ])
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 > fdt.c1)
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "fdt" ] ]
    , qeWhere =
        Just
          (SubQueryExpr
             SqExists
             Select
               { qeSetQuantifier = SQDefault
               , qeSelectList = [ ( Iden [ Name "c1" ] , Nothing ) ]
               , qeFrom = [ TRSimple [ Name "t2" ] ]
               , qeWhere =
                   Just
                     (BinOp
                        (Iden [ Name "c2" ])
                        [ Name ">" ]
                        (Iden [ Name "fdt" , Name "c1" ]))
               , qeGroupBy = []
               , qeHaving = Nothing
               , qeOrderBy = []
               , qeOffset = Nothing
               , qeFetchFirst = Nothing
               })
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM test1;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "test1" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x FROM test1 GROUP BY x;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "x" ] , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "test1" ] ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "x" ]) ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x, sum(y) FROM test1 GROUP BY x;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "x" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "y" ] ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "test1" ] ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "x" ]) ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "product_id" ] , Nothing )
        , ( Iden [ Name "p" , Name "name" ] , Nothing )
        , ( Parens
              (BinOp
                 (App [ Name "sum" ] [ Iden [ Name "s" , Name "units" ] ])
                 [ Name "*" ]
                 (Iden [ Name "p" , Name "price" ]))
          , Just (Name "sales")
          )
        ]
    , qeFrom =
        [ TRJoin
            (TRAlias (TRSimple [ Name "products" ]) (Alias (Name "p") Nothing))
            False
            JLeft
            (TRAlias (TRSimple [ Name "sales" ]) (Alias (Name "s") Nothing))
            (Just (JoinUsing [ Name "product_id" ]))
        ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "product_id" ])
        , SimpleGroup (Iden [ Name "p" , Name "name" ])
        , SimpleGroup (Iden [ Name "p" , Name "price" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "x" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "y" ] ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "test1" ] ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "x" ]) ]
    , qeHaving =
        Just
          (BinOp
             (App [ Name "sum" ] [ Iden [ Name "y" ] ])
             [ Name ">" ]
             (NumLit "3"))
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "x" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "y" ] ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "test1" ] ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "x" ]) ]
    , qeHaving =
        Just (BinOp (Iden [ Name "x" ]) [ Name "<" ] (StringLit "c"))
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.datex > CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) > 5000;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "product_id" ] , Nothing )
        , ( Iden [ Name "p" , Name "name" ] , Nothing )
        , ( Parens
              (BinOp
                 (App [ Name "sum" ] [ Iden [ Name "s" , Name "units" ] ])
                 [ Name "*" ]
                 (Parens
                    (BinOp
                       (Iden [ Name "p" , Name "price" ])
                       [ Name "-" ]
                       (Iden [ Name "p" , Name "cost" ]))))
          , Just (Name "profit")
          )
        ]
    , qeFrom =
        [ TRJoin
            (TRAlias (TRSimple [ Name "products" ]) (Alias (Name "p") Nothing))
            False
            JLeft
            (TRAlias (TRSimple [ Name "sales" ]) (Alias (Name "s") Nothing))
            (Just (JoinUsing [ Name "product_id" ]))
        ]
    , qeWhere =
        Just
          (BinOp
             (Iden [ Name "s" , Name "datex" ])
             [ Name ">" ]
             (BinOp
                (Iden [ Name "CURRENT_DATE" ])
                [ Name "-" ]
                (TypedLit (TypeName [ Name "interval" ]) "4 weeks")))
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "product_id" ])
        , SimpleGroup (Iden [ Name "p" , Name "name" ])
        , SimpleGroup (Iden [ Name "p" , Name "price" ])
        , SimpleGroup (Iden [ Name "p" , Name "cost" ])
        ]
    , qeHaving =
        Just
          (BinOp
             (App
                [ Name "sum" ]
                [ BinOp
                    (Iden [ Name "p" , Name "price" ])
                    [ Name "*" ]
                    (Iden [ Name "s" , Name "units" ])
                ])
             [ Name ">" ]
             (NumLit "5000"))
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT a, b, c FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "a" ] , Nothing )
        , ( Iden [ Name "b" ] , Nothing )
        , ( Iden [ Name "c" ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT tbl1.a, tbl2.a, tbl1.b FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "tbl1" , Name "a" ] , Nothing )
        , ( Iden [ Name "tbl2" , Name "a" ] , Nothing )
        , ( Iden [ Name "tbl1" , Name "b" ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT tbl1.*, tbl2.a FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( BinOp (Iden [ Name "tbl1" ]) [ Name "." ] Star , Nothing )
        , ( Iden [ Name "tbl2" , Name "a" ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT a AS value, b + c AS sum FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "a" ] , Just (Name "value") )
        , ( BinOp (Iden [ Name "b" ]) [ Name "+" ] (Iden [ Name "c" ])
          , Just (Name "sum")
          )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT a "value", b + c AS sum FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "a" ] , Just (QName "value") )
        , ( BinOp (Iden [ Name "b" ]) [ Name "+" ] (Iden [ Name "c" ])
          , Just (Name "sum")
          )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT DISTINCT select_list t
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = Distinct
    , qeSelectList =
        [ ( Iden [ Name "select_list" ] , Just (Name "t") ) ]
    , qeFrom = []
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
VALUES (1, 'one'), (2, 'two'), (3, 'three');
~~~~
</td><td>
~~~~{.haskell}
Right
  (Values
     [ [ NumLit "1" , StringLit "one" ]
     , [ NumLit "2" , StringLit "two" ]
     , [ NumLit "3" , StringLit "three" ]
     ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
~~~~
</td><td>
~~~~{.haskell}
Right
  CombineQueryExpr
    { qe0 =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( NumLit "1" , Just (Name "column1") )
              , ( StringLit "one" , Just (Name "column2") )
              ]
          , qeFrom = []
          , qeWhere = Nothing
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    , qeCombOp = Union
    , qeSetQuantifier = All
    , qeCorresponding = Respectively
    , qe1 =
        CombineQueryExpr
          { qe0 =
              Select
                { qeSetQuantifier = SQDefault
                , qeSelectList =
                    [ ( NumLit "2" , Nothing ) , ( StringLit "two" , Nothing ) ]
                , qeFrom = []
                , qeWhere = Nothing
                , qeGroupBy = []
                , qeHaving = Nothing
                , qeOrderBy = []
                , qeOffset = Nothing
                , qeFetchFirst = Nothing
                }
          , qeCombOp = Union
          , qeSetQuantifier = All
          , qeCorresponding = Respectively
          , qe1 =
              Select
                { qeSetQuantifier = SQDefault
                , qeSelectList =
                    [ ( NumLit "3" , Nothing ) , ( StringLit "three" , Nothing ) ]
                , qeFrom = []
                , qeWhere = Nothing
                , qeGroupBy = []
                , qeHaving = Nothing
                , qeOrderBy = []
                , qeOffset = Nothing
                , qeFetchFirst = Nothing
                }
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom =
        [ TRAlias
            (TRQueryExpr
               (Values
                  [ [ NumLit "1" , StringLit "one" ]
                  , [ NumLit "2" , StringLit "two" ]
                  , [ NumLit "3" , StringLit "three" ]
                  ]))
            (Alias (Name "t") (Just [ Name "num" , Name "letter" ]))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
     )
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = False
    , qeViews =
        [ ( Alias (Name "regional_sales") Nothing
          , Select
              { qeSetQuantifier = SQDefault
              , qeSelectList =
                  [ ( Iden [ Name "region" ] , Nothing )
                  , ( App [ Name "SUM" ] [ Iden [ Name "amount" ] ]
                    , Just (Name "total_sales")
                    )
                  ]
              , qeFrom = [ TRSimple [ Name "orders" ] ]
              , qeWhere = Nothing
              , qeGroupBy = [ SimpleGroup (Iden [ Name "region" ]) ]
              , qeHaving = Nothing
              , qeOrderBy = []
              , qeOffset = Nothing
              , qeFetchFirst = Nothing
              }
          )
        , ( Alias (Name "top_regions") Nothing
          , Select
              { qeSetQuantifier = SQDefault
              , qeSelectList = [ ( Iden [ Name "region" ] , Nothing ) ]
              , qeFrom = [ TRSimple [ Name "regional_sales" ] ]
              , qeWhere =
                  Just
                    (BinOp
                       (Iden [ Name "total_sales" ])
                       [ Name ">" ]
                       (SubQueryExpr
                          SqSq
                          Select
                            { qeSetQuantifier = SQDefault
                            , qeSelectList =
                                [ ( BinOp
                                      (App [ Name "SUM" ] [ Iden [ Name "total_sales" ] ])
                                      [ Name "/" ]
                                      (NumLit "10")
                                  , Nothing
                                  )
                                ]
                            , qeFrom = [ TRSimple [ Name "regional_sales" ] ]
                            , qeWhere = Nothing
                            , qeGroupBy = []
                            , qeHaving = Nothing
                            , qeOrderBy = []
                            , qeOffset = Nothing
                            , qeFetchFirst = Nothing
                            }))
              , qeGroupBy = []
              , qeHaving = Nothing
              , qeOrderBy = []
              , qeOffset = Nothing
              , qeFetchFirst = Nothing
              }
          )
        ]
    , qeQueryExpression =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( Iden [ Name "region" ] , Nothing )
              , ( Iden [ Name "product" ] , Nothing )
              , ( App [ Name "SUM" ] [ Iden [ Name "quantity" ] ]
                , Just (Name "product_units")
                )
              , ( App [ Name "SUM" ] [ Iden [ Name "amount" ] ]
                , Just (Name "product_sales")
                )
              ]
          , qeFrom = [ TRSimple [ Name "orders" ] ]
          , qeWhere =
              Just
                (In
                   True
                   (Iden [ Name "region" ])
                   (InQueryExpr
                      Select
                        { qeSetQuantifier = SQDefault
                        , qeSelectList = [ ( Iden [ Name "region" ] , Nothing ) ]
                        , qeFrom = [ TRSimple [ Name "top_regions" ] ]
                        , qeWhere = Nothing
                        , qeGroupBy = []
                        , qeHaving = Nothing
                        , qeOrderBy = []
                        , qeOffset = Nothing
                        , qeFetchFirst = Nothing
                        }))
          , qeGroupBy =
              [ SimpleGroup (Iden [ Name "region" ])
              , SimpleGroup (Iden [ Name "product" ])
              ]
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = True
    , qeViews =
        [ ( Alias (Name "t") (Just [ Name "n" ])
          , CombineQueryExpr
              { qe0 = Values [ [ NumLit "1" ] ]
              , qeCombOp = Union
              , qeSetQuantifier = All
              , qeCorresponding = Respectively
              , qe1 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( BinOp (Iden [ Name "n" ]) [ Name "+" ] (NumLit "1") , Nothing )
                        ]
                    , qeFrom = [ TRSimple [ Name "t" ] ]
                    , qeWhere =
                        Just (BinOp (Iden [ Name "n" ]) [ Name "<" ] (NumLit "100"))
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              }
          )
        ]
    , qeQueryExpression =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( App [ Name "sum" ] [ Iden [ Name "n" ] ] , Nothing ) ]
          , qeFrom = [ TRSimple [ Name "t" ] ]
          , qeWhere = Nothing
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = True
    , qeViews =
        [ ( Alias
              (Name "included_parts")
              (Just [ Name "sub_part" , Name "part" , Name "quantity" ])
          , CombineQueryExpr
              { qe0 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( Iden [ Name "sub_part" ] , Nothing )
                        , ( Iden [ Name "part" ] , Nothing )
                        , ( Iden [ Name "quantity" ] , Nothing )
                        ]
                    , qeFrom = [ TRSimple [ Name "parts" ] ]
                    , qeWhere =
                        Just
                          (BinOp
                             (Iden [ Name "part" ]) [ Name "=" ] (StringLit "our_product"))
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              , qeCombOp = Union
              , qeSetQuantifier = All
              , qeCorresponding = Respectively
              , qe1 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( Iden [ Name "p" , Name "sub_part" ] , Nothing )
                        , ( Iden [ Name "p" , Name "part" ] , Nothing )
                        , ( Iden [ Name "p" , Name "quantity" ] , Nothing )
                        ]
                    , qeFrom =
                        [ TRAlias
                            (TRSimple [ Name "included_parts" ]) (Alias (Name "pr") Nothing)
                        , TRAlias (TRSimple [ Name "parts" ]) (Alias (Name "p") Nothing)
                        ]
                    , qeWhere =
                        Just
                          (BinOp
                             (Iden [ Name "p" , Name "part" ])
                             [ Name "=" ]
                             (Iden [ Name "pr" , Name "sub_part" ]))
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              }
          )
        ]
    , qeQueryExpression =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( Iden [ Name "sub_part" ] , Nothing )
              , ( App [ Name "SUM" ] [ Iden [ Name "quantity" ] ]
                , Just (Name "total_quantity")
                )
              ]
          , qeFrom = [ TRSimple [ Name "included_parts" ] ]
          , qeWhere = Nothing
          , qeGroupBy = [ SimpleGroup (Iden [ Name "sub_part" ]) ]
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE search_graph(id, link, data, depth) AS (
        SELECT g.id, g.link, g.data, 1
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1
        FROM graph g, search_graph sg
        WHERE g.id = sg.link
)
SELECT * FROM search_graph;
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = True
    , qeViews =
        [ ( Alias
              (Name "search_graph")
              (Just [ Name "id" , Name "link" , Name "data" , Name "depth" ])
          , CombineQueryExpr
              { qe0 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( Iden [ Name "g" , Name "id" ] , Nothing )
                        , ( Iden [ Name "g" , Name "link" ] , Nothing )
                        , ( Iden [ Name "g" , Name "data" ] , Nothing )
                        , ( NumLit "1" , Nothing )
                        ]
                    , qeFrom =
                        [ TRAlias (TRSimple [ Name "graph" ]) (Alias (Name "g") Nothing) ]
                    , qeWhere = Nothing
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              , qeCombOp = Union
              , qeSetQuantifier = All
              , qeCorresponding = Respectively
              , qe1 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( Iden [ Name "g" , Name "id" ] , Nothing )
                        , ( Iden [ Name "g" , Name "link" ] , Nothing )
                        , ( Iden [ Name "g" , Name "data" ] , Nothing )
                        , ( BinOp
                              (Iden [ Name "sg" , Name "depth" ]) [ Name "+" ] (NumLit "1")
                          , Nothing
                          )
                        ]
                    , qeFrom =
                        [ TRAlias (TRSimple [ Name "graph" ]) (Alias (Name "g") Nothing)
                        , TRAlias
                            (TRSimple [ Name "search_graph" ]) (Alias (Name "sg") Nothing)
                        ]
                    , qeWhere =
                        Just
                          (BinOp
                             (Iden [ Name "g" , Name "id" ])
                             [ Name "=" ]
                             (Iden [ Name "sg" , Name "link" ]))
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              }
          )
        ]
    , qeQueryExpression =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList = [ ( Star , Nothing ) ]
          , qeFrom = [ TRSimple [ Name "search_graph" ] ]
          , qeWhere = Nothing
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t --LIMIT 100;
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = True
    , qeViews =
        [ ( Alias (Name "t") (Just [ Name "n" ])
          , CombineQueryExpr
              { qe0 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList = [ ( NumLit "1" , Nothing ) ]
                    , qeFrom = []
                    , qeWhere = Nothing
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              , qeCombOp = Union
              , qeSetQuantifier = All
              , qeCorresponding = Respectively
              , qe1 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( BinOp (Iden [ Name "n" ]) [ Name "+" ] (NumLit "1") , Nothing )
                        ]
                    , qeFrom = [ TRSimple [ Name "t" ] ]
                    , qeWhere = Nothing
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              }
          )
        ]
    , qeQueryExpression =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList = [ ( Iden [ Name "n" ] , Nothing ) ]
          , qeFrom = [ TRSimple [ Name "t" ] ]
          , qeWhere = Nothing
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "f" , Name "title" ] , Nothing )
        , ( Iden [ Name "f" , Name "did" ] , Nothing )
        , ( Iden [ Name "d" , Name "name" ] , Nothing )
        , ( Iden [ Name "f" , Name "date_prod" ] , Nothing )
        , ( Iden [ Name "f" , Name "kind" ] , Nothing )
        ]
    , qeFrom =
        [ TRAlias
            (TRSimple [ Name "distributors" ]) (Alias (Name "d") Nothing)
        , TRAlias (TRSimple [ Name "films" ]) (Alias (Name "f") Nothing)
        ]
    , qeWhere =
        Just
          (BinOp
             (Iden [ Name "f" , Name "did" ])
             [ Name "=" ]
             (Iden [ Name "d" , Name "did" ]))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) < interval '5 hours';
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "kind" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "len" ] ]
          , Just (Name "total")
          )
        ]
    , qeFrom = [ TRSimple [ Name "films" ] ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "kind" ]) ]
    , qeHaving =
        Just
          (BinOp
             (App [ Name "sum" ] [ Iden [ Name "len" ] ])
             [ Name "<" ]
             (TypedLit (TypeName [ Name "interval" ]) "5 hours"))
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM distributors ORDER BY name;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "distributors" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "name" ]) DirDefault NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM distributors ORDER BY 2;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "distributors" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (NumLit "2") DirDefault NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';
~~~~
</td><td>
~~~~{.haskell}
Right
  CombineQueryExpr
    { qe0 =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( Iden [ Name "distributors" , Name "name" ] , Nothing ) ]
          , qeFrom = [ TRSimple [ Name "distributors" ] ]
          , qeWhere =
              Just
                (BinOp
                   (Iden [ Name "distributors" , Name "name" ])
                   [ Name "like" ]
                   (StringLit "W%"))
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    , qeCombOp = Union
    , qeSetQuantifier = SQDefault
    , qeCorresponding = Respectively
    , qe1 =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( Iden [ Name "actors" , Name "name" ] , Nothing ) ]
          , qeFrom = [ TRSimple [ Name "actors" ] ]
          , qeWhere =
              Just
                (BinOp
                   (Iden [ Name "actors" , Name "name" ])
                   [ Name "like" ]
                   (StringLit "W%"))
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = False
    , qeViews =
        [ ( Alias (Name "t") Nothing
          , Select
              { qeSetQuantifier = SQDefault
              , qeSelectList = [ ( App [ Name "random" ] [] , Just (Name "x") ) ]
              , qeFrom =
                  [ TRFunction [ Name "generate_series" ] [ NumLit "1" , NumLit "3" ]
                  ]
              , qeWhere = Nothing
              , qeGroupBy = []
              , qeHaving = Nothing
              , qeOrderBy = []
              , qeOffset = Nothing
              , qeFetchFirst = Nothing
              }
          )
        ]
    , qeQueryExpression =
        CombineQueryExpr
          { qe0 =
              Select
                { qeSetQuantifier = SQDefault
                , qeSelectList = [ ( Star , Nothing ) ]
                , qeFrom = [ TRSimple [ Name "t" ] ]
                , qeWhere = Nothing
                , qeGroupBy = []
                , qeHaving = Nothing
                , qeOrderBy = []
                , qeOffset = Nothing
                , qeFetchFirst = Nothing
                }
          , qeCombOp = Union
          , qeSetQuantifier = All
          , qeCorresponding = Respectively
          , qe1 =
              Select
                { qeSetQuantifier = SQDefault
                , qeSelectList = [ ( Star , Nothing ) ]
                , qeFrom = [ TRSimple [ Name "t" ] ]
                , qeWhere = Nothing
                , qeGroupBy = []
                , qeHaving = Nothing
                , qeOrderBy = []
                , qeOffset = Nothing
                , qeFetchFirst = Nothing
                }
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = True
    , qeViews =
        [ ( Alias
              (Name "employee_recursive")
              (Just
                 [ Name "distance" , Name "employee_name" , Name "manager_name" ])
          , CombineQueryExpr
              { qe0 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( NumLit "1" , Nothing )
                        , ( Iden [ Name "employee_name" ] , Nothing )
                        , ( Iden [ Name "manager_name" ] , Nothing )
                        ]
                    , qeFrom = [ TRSimple [ Name "employee" ] ]
                    , qeWhere =
                        Just
                          (BinOp
                             (Iden [ Name "manager_name" ]) [ Name "=" ] (StringLit "Mary"))
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              , qeCombOp = Union
              , qeSetQuantifier = All
              , qeCorresponding = Respectively
              , qe1 =
                  Select
                    { qeSetQuantifier = SQDefault
                    , qeSelectList =
                        [ ( BinOp
                              (Iden [ Name "er" , Name "distance" ]) [ Name "+" ] (NumLit "1")
                          , Nothing
                          )
                        , ( Iden [ Name "e" , Name "employee_name" ] , Nothing )
                        , ( Iden [ Name "e" , Name "manager_name" ] , Nothing )
                        ]
                    , qeFrom =
                        [ TRAlias
                            (TRSimple [ Name "employee_recursive" ])
                            (Alias (Name "er") Nothing)
                        , TRAlias (TRSimple [ Name "employee" ]) (Alias (Name "e") Nothing)
                        ]
                    , qeWhere =
                        Just
                          (BinOp
                             (Iden [ Name "er" , Name "employee_name" ])
                             [ Name "=" ]
                             (Iden [ Name "e" , Name "manager_name" ]))
                    , qeGroupBy = []
                    , qeHaving = Nothing
                    , qeOrderBy = []
                    , qeOffset = Nothing
                    , qeFetchFirst = Nothing
                    }
              }
          )
        ]
    , qeQueryExpression =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( Iden [ Name "distance" ] , Nothing )
              , ( Iden [ Name "employee_name" ] , Nothing )
              ]
          , qeFrom = [ TRSimple [ Name "employee_recursive" ] ]
          , qeWhere = Nothing
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "m" , Name "name" ] , Just (Name "mname") )
        , ( Iden [ Name "pname" ] , Nothing )
        ]
    , qeFrom =
        [ TRAlias
            (TRSimple [ Name "manufacturers" ]) (Alias (Name "m") Nothing)
        , TRLateral
            (TRAlias
               (TRFunction
                  [ Name "get_product_names" ] [ Iden [ Name "m" , Name "id" ] ])
               (Alias (Name "pname") Nothing))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "m" , Name "name" ] , Just (Name "mname") )
        , ( Iden [ Name "pname" ] , Nothing )
        ]
    , qeFrom =
        [ TRJoin
            (TRAlias
               (TRSimple [ Name "manufacturers" ]) (Alias (Name "m") Nothing))
            False
            JLeft
            (TRLateral
               (TRAlias
                  (TRFunction
                     [ Name "get_product_names" ] [ Iden [ Name "m" , Name "id" ] ])
                  (Alias (Name "pname") Nothing)))
            (Just (JoinOn (Iden [ Name "true" ])))
        ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT 2+2;
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( BinOp (NumLit "2") [ Name "+" ] (NumLit "2") , Nothing ) ]
    , qeFrom = []
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
## parse tpch
<table>
<tr><td>
~~~~{.sql}

select
        l_returnflag,
        l_linestatus,
        sum(l_quantity) as sum_qty,
        sum(l_extendedprice) as sum_base_price,
        sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
        sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
        avg(l_quantity) as avg_qty,
        avg(l_extendedprice) as avg_price,
        avg(l_discount) as avg_disc,
        count(*) as count_order
from
        lineitem
where
        l_shipdate <= date '1998-12-01' - interval '63' day (3)
group by
        l_returnflag,
        l_linestatus
order by
        l_returnflag,
        l_linestatus
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "l_returnflag" ] , Nothing )
        , ( Iden [ Name "l_linestatus" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "l_quantity" ] ]
          , Just (Name "sum_qty")
          )
        , ( App [ Name "sum" ] [ Iden [ Name "l_extendedprice" ] ]
          , Just (Name "sum_base_price")
          )
        , ( App
              [ Name "sum" ]
              [ BinOp
                  (Iden [ Name "l_extendedprice" ])
                  [ Name "*" ]
                  (Parens
                     (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
              ]
          , Just (Name "sum_disc_price")
          )
        , ( App
              [ Name "sum" ]
              [ BinOp
                  (BinOp
                     (Iden [ Name "l_extendedprice" ])
                     [ Name "*" ]
                     (Parens
                        (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ]))))
                  [ Name "*" ]
                  (Parens (BinOp (NumLit "1") [ Name "+" ] (Iden [ Name "l_tax" ])))
              ]
          , Just (Name "sum_charge")
          )
        , ( App [ Name "avg" ] [ Iden [ Name "l_quantity" ] ]
          , Just (Name "avg_qty")
          )
        , ( App [ Name "avg" ] [ Iden [ Name "l_extendedprice" ] ]
          , Just (Name "avg_price")
          )
        , ( App [ Name "avg" ] [ Iden [ Name "l_discount" ] ]
          , Just (Name "avg_disc")
          )
        , ( App [ Name "count" ] [ Star ] , Just (Name "count_order") )
        ]
    , qeFrom = [ TRSimple [ Name "lineitem" ] ]
    , qeWhere =
        Just
          (BinOp
             (Iden [ Name "l_shipdate" ])
             [ Name "<=" ]
             (BinOp
                (TypedLit (TypeName [ Name "date" ]) "1998-12-01")
                [ Name "-" ]
                IntervalLit
                  { ilSign = Nothing
                  , ilLiteral = "63"
                  , ilFrom = Itf "day" (Just ( 3 , Nothing ))
                  , ilTo = Nothing
                  }))
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "l_returnflag" ])
        , SimpleGroup (Iden [ Name "l_linestatus" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec
            (Iden [ Name "l_returnflag" ]) DirDefault NullsOrderDefault
        , SortSpec
            (Iden [ Name "l_linestatus" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
from
        part,
        supplier,
        partsupp,
        nation,
        region
where
        p_partkey = ps_partkey
        and s_suppkey = ps_suppkey
        and p_size = 15
        and p_type like '%BRASS'
        and s_nationkey = n_nationkey
        and n_regionkey = r_regionkey
        and r_name = 'EUROPE'
        and ps_supplycost = (
                select
                        min(ps_supplycost)
                from
                        partsupp,
                        supplier,
                        nation,
                        region
                where
                        p_partkey = ps_partkey
                        and s_suppkey = ps_suppkey
                        and s_nationkey = n_nationkey
                        and n_regionkey = r_regionkey
                        and r_name = 'EUROPE'
        )
order by
        s_acctbal desc,
        n_name,
        s_name,
        p_partkey
fetch first 100 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "s_acctbal" ] , Nothing )
        , ( Iden [ Name "s_name" ] , Nothing )
        , ( Iden [ Name "n_name" ] , Nothing )
        , ( Iden [ Name "p_partkey" ] , Nothing )
        , ( Iden [ Name "p_mfgr" ] , Nothing )
        , ( Iden [ Name "s_address" ] , Nothing )
        , ( Iden [ Name "s_phone" ] , Nothing )
        , ( Iden [ Name "s_comment" ] , Nothing )
        ]
    , qeFrom =
        [ TRSimple [ Name "part" ]
        , TRSimple [ Name "supplier" ]
        , TRSimple [ Name "partsupp" ]
        , TRSimple [ Name "nation" ]
        , TRSimple [ Name "region" ]
        ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (BinOp
                         (BinOp
                            (BinOp
                               (BinOp
                                  (Iden [ Name "p_partkey" ])
                                  [ Name "=" ]
                                  (Iden [ Name "ps_partkey" ]))
                               [ Name "and" ]
                               (BinOp
                                  (Iden [ Name "s_suppkey" ])
                                  [ Name "=" ]
                                  (Iden [ Name "ps_suppkey" ])))
                            [ Name "and" ]
                            (BinOp (Iden [ Name "p_size" ]) [ Name "=" ] (NumLit "15")))
                         [ Name "and" ]
                         (BinOp
                            (Iden [ Name "p_type" ]) [ Name "like" ] (StringLit "%BRASS")))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "s_nationkey" ])
                         [ Name "=" ]
                         (Iden [ Name "n_nationkey" ])))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "n_regionkey" ])
                      [ Name "=" ]
                      (Iden [ Name "r_regionkey" ])))
                [ Name "and" ]
                (BinOp (Iden [ Name "r_name" ]) [ Name "=" ] (StringLit "EUROPE")))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "ps_supplycost" ])
                [ Name "=" ]
                (SubQueryExpr
                   SqSq
                   Select
                     { qeSetQuantifier = SQDefault
                     , qeSelectList =
                         [ ( App [ Name "min" ] [ Iden [ Name "ps_supplycost" ] ]
                           , Nothing
                           )
                         ]
                     , qeFrom =
                         [ TRSimple [ Name "partsupp" ]
                         , TRSimple [ Name "supplier" ]
                         , TRSimple [ Name "nation" ]
                         , TRSimple [ Name "region" ]
                         ]
                     , qeWhere =
                         Just
                           (BinOp
                              (BinOp
                                 (BinOp
                                    (BinOp
                                       (BinOp
                                          (Iden [ Name "p_partkey" ])
                                          [ Name "=" ]
                                          (Iden [ Name "ps_partkey" ]))
                                       [ Name "and" ]
                                       (BinOp
                                          (Iden [ Name "s_suppkey" ])
                                          [ Name "=" ]
                                          (Iden [ Name "ps_suppkey" ])))
                                    [ Name "and" ]
                                    (BinOp
                                       (Iden [ Name "s_nationkey" ])
                                       [ Name "=" ]
                                       (Iden [ Name "n_nationkey" ])))
                                 [ Name "and" ]
                                 (BinOp
                                    (Iden [ Name "n_regionkey" ])
                                    [ Name "=" ]
                                    (Iden [ Name "r_regionkey" ])))
                              [ Name "and" ]
                              (BinOp (Iden [ Name "r_name" ]) [ Name "=" ] (StringLit "EUROPE")))
                     , qeGroupBy = []
                     , qeHaving = Nothing
                     , qeOrderBy = []
                     , qeOffset = Nothing
                     , qeFetchFirst = Nothing
                     })))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "s_acctbal" ]) Desc NullsOrderDefault
        , SortSpec (Iden [ Name "n_name" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "s_name" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "p_partkey" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Just (NumLit "100")
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         l_orderkey,
         sum(l_extendedprice * (1 - l_discount)) as revenue,
         o_orderdate,
         o_shippriority
 from
         customer,
         orders,
         lineitem
 where
         c_mktsegment = 'MACHINERY'
         and c_custkey = o_custkey
         and l_orderkey = o_orderkey
         and o_orderdate < date '1995-03-21'
         and l_shipdate > date '1995-03-21'
 group by
         l_orderkey,
         o_orderdate,
         o_shippriority
 order by
         revenue desc,
         o_orderdate
 fetch first 10 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "l_orderkey" ] , Nothing )
        , ( App
              [ Name "sum" ]
              [ BinOp
                  (Iden [ Name "l_extendedprice" ])
                  [ Name "*" ]
                  (Parens
                     (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
              ]
          , Just (Name "revenue")
          )
        , ( Iden [ Name "o_orderdate" ] , Nothing )
        , ( Iden [ Name "o_shippriority" ] , Nothing )
        ]
    , qeFrom =
        [ TRSimple [ Name "customer" ]
        , TRSimple [ Name "orders" ]
        , TRSimple [ Name "lineitem" ]
        ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (BinOp
                         (Iden [ Name "c_mktsegment" ])
                         [ Name "=" ]
                         (StringLit "MACHINERY"))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "c_custkey" ])
                         [ Name "=" ]
                         (Iden [ Name "o_custkey" ])))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "l_orderkey" ])
                      [ Name "=" ]
                      (Iden [ Name "o_orderkey" ])))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "o_orderdate" ])
                   [ Name "<" ]
                   (TypedLit (TypeName [ Name "date" ]) "1995-03-21")))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "l_shipdate" ])
                [ Name ">" ]
                (TypedLit (TypeName [ Name "date" ]) "1995-03-21")))
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "l_orderkey" ])
        , SimpleGroup (Iden [ Name "o_orderdate" ])
        , SimpleGroup (Iden [ Name "o_shippriority" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "revenue" ]) Desc NullsOrderDefault
        , SortSpec
            (Iden [ Name "o_orderdate" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Just (NumLit "10")
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         o_orderpriority,
         count(*) as order_count
 from
         orders
 where
         o_orderdate >= date '1996-03-01'
         and o_orderdate < date '1996-03-01' + interval '3' month
         and exists (
                 select
                         *
                 from
                         lineitem
                 where
                         l_orderkey = o_orderkey
                         and l_commitdate < l_receiptdate
         )
 group by
         o_orderpriority
 order by
         o_orderpriority
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "o_orderpriority" ] , Nothing )
        , ( App [ Name "count" ] [ Star ] , Just (Name "order_count") )
        ]
    , qeFrom = [ TRSimple [ Name "orders" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (Iden [ Name "o_orderdate" ])
                   [ Name ">=" ]
                   (TypedLit (TypeName [ Name "date" ]) "1996-03-01"))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "o_orderdate" ])
                   [ Name "<" ]
                   (BinOp
                      (TypedLit (TypeName [ Name "date" ]) "1996-03-01")
                      [ Name "+" ]
                      IntervalLit
                        { ilSign = Nothing
                        , ilLiteral = "3"
                        , ilFrom = Itf "month" Nothing
                        , ilTo = Nothing
                        })))
             [ Name "and" ]
             (SubQueryExpr
                SqExists
                Select
                  { qeSetQuantifier = SQDefault
                  , qeSelectList = [ ( Star , Nothing ) ]
                  , qeFrom = [ TRSimple [ Name "lineitem" ] ]
                  , qeWhere =
                      Just
                        (BinOp
                           (BinOp
                              (Iden [ Name "l_orderkey" ])
                              [ Name "=" ]
                              (Iden [ Name "o_orderkey" ]))
                           [ Name "and" ]
                           (BinOp
                              (Iden [ Name "l_commitdate" ])
                              [ Name "<" ]
                              (Iden [ Name "l_receiptdate" ])))
                  , qeGroupBy = []
                  , qeHaving = Nothing
                  , qeOrderBy = []
                  , qeOffset = Nothing
                  , qeFetchFirst = Nothing
                  }))
    , qeGroupBy = [ SimpleGroup (Iden [ Name "o_orderpriority" ]) ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec
            (Iden [ Name "o_orderpriority" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         n_name,
         sum(l_extendedprice * (1 - l_discount)) as revenue
 from
         customer,
         orders,
         lineitem,
         supplier,
         nation,
         region
 where
         c_custkey = o_custkey
         and l_orderkey = o_orderkey
         and l_suppkey = s_suppkey
         and c_nationkey = s_nationkey
         and s_nationkey = n_nationkey
         and n_regionkey = r_regionkey
         and r_name = 'EUROPE'
         and o_orderdate >= date '1997-01-01'
         and o_orderdate < date '1997-01-01' + interval '1' year
 group by
         n_name
 order by
         revenue desc
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "n_name" ] , Nothing )
        , ( App
              [ Name "sum" ]
              [ BinOp
                  (Iden [ Name "l_extendedprice" ])
                  [ Name "*" ]
                  (Parens
                     (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
              ]
          , Just (Name "revenue")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "customer" ]
        , TRSimple [ Name "orders" ]
        , TRSimple [ Name "lineitem" ]
        , TRSimple [ Name "supplier" ]
        , TRSimple [ Name "nation" ]
        , TRSimple [ Name "region" ]
        ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (BinOp
                         (BinOp
                            (BinOp
                               (BinOp
                                  (BinOp
                                     (Iden [ Name "c_custkey" ])
                                     [ Name "=" ]
                                     (Iden [ Name "o_custkey" ]))
                                  [ Name "and" ]
                                  (BinOp
                                     (Iden [ Name "l_orderkey" ])
                                     [ Name "=" ]
                                     (Iden [ Name "o_orderkey" ])))
                               [ Name "and" ]
                               (BinOp
                                  (Iden [ Name "l_suppkey" ])
                                  [ Name "=" ]
                                  (Iden [ Name "s_suppkey" ])))
                            [ Name "and" ]
                            (BinOp
                               (Iden [ Name "c_nationkey" ])
                               [ Name "=" ]
                               (Iden [ Name "s_nationkey" ])))
                         [ Name "and" ]
                         (BinOp
                            (Iden [ Name "s_nationkey" ])
                            [ Name "=" ]
                            (Iden [ Name "n_nationkey" ])))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "n_regionkey" ])
                         [ Name "=" ]
                         (Iden [ Name "r_regionkey" ])))
                   [ Name "and" ]
                   (BinOp (Iden [ Name "r_name" ]) [ Name "=" ] (StringLit "EUROPE")))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "o_orderdate" ])
                   [ Name ">=" ]
                   (TypedLit (TypeName [ Name "date" ]) "1997-01-01")))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "o_orderdate" ])
                [ Name "<" ]
                (BinOp
                   (TypedLit (TypeName [ Name "date" ]) "1997-01-01")
                   [ Name "+" ]
                   IntervalLit
                     { ilSign = Nothing
                     , ilLiteral = "1"
                     , ilFrom = Itf "year" Nothing
                     , ilTo = Nothing
                     })))
    , qeGroupBy = [ SimpleGroup (Iden [ Name "n_name" ]) ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "revenue" ]) Desc NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         sum(l_extendedprice * l_discount) as revenue
 from
         lineitem
 where
         l_shipdate >= date '1997-01-01'
         and l_shipdate < date '1997-01-01' + interval '1' year
         and l_discount between 0.07 - 0.01 and 0.07 + 0.01
         and l_quantity < 24
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App
              [ Name "sum" ]
              [ BinOp
                  (Iden [ Name "l_extendedprice" ])
                  [ Name "*" ]
                  (Iden [ Name "l_discount" ])
              ]
          , Just (Name "revenue")
          )
        ]
    , qeFrom = [ TRSimple [ Name "lineitem" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (Iden [ Name "l_shipdate" ])
                      [ Name ">=" ]
                      (TypedLit (TypeName [ Name "date" ]) "1997-01-01"))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "l_shipdate" ])
                      [ Name "<" ]
                      (BinOp
                         (TypedLit (TypeName [ Name "date" ]) "1997-01-01")
                         [ Name "+" ]
                         IntervalLit
                           { ilSign = Nothing
                           , ilLiteral = "1"
                           , ilFrom = Itf "year" Nothing
                           , ilTo = Nothing
                           })))
                [ Name "and" ]
                (SpecialOp
                   [ Name "between" ]
                   [ Iden [ Name "l_discount" ]
                   , BinOp (NumLit "0.07") [ Name "-" ] (NumLit "0.01")
                   , BinOp (NumLit "0.07") [ Name "+" ] (NumLit "0.01")
                   ]))
             [ Name "and" ]
             (BinOp (Iden [ Name "l_quantity" ]) [ Name "<" ] (NumLit "24")))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         supp_nation,
         cust_nation,
         l_year,
         sum(volume) as revenue
 from
         (
                 select
                         n1.n_name as supp_nation,
                         n2.n_name as cust_nation,
                         extract(year from l_shipdate) as l_year,
                         l_extendedprice * (1 - l_discount) as volume
                 from
                         supplier,
                         lineitem,
                         orders,
                         customer,
                         nation n1,
                         nation n2
                 where
                         s_suppkey = l_suppkey
                         and o_orderkey = l_orderkey
                         and c_custkey = o_custkey
                         and s_nationkey = n1.n_nationkey
                         and c_nationkey = n2.n_nationkey
                         and (
                                 (n1.n_name = 'PERU' and n2.n_name = 'IRAQ')
                                 or (n1.n_name = 'IRAQ' and n2.n_name = 'PERU')
                         )
                         and l_shipdate between date '1995-01-01' and date '1996-12-31'
         ) as shipping
 group by
         supp_nation,
         cust_nation,
         l_year
 order by
         supp_nation,
         cust_nation,
         l_year
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "supp_nation" ] , Nothing )
        , ( Iden [ Name "cust_nation" ] , Nothing )
        , ( Iden [ Name "l_year" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "volume" ] ]
          , Just (Name "revenue")
          )
        ]
    , qeFrom =
        [ TRAlias
            (TRQueryExpr
               Select
                 { qeSetQuantifier = SQDefault
                 , qeSelectList =
                     [ ( Iden [ Name "n1" , Name "n_name" ]
                       , Just (Name "supp_nation")
                       )
                     , ( Iden [ Name "n2" , Name "n_name" ]
                       , Just (Name "cust_nation")
                       )
                     , ( SpecialOpK
                           [ Name "extract" ]
                           (Just (Iden [ Name "year" ]))
                           [ ( "from" , Iden [ Name "l_shipdate" ] ) ]
                       , Just (Name "l_year")
                       )
                     , ( BinOp
                           (Iden [ Name "l_extendedprice" ])
                           [ Name "*" ]
                           (Parens
                              (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
                       , Just (Name "volume")
                       )
                     ]
                 , qeFrom =
                     [ TRSimple [ Name "supplier" ]
                     , TRSimple [ Name "lineitem" ]
                     , TRSimple [ Name "orders" ]
                     , TRSimple [ Name "customer" ]
                     , TRAlias (TRSimple [ Name "nation" ]) (Alias (Name "n1") Nothing)
                     , TRAlias (TRSimple [ Name "nation" ]) (Alias (Name "n2") Nothing)
                     ]
                 , qeWhere =
                     Just
                       (BinOp
                          (BinOp
                             (BinOp
                                (BinOp
                                   (BinOp
                                      (BinOp
                                         (BinOp
                                            (Iden [ Name "s_suppkey" ])
                                            [ Name "=" ]
                                            (Iden [ Name "l_suppkey" ]))
                                         [ Name "and" ]
                                         (BinOp
                                            (Iden [ Name "o_orderkey" ])
                                            [ Name "=" ]
                                            (Iden [ Name "l_orderkey" ])))
                                      [ Name "and" ]
                                      (BinOp
                                         (Iden [ Name "c_custkey" ])
                                         [ Name "=" ]
                                         (Iden [ Name "o_custkey" ])))
                                   [ Name "and" ]
                                   (BinOp
                                      (Iden [ Name "s_nationkey" ])
                                      [ Name "=" ]
                                      (Iden [ Name "n1" , Name "n_nationkey" ])))
                                [ Name "and" ]
                                (BinOp
                                   (Iden [ Name "c_nationkey" ])
                                   [ Name "=" ]
                                   (Iden [ Name "n2" , Name "n_nationkey" ])))
                             [ Name "and" ]
                             (Parens
                                (BinOp
                                   (Parens
                                      (BinOp
                                         (BinOp
                                            (Iden [ Name "n1" , Name "n_name" ])
                                            [ Name "=" ]
                                            (StringLit "PERU"))
                                         [ Name "and" ]
                                         (BinOp
                                            (Iden [ Name "n2" , Name "n_name" ])
                                            [ Name "=" ]
                                            (StringLit "IRAQ"))))
                                   [ Name "or" ]
                                   (Parens
                                      (BinOp
                                         (BinOp
                                            (Iden [ Name "n1" , Name "n_name" ])
                                            [ Name "=" ]
                                            (StringLit "IRAQ"))
                                         [ Name "and" ]
                                         (BinOp
                                            (Iden [ Name "n2" , Name "n_name" ])
                                            [ Name "=" ]
                                            (StringLit "PERU")))))))
                          [ Name "and" ]
                          (SpecialOp
                             [ Name "between" ]
                             [ Iden [ Name "l_shipdate" ]
                             , TypedLit (TypeName [ Name "date" ]) "1995-01-01"
                             , TypedLit (TypeName [ Name "date" ]) "1996-12-31"
                             ]))
                 , qeGroupBy = []
                 , qeHaving = Nothing
                 , qeOrderBy = []
                 , qeOffset = Nothing
                 , qeFetchFirst = Nothing
                 })
            (Alias (Name "shipping") Nothing)
        ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "supp_nation" ])
        , SimpleGroup (Iden [ Name "cust_nation" ])
        , SimpleGroup (Iden [ Name "l_year" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec
            (Iden [ Name "supp_nation" ]) DirDefault NullsOrderDefault
        , SortSpec
            (Iden [ Name "cust_nation" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "l_year" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         o_year,
         sum(case
                 when nation = 'IRAQ' then volume
                 else 0
         end) / sum(volume) as mkt_share
 from
         (
                 select
                         extract(year from o_orderdate) as o_year,
                         l_extendedprice * (1 - l_discount) as volume,
                         n2.n_name as nation
                 from
                         part,
                         supplier,
                         lineitem,
                         orders,
                         customer,
                         nation n1,
                         nation n2,
                         region
                 where
                         p_partkey = l_partkey
                         and s_suppkey = l_suppkey
                         and l_orderkey = o_orderkey
                         and o_custkey = c_custkey
                         and c_nationkey = n1.n_nationkey
                         and n1.n_regionkey = r_regionkey
                         and r_name = 'MIDDLE EAST'
                         and s_nationkey = n2.n_nationkey
                         and o_orderdate between date '1995-01-01' and date '1996-12-31'
                         and p_type = 'STANDARD ANODIZED BRASS'
         ) as all_nations
 group by
         o_year
 order by
         o_year
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "o_year" ] , Nothing )
        , ( BinOp
              (App
                 [ Name "sum" ]
                 [ Case
                     { caseTest = Nothing
                     , caseWhens =
                         [ ( [ BinOp
                                 (Iden [ Name "nation" ]) [ Name "=" ] (StringLit "IRAQ")
                             ]
                           , Iden [ Name "volume" ]
                           )
                         ]
                     , caseElse = Just (NumLit "0")
                     }
                 ])
              [ Name "/" ]
              (App [ Name "sum" ] [ Iden [ Name "volume" ] ])
          , Just (Name "mkt_share")
          )
        ]
    , qeFrom =
        [ TRAlias
            (TRQueryExpr
               Select
                 { qeSetQuantifier = SQDefault
                 , qeSelectList =
                     [ ( SpecialOpK
                           [ Name "extract" ]
                           (Just (Iden [ Name "year" ]))
                           [ ( "from" , Iden [ Name "o_orderdate" ] ) ]
                       , Just (Name "o_year")
                       )
                     , ( BinOp
                           (Iden [ Name "l_extendedprice" ])
                           [ Name "*" ]
                           (Parens
                              (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
                       , Just (Name "volume")
                       )
                     , ( Iden [ Name "n2" , Name "n_name" ] , Just (Name "nation") )
                     ]
                 , qeFrom =
                     [ TRSimple [ Name "part" ]
                     , TRSimple [ Name "supplier" ]
                     , TRSimple [ Name "lineitem" ]
                     , TRSimple [ Name "orders" ]
                     , TRSimple [ Name "customer" ]
                     , TRAlias (TRSimple [ Name "nation" ]) (Alias (Name "n1") Nothing)
                     , TRAlias (TRSimple [ Name "nation" ]) (Alias (Name "n2") Nothing)
                     , TRSimple [ Name "region" ]
                     ]
                 , qeWhere =
                     Just
                       (BinOp
                          (BinOp
                             (BinOp
                                (BinOp
                                   (BinOp
                                      (BinOp
                                         (BinOp
                                            (BinOp
                                               (BinOp
                                                  (BinOp
                                                     (Iden [ Name "p_partkey" ])
                                                     [ Name "=" ]
                                                     (Iden [ Name "l_partkey" ]))
                                                  [ Name "and" ]
                                                  (BinOp
                                                     (Iden [ Name "s_suppkey" ])
                                                     [ Name "=" ]
                                                     (Iden [ Name "l_suppkey" ])))
                                               [ Name "and" ]
                                               (BinOp
                                                  (Iden [ Name "l_orderkey" ])
                                                  [ Name "=" ]
                                                  (Iden [ Name "o_orderkey" ])))
                                            [ Name "and" ]
                                            (BinOp
                                               (Iden [ Name "o_custkey" ])
                                               [ Name "=" ]
                                               (Iden [ Name "c_custkey" ])))
                                         [ Name "and" ]
                                         (BinOp
                                            (Iden [ Name "c_nationkey" ])
                                            [ Name "=" ]
                                            (Iden [ Name "n1" , Name "n_nationkey" ])))
                                      [ Name "and" ]
                                      (BinOp
                                         (Iden [ Name "n1" , Name "n_regionkey" ])
                                         [ Name "=" ]
                                         (Iden [ Name "r_regionkey" ])))
                                   [ Name "and" ]
                                   (BinOp
                                      (Iden [ Name "r_name" ])
                                      [ Name "=" ]
                                      (StringLit "MIDDLE EAST")))
                                [ Name "and" ]
                                (BinOp
                                   (Iden [ Name "s_nationkey" ])
                                   [ Name "=" ]
                                   (Iden [ Name "n2" , Name "n_nationkey" ])))
                             [ Name "and" ]
                             (SpecialOp
                                [ Name "between" ]
                                [ Iden [ Name "o_orderdate" ]
                                , TypedLit (TypeName [ Name "date" ]) "1995-01-01"
                                , TypedLit (TypeName [ Name "date" ]) "1996-12-31"
                                ]))
                          [ Name "and" ]
                          (BinOp
                             (Iden [ Name "p_type" ])
                             [ Name "=" ]
                             (StringLit "STANDARD ANODIZED BRASS")))
                 , qeGroupBy = []
                 , qeHaving = Nothing
                 , qeOrderBy = []
                 , qeOffset = Nothing
                 , qeFetchFirst = Nothing
                 })
            (Alias (Name "all_nations") Nothing)
        ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "o_year" ]) ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "o_year" ]) DirDefault NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         nation,
         o_year,
         sum(amount) as sum_profit
 from
         (
                 select
                         n_name as nation,
                         extract(year from o_orderdate) as o_year,
                         l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
                 from
                         part,
                         supplier,
                         lineitem,
                         partsupp,
                         orders,
                         nation
                 where
                         s_suppkey = l_suppkey
                         and ps_suppkey = l_suppkey
                         and ps_partkey = l_partkey
                         and p_partkey = l_partkey
                         and o_orderkey = l_orderkey
                         and s_nationkey = n_nationkey
                         and p_name like '%antique%'
         ) as profit
 group by
         nation,
         o_year
 order by
         nation,
         o_year desc
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "nation" ] , Nothing )
        , ( Iden [ Name "o_year" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "amount" ] ]
          , Just (Name "sum_profit")
          )
        ]
    , qeFrom =
        [ TRAlias
            (TRQueryExpr
               Select
                 { qeSetQuantifier = SQDefault
                 , qeSelectList =
                     [ ( Iden [ Name "n_name" ] , Just (Name "nation") )
                     , ( SpecialOpK
                           [ Name "extract" ]
                           (Just (Iden [ Name "year" ]))
                           [ ( "from" , Iden [ Name "o_orderdate" ] ) ]
                       , Just (Name "o_year")
                       )
                     , ( BinOp
                           (BinOp
                              (Iden [ Name "l_extendedprice" ])
                              [ Name "*" ]
                              (Parens
                                 (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ]))))
                           [ Name "-" ]
                           (BinOp
                              (Iden [ Name "ps_supplycost" ])
                              [ Name "*" ]
                              (Iden [ Name "l_quantity" ]))
                       , Just (Name "amount")
                       )
                     ]
                 , qeFrom =
                     [ TRSimple [ Name "part" ]
                     , TRSimple [ Name "supplier" ]
                     , TRSimple [ Name "lineitem" ]
                     , TRSimple [ Name "partsupp" ]
                     , TRSimple [ Name "orders" ]
                     , TRSimple [ Name "nation" ]
                     ]
                 , qeWhere =
                     Just
                       (BinOp
                          (BinOp
                             (BinOp
                                (BinOp
                                   (BinOp
                                      (BinOp
                                         (BinOp
                                            (Iden [ Name "s_suppkey" ])
                                            [ Name "=" ]
                                            (Iden [ Name "l_suppkey" ]))
                                         [ Name "and" ]
                                         (BinOp
                                            (Iden [ Name "ps_suppkey" ])
                                            [ Name "=" ]
                                            (Iden [ Name "l_suppkey" ])))
                                      [ Name "and" ]
                                      (BinOp
                                         (Iden [ Name "ps_partkey" ])
                                         [ Name "=" ]
                                         (Iden [ Name "l_partkey" ])))
                                   [ Name "and" ]
                                   (BinOp
                                      (Iden [ Name "p_partkey" ])
                                      [ Name "=" ]
                                      (Iden [ Name "l_partkey" ])))
                                [ Name "and" ]
                                (BinOp
                                   (Iden [ Name "o_orderkey" ])
                                   [ Name "=" ]
                                   (Iden [ Name "l_orderkey" ])))
                             [ Name "and" ]
                             (BinOp
                                (Iden [ Name "s_nationkey" ])
                                [ Name "=" ]
                                (Iden [ Name "n_nationkey" ])))
                          [ Name "and" ]
                          (BinOp
                             (Iden [ Name "p_name" ]) [ Name "like" ] (StringLit "%antique%")))
                 , qeGroupBy = []
                 , qeHaving = Nothing
                 , qeOrderBy = []
                 , qeOffset = Nothing
                 , qeFetchFirst = Nothing
                 })
            (Alias (Name "profit") Nothing)
        ]
    , qeWhere = Nothing
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "nation" ])
        , SimpleGroup (Iden [ Name "o_year" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "nation" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "o_year" ]) Desc NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         c_custkey,
         c_name,
         sum(l_extendedprice * (1 - l_discount)) as revenue,
         c_acctbal,
         n_name,
         c_address,
         c_phone,
         c_comment
 from
         customer,
         orders,
         lineitem,
         nation
 where
         c_custkey = o_custkey
         and l_orderkey = o_orderkey
         and o_orderdate >= date '1993-12-01'
         and o_orderdate < date '1993-12-01' + interval '3' month
         and l_returnflag = 'R'
         and c_nationkey = n_nationkey
 group by
         c_custkey,
         c_name,
         c_acctbal,
         c_phone,
         n_name,
         c_address,
         c_comment
 order by
         revenue desc
 fetch first 20 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "c_custkey" ] , Nothing )
        , ( Iden [ Name "c_name" ] , Nothing )
        , ( App
              [ Name "sum" ]
              [ BinOp
                  (Iden [ Name "l_extendedprice" ])
                  [ Name "*" ]
                  (Parens
                     (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
              ]
          , Just (Name "revenue")
          )
        , ( Iden [ Name "c_acctbal" ] , Nothing )
        , ( Iden [ Name "n_name" ] , Nothing )
        , ( Iden [ Name "c_address" ] , Nothing )
        , ( Iden [ Name "c_phone" ] , Nothing )
        , ( Iden [ Name "c_comment" ] , Nothing )
        ]
    , qeFrom =
        [ TRSimple [ Name "customer" ]
        , TRSimple [ Name "orders" ]
        , TRSimple [ Name "lineitem" ]
        , TRSimple [ Name "nation" ]
        ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (BinOp
                         (BinOp
                            (Iden [ Name "c_custkey" ])
                            [ Name "=" ]
                            (Iden [ Name "o_custkey" ]))
                         [ Name "and" ]
                         (BinOp
                            (Iden [ Name "l_orderkey" ])
                            [ Name "=" ]
                            (Iden [ Name "o_orderkey" ])))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "o_orderdate" ])
                         [ Name ">=" ]
                         (TypedLit (TypeName [ Name "date" ]) "1993-12-01")))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "o_orderdate" ])
                      [ Name "<" ]
                      (BinOp
                         (TypedLit (TypeName [ Name "date" ]) "1993-12-01")
                         [ Name "+" ]
                         IntervalLit
                           { ilSign = Nothing
                           , ilLiteral = "3"
                           , ilFrom = Itf "month" Nothing
                           , ilTo = Nothing
                           })))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "l_returnflag" ]) [ Name "=" ] (StringLit "R")))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "c_nationkey" ])
                [ Name "=" ]
                (Iden [ Name "n_nationkey" ])))
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "c_custkey" ])
        , SimpleGroup (Iden [ Name "c_name" ])
        , SimpleGroup (Iden [ Name "c_acctbal" ])
        , SimpleGroup (Iden [ Name "c_phone" ])
        , SimpleGroup (Iden [ Name "n_name" ])
        , SimpleGroup (Iden [ Name "c_address" ])
        , SimpleGroup (Iden [ Name "c_comment" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "revenue" ]) Desc NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Just (NumLit "20")
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         ps_partkey,
         sum(ps_supplycost * ps_availqty) as value
 from
         partsupp,
         supplier,
         nation
 where
         ps_suppkey = s_suppkey
         and s_nationkey = n_nationkey
         and n_name = 'CHINA'
 group by
         ps_partkey having
                 sum(ps_supplycost * ps_availqty) > (
                         select
                                 sum(ps_supplycost * ps_availqty) * 0.0001000000
                         from
                                 partsupp,
                                 supplier,
                                 nation
                         where
                                 ps_suppkey = s_suppkey
                                 and s_nationkey = n_nationkey
                                 and n_name = 'CHINA'
                 )
 order by
         value desc
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "ps_partkey" ] , Nothing )
        , ( App
              [ Name "sum" ]
              [ BinOp
                  (Iden [ Name "ps_supplycost" ])
                  [ Name "*" ]
                  (Iden [ Name "ps_availqty" ])
              ]
          , Just (Name "value")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "partsupp" ]
        , TRSimple [ Name "supplier" ]
        , TRSimple [ Name "nation" ]
        ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (Iden [ Name "ps_suppkey" ])
                   [ Name "=" ]
                   (Iden [ Name "s_suppkey" ]))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "s_nationkey" ])
                   [ Name "=" ]
                   (Iden [ Name "n_nationkey" ])))
             [ Name "and" ]
             (BinOp (Iden [ Name "n_name" ]) [ Name "=" ] (StringLit "CHINA")))
    , qeGroupBy = [ SimpleGroup (Iden [ Name "ps_partkey" ]) ]
    , qeHaving =
        Just
          (BinOp
             (App
                [ Name "sum" ]
                [ BinOp
                    (Iden [ Name "ps_supplycost" ])
                    [ Name "*" ]
                    (Iden [ Name "ps_availqty" ])
                ])
             [ Name ">" ]
             (SubQueryExpr
                SqSq
                Select
                  { qeSetQuantifier = SQDefault
                  , qeSelectList =
                      [ ( BinOp
                            (App
                               [ Name "sum" ]
                               [ BinOp
                                   (Iden [ Name "ps_supplycost" ])
                                   [ Name "*" ]
                                   (Iden [ Name "ps_availqty" ])
                               ])
                            [ Name "*" ]
                            (NumLit "0.0001000000")
                        , Nothing
                        )
                      ]
                  , qeFrom =
                      [ TRSimple [ Name "partsupp" ]
                      , TRSimple [ Name "supplier" ]
                      , TRSimple [ Name "nation" ]
                      ]
                  , qeWhere =
                      Just
                        (BinOp
                           (BinOp
                              (BinOp
                                 (Iden [ Name "ps_suppkey" ])
                                 [ Name "=" ]
                                 (Iden [ Name "s_suppkey" ]))
                              [ Name "and" ]
                              (BinOp
                                 (Iden [ Name "s_nationkey" ])
                                 [ Name "=" ]
                                 (Iden [ Name "n_nationkey" ])))
                           [ Name "and" ]
                           (BinOp (Iden [ Name "n_name" ]) [ Name "=" ] (StringLit "CHINA")))
                  , qeGroupBy = []
                  , qeHaving = Nothing
                  , qeOrderBy = []
                  , qeOffset = Nothing
                  , qeFetchFirst = Nothing
                  }))
    , qeOrderBy =
        [ SortSpec (Iden [ Name "value" ]) Desc NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         l_shipmode,
         sum(case
                 when o_orderpriority = '1-URGENT'
                         or o_orderpriority = '2-HIGH'
                         then 1
                 else 0
         end) as high_line_count,
         sum(case
                 when o_orderpriority <> '1-URGENT'
                         and o_orderpriority <> '2-HIGH'
                         then 1
                 else 0
         end) as low_line_count
 from
         orders,
         lineitem
 where
         o_orderkey = l_orderkey
         and l_shipmode in ('AIR', 'RAIL')
         and l_commitdate < l_receiptdate
         and l_shipdate < l_commitdate
         and l_receiptdate >= date '1994-01-01'
         and l_receiptdate < date '1994-01-01' + interval '1' year
 group by
         l_shipmode
 order by
         l_shipmode
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "l_shipmode" ] , Nothing )
        , ( App
              [ Name "sum" ]
              [ Case
                  { caseTest = Nothing
                  , caseWhens =
                      [ ( [ BinOp
                              (BinOp
                                 (Iden [ Name "o_orderpriority" ])
                                 [ Name "=" ]
                                 (StringLit "1-URGENT"))
                              [ Name "or" ]
                              (BinOp
                                 (Iden [ Name "o_orderpriority" ])
                                 [ Name "=" ]
                                 (StringLit "2-HIGH"))
                          ]
                        , NumLit "1"
                        )
                      ]
                  , caseElse = Just (NumLit "0")
                  }
              ]
          , Just (Name "high_line_count")
          )
        , ( App
              [ Name "sum" ]
              [ Case
                  { caseTest = Nothing
                  , caseWhens =
                      [ ( [ BinOp
                              (BinOp
                                 (Iden [ Name "o_orderpriority" ])
                                 [ Name "<>" ]
                                 (StringLit "1-URGENT"))
                              [ Name "and" ]
                              (BinOp
                                 (Iden [ Name "o_orderpriority" ])
                                 [ Name "<>" ]
                                 (StringLit "2-HIGH"))
                          ]
                        , NumLit "1"
                        )
                      ]
                  , caseElse = Just (NumLit "0")
                  }
              ]
          , Just (Name "low_line_count")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "orders" ] , TRSimple [ Name "lineitem" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (BinOp
                         (BinOp
                            (Iden [ Name "o_orderkey" ])
                            [ Name "=" ]
                            (Iden [ Name "l_orderkey" ]))
                         [ Name "and" ]
                         (In
                            True
                            (Iden [ Name "l_shipmode" ])
                            (InList [ StringLit "AIR" , StringLit "RAIL" ])))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "l_commitdate" ])
                         [ Name "<" ]
                         (Iden [ Name "l_receiptdate" ])))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "l_shipdate" ])
                      [ Name "<" ]
                      (Iden [ Name "l_commitdate" ])))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "l_receiptdate" ])
                   [ Name ">=" ]
                   (TypedLit (TypeName [ Name "date" ]) "1994-01-01")))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "l_receiptdate" ])
                [ Name "<" ]
                (BinOp
                   (TypedLit (TypeName [ Name "date" ]) "1994-01-01")
                   [ Name "+" ]
                   IntervalLit
                     { ilSign = Nothing
                     , ilLiteral = "1"
                     , ilFrom = Itf "year" Nothing
                     , ilTo = Nothing
                     })))
    , qeGroupBy = [ SimpleGroup (Iden [ Name "l_shipmode" ]) ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec
            (Iden [ Name "l_shipmode" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         c_count,
         count(*) as custdist
 from
         (
                 select
                         c_custkey,
                         count(o_orderkey)
                 from
                         customer left outer join orders on
                                 c_custkey = o_custkey
                                 and o_comment not like '%pending%requests%'
                 group by
                         c_custkey
         ) as c_orders (c_custkey, c_count)
 group by
         c_count
 order by
         custdist desc,
         c_count desc
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "c_count" ] , Nothing )
        , ( App [ Name "count" ] [ Star ] , Just (Name "custdist") )
        ]
    , qeFrom =
        [ TRAlias
            (TRQueryExpr
               Select
                 { qeSetQuantifier = SQDefault
                 , qeSelectList =
                     [ ( Iden [ Name "c_custkey" ] , Nothing )
                     , ( App [ Name "count" ] [ Iden [ Name "o_orderkey" ] ] , Nothing )
                     ]
                 , qeFrom =
                     [ TRJoin
                         (TRSimple [ Name "customer" ])
                         False
                         JLeft
                         (TRSimple [ Name "orders" ])
                         (Just
                            (JoinOn
                               (BinOp
                                  (BinOp
                                     (Iden [ Name "c_custkey" ])
                                     [ Name "=" ]
                                     (Iden [ Name "o_custkey" ]))
                                  [ Name "and" ]
                                  (BinOp
                                     (Iden [ Name "o_comment" ])
                                     [ Name "not like" ]
                                     (StringLit "%pending%requests%")))))
                     ]
                 , qeWhere = Nothing
                 , qeGroupBy = [ SimpleGroup (Iden [ Name "c_custkey" ]) ]
                 , qeHaving = Nothing
                 , qeOrderBy = []
                 , qeOffset = Nothing
                 , qeFetchFirst = Nothing
                 })
            (Alias
               (Name "c_orders") (Just [ Name "c_custkey" , Name "c_count" ]))
        ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "c_count" ]) ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "custdist" ]) Desc NullsOrderDefault
        , SortSpec (Iden [ Name "c_count" ]) Desc NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         100.00 * sum(case
                 when p_type like 'PROMO%'
                         then l_extendedprice * (1 - l_discount)
                 else 0
         end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
 from
         lineitem,
         part
 where
         l_partkey = p_partkey
         and l_shipdate >= date '1994-12-01'
         and l_shipdate < date '1994-12-01' + interval '1' month
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( BinOp
              (BinOp
                 (NumLit "100.00")
                 [ Name "*" ]
                 (App
                    [ Name "sum" ]
                    [ Case
                        { caseTest = Nothing
                        , caseWhens =
                            [ ( [ BinOp
                                    (Iden [ Name "p_type" ]) [ Name "like" ] (StringLit "PROMO%")
                                ]
                              , BinOp
                                  (Iden [ Name "l_extendedprice" ])
                                  [ Name "*" ]
                                  (Parens
                                     (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
                              )
                            ]
                        , caseElse = Just (NumLit "0")
                        }
                    ]))
              [ Name "/" ]
              (App
                 [ Name "sum" ]
                 [ BinOp
                     (Iden [ Name "l_extendedprice" ])
                     [ Name "*" ]
                     (Parens
                        (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
                 ])
          , Just (Name "promo_revenue")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "lineitem" ] , TRSimple [ Name "part" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (Iden [ Name "l_partkey" ])
                   [ Name "=" ]
                   (Iden [ Name "p_partkey" ]))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "l_shipdate" ])
                   [ Name ">=" ]
                   (TypedLit (TypeName [ Name "date" ]) "1994-12-01")))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "l_shipdate" ])
                [ Name "<" ]
                (BinOp
                   (TypedLit (TypeName [ Name "date" ]) "1994-12-01")
                   [ Name "+" ]
                   IntervalLit
                     { ilSign = Nothing
                     , ilLiteral = "1"
                     , ilFrom = Itf "month" Nothing
                     , ilTo = Nothing
                     })))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 /*create view revenue0 (supplier_no, total_revenue) as
         select
                 l_suppkey,
                 sum(l_extendedprice * (1 - l_discount))
         from
                 lineitem
         where
                 l_shipdate >= date '1995-06-01'
                 and l_shipdate < date '1995-06-01' + interval '3' month
         group by
                 l_suppkey;*/
 with
 revenue0 as
         (select
                 l_suppkey as supplier_no,
                 sum(l_extendedprice * (1 - l_discount)) as total_revenue
         from
                 lineitem
         where
                 l_shipdate >= date '1995-06-01'
                 and l_shipdate < date '1995-06-01' + interval '3' month
         group by
                 l_suppkey)
 select
         s_suppkey,
         s_name,
         s_address,
         s_phone,
         total_revenue
 from
         supplier,
         revenue0
 where
         s_suppkey = supplier_no
         and total_revenue = (
                 select
                         max(total_revenue)
                 from
                         revenue0
         )
 order by
         s_suppkey
~~~~
</td><td>
~~~~{.haskell}
Right
  With
    { qeWithRecursive = False
    , qeViews =
        [ ( Alias (Name "revenue0") Nothing
          , Select
              { qeSetQuantifier = SQDefault
              , qeSelectList =
                  [ ( Iden [ Name "l_suppkey" ] , Just (Name "supplier_no") )
                  , ( App
                        [ Name "sum" ]
                        [ BinOp
                            (Iden [ Name "l_extendedprice" ])
                            [ Name "*" ]
                            (Parens
                               (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
                        ]
                    , Just (Name "total_revenue")
                    )
                  ]
              , qeFrom = [ TRSimple [ Name "lineitem" ] ]
              , qeWhere =
                  Just
                    (BinOp
                       (BinOp
                          (Iden [ Name "l_shipdate" ])
                          [ Name ">=" ]
                          (TypedLit (TypeName [ Name "date" ]) "1995-06-01"))
                       [ Name "and" ]
                       (BinOp
                          (Iden [ Name "l_shipdate" ])
                          [ Name "<" ]
                          (BinOp
                             (TypedLit (TypeName [ Name "date" ]) "1995-06-01")
                             [ Name "+" ]
                             IntervalLit
                               { ilSign = Nothing
                               , ilLiteral = "3"
                               , ilFrom = Itf "month" Nothing
                               , ilTo = Nothing
                               })))
              , qeGroupBy = [ SimpleGroup (Iden [ Name "l_suppkey" ]) ]
              , qeHaving = Nothing
              , qeOrderBy = []
              , qeOffset = Nothing
              , qeFetchFirst = Nothing
              }
          )
        ]
    , qeQueryExpression =
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList =
              [ ( Iden [ Name "s_suppkey" ] , Nothing )
              , ( Iden [ Name "s_name" ] , Nothing )
              , ( Iden [ Name "s_address" ] , Nothing )
              , ( Iden [ Name "s_phone" ] , Nothing )
              , ( Iden [ Name "total_revenue" ] , Nothing )
              ]
          , qeFrom =
              [ TRSimple [ Name "supplier" ] , TRSimple [ Name "revenue0" ] ]
          , qeWhere =
              Just
                (BinOp
                   (BinOp
                      (Iden [ Name "s_suppkey" ])
                      [ Name "=" ]
                      (Iden [ Name "supplier_no" ]))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "total_revenue" ])
                      [ Name "=" ]
                      (SubQueryExpr
                         SqSq
                         Select
                           { qeSetQuantifier = SQDefault
                           , qeSelectList =
                               [ ( App [ Name "max" ] [ Iden [ Name "total_revenue" ] ]
                                 , Nothing
                                 )
                               ]
                           , qeFrom = [ TRSimple [ Name "revenue0" ] ]
                           , qeWhere = Nothing
                           , qeGroupBy = []
                           , qeHaving = Nothing
                           , qeOrderBy = []
                           , qeOffset = Nothing
                           , qeFetchFirst = Nothing
                           })))
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy =
              [ SortSpec (Iden [ Name "s_suppkey" ]) DirDefault NullsOrderDefault
              ]
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         p_brand,
         p_type,
         p_size,
         count(distinct ps_suppkey) as supplier_cnt
 from
         partsupp,
         part
 where
         p_partkey = ps_partkey
         and p_brand <> 'Brand#15'
         and p_type not like 'MEDIUM BURNISHED%'
         and p_size in (39, 26, 18, 45, 19, 1, 3, 9)
         and ps_suppkey not in (
                 select
                         s_suppkey
                 from
                         supplier
                 where
                         s_comment like '%Customer%Complaints%'
         )
 group by
         p_brand,
         p_type,
         p_size
 order by
         supplier_cnt desc,
         p_brand,
         p_type,
         p_size
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "p_brand" ] , Nothing )
        , ( Iden [ Name "p_type" ] , Nothing )
        , ( Iden [ Name "p_size" ] , Nothing )
        , ( AggregateApp
              { aggName = [ Name "count" ]
              , aggDistinct = Distinct
              , aggArgs = [ Iden [ Name "ps_suppkey" ] ]
              , aggOrderBy = []
              , aggFilter = Nothing
              }
          , Just (Name "supplier_cnt")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "partsupp" ] , TRSimple [ Name "part" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (BinOp
                         (Iden [ Name "p_partkey" ])
                         [ Name "=" ]
                         (Iden [ Name "ps_partkey" ]))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "p_brand" ]) [ Name "<>" ] (StringLit "Brand#15")))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "p_type" ])
                      [ Name "not like" ]
                      (StringLit "MEDIUM BURNISHED%")))
                [ Name "and" ]
                (In
                   True
                   (Iden [ Name "p_size" ])
                   (InList
                      [ NumLit "39"
                      , NumLit "26"
                      , NumLit "18"
                      , NumLit "45"
                      , NumLit "19"
                      , NumLit "1"
                      , NumLit "3"
                      , NumLit "9"
                      ])))
             [ Name "and" ]
             (In
                False
                (Iden [ Name "ps_suppkey" ])
                (InQueryExpr
                   Select
                     { qeSetQuantifier = SQDefault
                     , qeSelectList = [ ( Iden [ Name "s_suppkey" ] , Nothing ) ]
                     , qeFrom = [ TRSimple [ Name "supplier" ] ]
                     , qeWhere =
                         Just
                           (BinOp
                              (Iden [ Name "s_comment" ])
                              [ Name "like" ]
                              (StringLit "%Customer%Complaints%"))
                     , qeGroupBy = []
                     , qeHaving = Nothing
                     , qeOrderBy = []
                     , qeOffset = Nothing
                     , qeFetchFirst = Nothing
                     })))
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "p_brand" ])
        , SimpleGroup (Iden [ Name "p_type" ])
        , SimpleGroup (Iden [ Name "p_size" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "supplier_cnt" ]) Desc NullsOrderDefault
        , SortSpec (Iden [ Name "p_brand" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "p_type" ]) DirDefault NullsOrderDefault
        , SortSpec (Iden [ Name "p_size" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         sum(l_extendedprice) / 7.0 as avg_yearly
 from
         lineitem,
         part
 where
         p_partkey = l_partkey
         and p_brand = 'Brand#52'
         and p_container = 'JUMBO CAN'
         and l_quantity < (
                 select
                         0.2 * avg(l_quantity)
                 from
                         lineitem
                 where
                         l_partkey = p_partkey
         )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( BinOp
              (App [ Name "sum" ] [ Iden [ Name "l_extendedprice" ] ])
              [ Name "/" ]
              (NumLit "7.0")
          , Just (Name "avg_yearly")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "lineitem" ] , TRSimple [ Name "part" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (Iden [ Name "p_partkey" ])
                      [ Name "=" ]
                      (Iden [ Name "l_partkey" ]))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "p_brand" ]) [ Name "=" ] (StringLit "Brand#52")))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "p_container" ])
                   [ Name "=" ]
                   (StringLit "JUMBO CAN")))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "l_quantity" ])
                [ Name "<" ]
                (SubQueryExpr
                   SqSq
                   Select
                     { qeSetQuantifier = SQDefault
                     , qeSelectList =
                         [ ( BinOp
                               (NumLit "0.2")
                               [ Name "*" ]
                               (App [ Name "avg" ] [ Iden [ Name "l_quantity" ] ])
                           , Nothing
                           )
                         ]
                     , qeFrom = [ TRSimple [ Name "lineitem" ] ]
                     , qeWhere =
                         Just
                           (BinOp
                              (Iden [ Name "l_partkey" ])
                              [ Name "=" ]
                              (Iden [ Name "p_partkey" ]))
                     , qeGroupBy = []
                     , qeHaving = Nothing
                     , qeOrderBy = []
                     , qeOffset = Nothing
                     , qeFetchFirst = Nothing
                     })))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         c_name,
         c_custkey,
         o_orderkey,
         o_orderdate,
         o_totalprice,
         sum(l_quantity)
 from
         customer,
         orders,
         lineitem
 where
         o_orderkey in (
                 select
                         l_orderkey
                 from
                         lineitem
                 group by
                         l_orderkey having
                                 sum(l_quantity) > 313
         )
         and c_custkey = o_custkey
         and o_orderkey = l_orderkey
 group by
         c_name,
         c_custkey,
         o_orderkey,
         o_orderdate,
         o_totalprice
 order by
         o_totalprice desc,
         o_orderdate
 fetch first 100 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "c_name" ] , Nothing )
        , ( Iden [ Name "c_custkey" ] , Nothing )
        , ( Iden [ Name "o_orderkey" ] , Nothing )
        , ( Iden [ Name "o_orderdate" ] , Nothing )
        , ( Iden [ Name "o_totalprice" ] , Nothing )
        , ( App [ Name "sum" ] [ Iden [ Name "l_quantity" ] ] , Nothing )
        ]
    , qeFrom =
        [ TRSimple [ Name "customer" ]
        , TRSimple [ Name "orders" ]
        , TRSimple [ Name "lineitem" ]
        ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (In
                   True
                   (Iden [ Name "o_orderkey" ])
                   (InQueryExpr
                      Select
                        { qeSetQuantifier = SQDefault
                        , qeSelectList = [ ( Iden [ Name "l_orderkey" ] , Nothing ) ]
                        , qeFrom = [ TRSimple [ Name "lineitem" ] ]
                        , qeWhere = Nothing
                        , qeGroupBy = [ SimpleGroup (Iden [ Name "l_orderkey" ]) ]
                        , qeHaving =
                            Just
                              (BinOp
                                 (App [ Name "sum" ] [ Iden [ Name "l_quantity" ] ])
                                 [ Name ">" ]
                                 (NumLit "313"))
                        , qeOrderBy = []
                        , qeOffset = Nothing
                        , qeFetchFirst = Nothing
                        }))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "c_custkey" ])
                   [ Name "=" ]
                   (Iden [ Name "o_custkey" ])))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "o_orderkey" ])
                [ Name "=" ]
                (Iden [ Name "l_orderkey" ])))
    , qeGroupBy =
        [ SimpleGroup (Iden [ Name "c_name" ])
        , SimpleGroup (Iden [ Name "c_custkey" ])
        , SimpleGroup (Iden [ Name "o_orderkey" ])
        , SimpleGroup (Iden [ Name "o_orderdate" ])
        , SimpleGroup (Iden [ Name "o_totalprice" ])
        ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "o_totalprice" ]) Desc NullsOrderDefault
        , SortSpec
            (Iden [ Name "o_orderdate" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Just (NumLit "100")
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         sum(l_extendedprice* (1 - l_discount)) as revenue
 from
         lineitem,
         part
 where
         (
                 p_partkey = l_partkey
                 and p_brand = 'Brand#43'
                 and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
                 and l_quantity >= 3 and l_quantity <= 3 + 10
                 and p_size between 1 and 5
                 and l_shipmode in ('AIR', 'AIR REG')
                 and l_shipinstruct = 'DELIVER IN PERSON'
         )
         or
         (
                 p_partkey = l_partkey
                 and p_brand = 'Brand#25'
                 and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
                 and l_quantity >= 10 and l_quantity <= 10 + 10
                 and p_size between 1 and 10
                 and l_shipmode in ('AIR', 'AIR REG')
                 and l_shipinstruct = 'DELIVER IN PERSON'
         )
         or
         (
                 p_partkey = l_partkey
                 and p_brand = 'Brand#24'
                 and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
                 and l_quantity >= 22 and l_quantity <= 22 + 10
                 and p_size between 1 and 15
                 and l_shipmode in ('AIR', 'AIR REG')
                 and l_shipinstruct = 'DELIVER IN PERSON'
         )
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( App
              [ Name "sum" ]
              [ BinOp
                  (Iden [ Name "l_extendedprice" ])
                  [ Name "*" ]
                  (Parens
                     (BinOp (NumLit "1") [ Name "-" ] (Iden [ Name "l_discount" ])))
              ]
          , Just (Name "revenue")
          )
        ]
    , qeFrom =
        [ TRSimple [ Name "lineitem" ] , TRSimple [ Name "part" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (Parens
                   (BinOp
                      (BinOp
                         (BinOp
                            (BinOp
                               (BinOp
                                  (BinOp
                                     (BinOp
                                        (BinOp
                                           (Iden [ Name "p_partkey" ])
                                           [ Name "=" ]
                                           (Iden [ Name "l_partkey" ]))
                                        [ Name "and" ]
                                        (BinOp
                                           (Iden [ Name "p_brand" ])
                                           [ Name "=" ]
                                           (StringLit "Brand#43")))
                                     [ Name "and" ]
                                     (In
                                        True
                                        (Iden [ Name "p_container" ])
                                        (InList
                                           [ StringLit "SM CASE"
                                           , StringLit "SM BOX"
                                           , StringLit "SM PACK"
                                           , StringLit "SM PKG"
                                           ])))
                                  [ Name "and" ]
                                  (BinOp (Iden [ Name "l_quantity" ]) [ Name ">=" ] (NumLit "3")))
                               [ Name "and" ]
                               (BinOp
                                  (Iden [ Name "l_quantity" ])
                                  [ Name "<=" ]
                                  (BinOp (NumLit "3") [ Name "+" ] (NumLit "10"))))
                            [ Name "and" ]
                            (SpecialOp
                               [ Name "between" ]
                               [ Iden [ Name "p_size" ] , NumLit "1" , NumLit "5" ]))
                         [ Name "and" ]
                         (In
                            True
                            (Iden [ Name "l_shipmode" ])
                            (InList [ StringLit "AIR" , StringLit "AIR REG" ])))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "l_shipinstruct" ])
                         [ Name "=" ]
                         (StringLit "DELIVER IN PERSON"))))
                [ Name "or" ]
                (Parens
                   (BinOp
                      (BinOp
                         (BinOp
                            (BinOp
                               (BinOp
                                  (BinOp
                                     (BinOp
                                        (BinOp
                                           (Iden [ Name "p_partkey" ])
                                           [ Name "=" ]
                                           (Iden [ Name "l_partkey" ]))
                                        [ Name "and" ]
                                        (BinOp
                                           (Iden [ Name "p_brand" ])
                                           [ Name "=" ]
                                           (StringLit "Brand#25")))
                                     [ Name "and" ]
                                     (In
                                        True
                                        (Iden [ Name "p_container" ])
                                        (InList
                                           [ StringLit "MED BAG"
                                           , StringLit "MED BOX"
                                           , StringLit "MED PKG"
                                           , StringLit "MED PACK"
                                           ])))
                                  [ Name "and" ]
                                  (BinOp (Iden [ Name "l_quantity" ]) [ Name ">=" ] (NumLit "10")))
                               [ Name "and" ]
                               (BinOp
                                  (Iden [ Name "l_quantity" ])
                                  [ Name "<=" ]
                                  (BinOp (NumLit "10") [ Name "+" ] (NumLit "10"))))
                            [ Name "and" ]
                            (SpecialOp
                               [ Name "between" ]
                               [ Iden [ Name "p_size" ] , NumLit "1" , NumLit "10" ]))
                         [ Name "and" ]
                         (In
                            True
                            (Iden [ Name "l_shipmode" ])
                            (InList [ StringLit "AIR" , StringLit "AIR REG" ])))
                      [ Name "and" ]
                      (BinOp
                         (Iden [ Name "l_shipinstruct" ])
                         [ Name "=" ]
                         (StringLit "DELIVER IN PERSON")))))
             [ Name "or" ]
             (Parens
                (BinOp
                   (BinOp
                      (BinOp
                         (BinOp
                            (BinOp
                               (BinOp
                                  (BinOp
                                     (BinOp
                                        (Iden [ Name "p_partkey" ])
                                        [ Name "=" ]
                                        (Iden [ Name "l_partkey" ]))
                                     [ Name "and" ]
                                     (BinOp
                                        (Iden [ Name "p_brand" ])
                                        [ Name "=" ]
                                        (StringLit "Brand#24")))
                                  [ Name "and" ]
                                  (In
                                     True
                                     (Iden [ Name "p_container" ])
                                     (InList
                                        [ StringLit "LG CASE"
                                        , StringLit "LG BOX"
                                        , StringLit "LG PACK"
                                        , StringLit "LG PKG"
                                        ])))
                               [ Name "and" ]
                               (BinOp (Iden [ Name "l_quantity" ]) [ Name ">=" ] (NumLit "22")))
                            [ Name "and" ]
                            (BinOp
                               (Iden [ Name "l_quantity" ])
                               [ Name "<=" ]
                               (BinOp (NumLit "22") [ Name "+" ] (NumLit "10"))))
                         [ Name "and" ]
                         (SpecialOp
                            [ Name "between" ]
                            [ Iden [ Name "p_size" ] , NumLit "1" , NumLit "15" ]))
                      [ Name "and" ]
                      (In
                         True
                         (Iden [ Name "l_shipmode" ])
                         (InList [ StringLit "AIR" , StringLit "AIR REG" ])))
                   [ Name "and" ]
                   (BinOp
                      (Iden [ Name "l_shipinstruct" ])
                      [ Name "=" ]
                      (StringLit "DELIVER IN PERSON")))))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         s_name,
         s_address
 from
         supplier,
         nation
 where
         s_suppkey in (
                 select
                         ps_suppkey
                 from
                         partsupp
                 where
                         ps_partkey in (
                                 select
                                         p_partkey
                                 from
                                         part
                                 where
                                         p_name like 'lime%'
                         )
                         and ps_availqty > (
                                 select
                                         0.5 * sum(l_quantity)
                                 from
                                         lineitem
                                 where
                                         l_partkey = ps_partkey
                                         and l_suppkey = ps_suppkey
                                         and l_shipdate >= date '1994-01-01'
                                         and l_shipdate < date '1994-01-01' + interval '1' year
                         )
         )
         and s_nationkey = n_nationkey
         and n_name = 'VIETNAM'
 order by
         s_name
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "s_name" ] , Nothing )
        , ( Iden [ Name "s_address" ] , Nothing )
        ]
    , qeFrom =
        [ TRSimple [ Name "supplier" ] , TRSimple [ Name "nation" ] ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (In
                   True
                   (Iden [ Name "s_suppkey" ])
                   (InQueryExpr
                      Select
                        { qeSetQuantifier = SQDefault
                        , qeSelectList = [ ( Iden [ Name "ps_suppkey" ] , Nothing ) ]
                        , qeFrom = [ TRSimple [ Name "partsupp" ] ]
                        , qeWhere =
                            Just
                              (BinOp
                                 (In
                                    True
                                    (Iden [ Name "ps_partkey" ])
                                    (InQueryExpr
                                       Select
                                         { qeSetQuantifier = SQDefault
                                         , qeSelectList =
                                             [ ( Iden [ Name "p_partkey" ] , Nothing ) ]
                                         , qeFrom = [ TRSimple [ Name "part" ] ]
                                         , qeWhere =
                                             Just
                                               (BinOp
                                                  (Iden [ Name "p_name" ])
                                                  [ Name "like" ]
                                                  (StringLit "lime%"))
                                         , qeGroupBy = []
                                         , qeHaving = Nothing
                                         , qeOrderBy = []
                                         , qeOffset = Nothing
                                         , qeFetchFirst = Nothing
                                         }))
                                 [ Name "and" ]
                                 (BinOp
                                    (Iden [ Name "ps_availqty" ])
                                    [ Name ">" ]
                                    (SubQueryExpr
                                       SqSq
                                       Select
                                         { qeSetQuantifier = SQDefault
                                         , qeSelectList =
                                             [ ( BinOp
                                                   (NumLit "0.5")
                                                   [ Name "*" ]
                                                   (App
                                                      [ Name "sum" ] [ Iden [ Name "l_quantity" ] ])
                                               , Nothing
                                               )
                                             ]
                                         , qeFrom = [ TRSimple [ Name "lineitem" ] ]
                                         , qeWhere =
                                             Just
                                               (BinOp
                                                  (BinOp
                                                     (BinOp
                                                        (BinOp
                                                           (Iden [ Name "l_partkey" ])
                                                           [ Name "=" ]
                                                           (Iden [ Name "ps_partkey" ]))
                                                        [ Name "and" ]
                                                        (BinOp
                                                           (Iden [ Name "l_suppkey" ])
                                                           [ Name "=" ]
                                                           (Iden [ Name "ps_suppkey" ])))
                                                     [ Name "and" ]
                                                     (BinOp
                                                        (Iden [ Name "l_shipdate" ])
                                                        [ Name ">=" ]
                                                        (TypedLit
                                                           (TypeName [ Name "date" ])
                                                           "1994-01-01")))
                                                  [ Name "and" ]
                                                  (BinOp
                                                     (Iden [ Name "l_shipdate" ])
                                                     [ Name "<" ]
                                                     (BinOp
                                                        (TypedLit
                                                           (TypeName [ Name "date" ]) "1994-01-01")
                                                        [ Name "+" ]
                                                        IntervalLit
                                                          { ilSign = Nothing
                                                          , ilLiteral = "1"
                                                          , ilFrom = Itf "year" Nothing
                                                          , ilTo = Nothing
                                                          })))
                                         , qeGroupBy = []
                                         , qeHaving = Nothing
                                         , qeOrderBy = []
                                         , qeOffset = Nothing
                                         , qeFetchFirst = Nothing
                                         })))
                        , qeGroupBy = []
                        , qeHaving = Nothing
                        , qeOrderBy = []
                        , qeOffset = Nothing
                        , qeFetchFirst = Nothing
                        }))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "s_nationkey" ])
                   [ Name "=" ]
                   (Iden [ Name "n_nationkey" ])))
             [ Name "and" ]
             (BinOp
                (Iden [ Name "n_name" ]) [ Name "=" ] (StringLit "VIETNAM")))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "s_name" ]) DirDefault NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         s_name,
         count(*) as numwait
 from
         supplier,
         lineitem l1,
         orders,
         nation
 where
         s_suppkey = l1.l_suppkey
         and o_orderkey = l1.l_orderkey
         and o_orderstatus = 'F'
         and l1.l_receiptdate > l1.l_commitdate
         and exists (
                 select
                         *
                 from
                         lineitem l2
                 where
                         l2.l_orderkey = l1.l_orderkey
                         and l2.l_suppkey <> l1.l_suppkey
         )
         and not exists (
                 select
                         *
                 from
                         lineitem l3
                 where
                         l3.l_orderkey = l1.l_orderkey
                         and l3.l_suppkey <> l1.l_suppkey
                         and l3.l_receiptdate > l3.l_commitdate
         )
         and s_nationkey = n_nationkey
         and n_name = 'INDIA'
 group by
         s_name
 order by
         numwait desc,
         s_name
 fetch first 100 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "s_name" ] , Nothing )
        , ( App [ Name "count" ] [ Star ] , Just (Name "numwait") )
        ]
    , qeFrom =
        [ TRSimple [ Name "supplier" ]
        , TRAlias
            (TRSimple [ Name "lineitem" ]) (Alias (Name "l1") Nothing)
        , TRSimple [ Name "orders" ]
        , TRSimple [ Name "nation" ]
        ]
    , qeWhere =
        Just
          (BinOp
             (BinOp
                (BinOp
                   (BinOp
                      (BinOp
                         (BinOp
                            (BinOp
                               (BinOp
                                  (Iden [ Name "s_suppkey" ])
                                  [ Name "=" ]
                                  (Iden [ Name "l1" , Name "l_suppkey" ]))
                               [ Name "and" ]
                               (BinOp
                                  (Iden [ Name "o_orderkey" ])
                                  [ Name "=" ]
                                  (Iden [ Name "l1" , Name "l_orderkey" ])))
                            [ Name "and" ]
                            (BinOp
                               (Iden [ Name "o_orderstatus" ]) [ Name "=" ] (StringLit "F")))
                         [ Name "and" ]
                         (BinOp
                            (Iden [ Name "l1" , Name "l_receiptdate" ])
                            [ Name ">" ]
                            (Iden [ Name "l1" , Name "l_commitdate" ])))
                      [ Name "and" ]
                      (SubQueryExpr
                         SqExists
                         Select
                           { qeSetQuantifier = SQDefault
                           , qeSelectList = [ ( Star , Nothing ) ]
                           , qeFrom =
                               [ TRAlias
                                   (TRSimple [ Name "lineitem" ]) (Alias (Name "l2") Nothing)
                               ]
                           , qeWhere =
                               Just
                                 (BinOp
                                    (BinOp
                                       (Iden [ Name "l2" , Name "l_orderkey" ])
                                       [ Name "=" ]
                                       (Iden [ Name "l1" , Name "l_orderkey" ]))
                                    [ Name "and" ]
                                    (BinOp
                                       (Iden [ Name "l2" , Name "l_suppkey" ])
                                       [ Name "<>" ]
                                       (Iden [ Name "l1" , Name "l_suppkey" ])))
                           , qeGroupBy = []
                           , qeHaving = Nothing
                           , qeOrderBy = []
                           , qeOffset = Nothing
                           , qeFetchFirst = Nothing
                           }))
                   [ Name "and" ]
                   (PrefixOp
                      [ Name "not" ]
                      (SubQueryExpr
                         SqExists
                         Select
                           { qeSetQuantifier = SQDefault
                           , qeSelectList = [ ( Star , Nothing ) ]
                           , qeFrom =
                               [ TRAlias
                                   (TRSimple [ Name "lineitem" ]) (Alias (Name "l3") Nothing)
                               ]
                           , qeWhere =
                               Just
                                 (BinOp
                                    (BinOp
                                       (BinOp
                                          (Iden [ Name "l3" , Name "l_orderkey" ])
                                          [ Name "=" ]
                                          (Iden [ Name "l1" , Name "l_orderkey" ]))
                                       [ Name "and" ]
                                       (BinOp
                                          (Iden [ Name "l3" , Name "l_suppkey" ])
                                          [ Name "<>" ]
                                          (Iden [ Name "l1" , Name "l_suppkey" ])))
                                    [ Name "and" ]
                                    (BinOp
                                       (Iden [ Name "l3" , Name "l_receiptdate" ])
                                       [ Name ">" ]
                                       (Iden [ Name "l3" , Name "l_commitdate" ])))
                           , qeGroupBy = []
                           , qeHaving = Nothing
                           , qeOrderBy = []
                           , qeOffset = Nothing
                           , qeFetchFirst = Nothing
                           })))
                [ Name "and" ]
                (BinOp
                   (Iden [ Name "s_nationkey" ])
                   [ Name "=" ]
                   (Iden [ Name "n_nationkey" ])))
             [ Name "and" ]
             (BinOp (Iden [ Name "n_name" ]) [ Name "=" ] (StringLit "INDIA")))
    , qeGroupBy = [ SimpleGroup (Iden [ Name "s_name" ]) ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "numwait" ]) Desc NullsOrderDefault
        , SortSpec (Iden [ Name "s_name" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Just (NumLit "100")
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         cntrycode,
         count(*) as numcust,
         sum(c_acctbal) as totacctbal
 from
         (
                 select
                         substring(c_phone from 1 for 2) as cntrycode,
                         c_acctbal
                 from
                         customer
                 where
                         substring(c_phone from 1 for 2) in
                                 ('41', '28', '39', '21', '24', '29', '44')
                         and c_acctbal > (
                                 select
                                         avg(c_acctbal)
                                 from
                                         customer
                                 where
                                         c_acctbal > 0.00
                                         and substring(c_phone from 1 for 2) in
                                                 ('41', '28', '39', '21', '24', '29', '44')
                         )
                         and not exists (
                                 select
                                         *
                                 from
                                         orders
                                 where
                                         o_custkey = c_custkey
                         )
         ) as custsale
 group by
         cntrycode
 order by
         cntrycode
~~~~
</td><td>
~~~~{.haskell}
Right
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "cntrycode" ] , Nothing )
        , ( App [ Name "count" ] [ Star ] , Just (Name "numcust") )
        , ( App [ Name "sum" ] [ Iden [ Name "c_acctbal" ] ]
          , Just (Name "totacctbal")
          )
        ]
    , qeFrom =
        [ TRAlias
            (TRQueryExpr
               Select
                 { qeSetQuantifier = SQDefault
                 , qeSelectList =
                     [ ( SpecialOpK
                           [ Name "substring" ]
                           (Just (Iden [ Name "c_phone" ]))
                           [ ( "from" , NumLit "1" ) , ( "for" , NumLit "2" ) ]
                       , Just (Name "cntrycode")
                       )
                     , ( Iden [ Name "c_acctbal" ] , Nothing )
                     ]
                 , qeFrom = [ TRSimple [ Name "customer" ] ]
                 , qeWhere =
                     Just
                       (BinOp
                          (BinOp
                             (In
                                True
                                (SpecialOpK
                                   [ Name "substring" ]
                                   (Just (Iden [ Name "c_phone" ]))
                                   [ ( "from" , NumLit "1" ) , ( "for" , NumLit "2" ) ])
                                (InList
                                   [ StringLit "41"
                                   , StringLit "28"
                                   , StringLit "39"
                                   , StringLit "21"
                                   , StringLit "24"
                                   , StringLit "29"
                                   , StringLit "44"
                                   ]))
                             [ Name "and" ]
                             (BinOp
                                (Iden [ Name "c_acctbal" ])
                                [ Name ">" ]
                                (SubQueryExpr
                                   SqSq
                                   Select
                                     { qeSetQuantifier = SQDefault
                                     , qeSelectList =
                                         [ ( App [ Name "avg" ] [ Iden [ Name "c_acctbal" ] ]
                                           , Nothing
                                           )
                                         ]
                                     , qeFrom = [ TRSimple [ Name "customer" ] ]
                                     , qeWhere =
                                         Just
                                           (BinOp
                                              (BinOp
                                                 (Iden [ Name "c_acctbal" ])
                                                 [ Name ">" ]
                                                 (NumLit "0.00"))
                                              [ Name "and" ]
                                              (In
                                                 True
                                                 (SpecialOpK
                                                    [ Name "substring" ]
                                                    (Just (Iden [ Name "c_phone" ]))
                                                    [ ( "from" , NumLit "1" )
                                                    , ( "for" , NumLit "2" )
                                                    ])
                                                 (InList
                                                    [ StringLit "41"
                                                    , StringLit "28"
                                                    , StringLit "39"
                                                    , StringLit "21"
                                                    , StringLit "24"
                                                    , StringLit "29"
                                                    , StringLit "44"
                                                    ])))
                                     , qeGroupBy = []
                                     , qeHaving = Nothing
                                     , qeOrderBy = []
                                     , qeOffset = Nothing
                                     , qeFetchFirst = Nothing
                                     })))
                          [ Name "and" ]
                          (PrefixOp
                             [ Name "not" ]
                             (SubQueryExpr
                                SqExists
                                Select
                                  { qeSetQuantifier = SQDefault
                                  , qeSelectList = [ ( Star , Nothing ) ]
                                  , qeFrom = [ TRSimple [ Name "orders" ] ]
                                  , qeWhere =
                                      Just
                                        (BinOp
                                           (Iden [ Name "o_custkey" ])
                                           [ Name "=" ]
                                           (Iden [ Name "c_custkey" ]))
                                  , qeGroupBy = []
                                  , qeHaving = Nothing
                                  , qeOrderBy = []
                                  , qeOffset = Nothing
                                  , qeFetchFirst = Nothing
                                  })))
                 , qeGroupBy = []
                 , qeHaving = Nothing
                 , qeOrderBy = []
                 , qeOffset = Nothing
                 , qeFetchFirst = Nothing
                 })
            (Alias (Name "custsale") Nothing)
        ]
    , qeWhere = Nothing
    , qeGroupBy = [ SimpleGroup (Iden [ Name "cntrycode" ]) ]
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "cntrycode" ]) DirDefault NullsOrderDefault
        ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
## sql 2011 query tests
### literals
#### numeric literals
<table>
<tr><td>
~~~~{.sql}
11
~~~~
</td><td>
~~~~{.haskell}
NumLit "11"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11.11
~~~~
</td><td>
~~~~{.haskell}
NumLit "11.11"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11E23
~~~~
</td><td>
~~~~{.haskell}
NumLit "11E23"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11E+23
~~~~
</td><td>
~~~~{.haskell}
NumLit "11E+23"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11E-23
~~~~
</td><td>
~~~~{.haskell}
NumLit "11E-23"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11.11E23
~~~~
</td><td>
~~~~{.haskell}
NumLit "11.11E23"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11.11E+23
~~~~
</td><td>
~~~~{.haskell}
NumLit "11.11E+23"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11.11E-23
~~~~
</td><td>
~~~~{.haskell}
NumLit "11.11E-23"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+11E23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (NumLit "11E23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+11E+23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (NumLit "11E+23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+11E-23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (NumLit "11E-23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+11.11E23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (NumLit "11.11E23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+11.11E+23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (NumLit "11.11E+23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+11.11E-23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (NumLit "11.11E-23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-11E23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (NumLit "11E23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-11E+23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (NumLit "11E+23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-11E-23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (NumLit "11E-23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-11.11E23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (NumLit "11.11E23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-11.11E+23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (NumLit "11.11E+23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-11.11E-23
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (NumLit "11.11E-23")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
11.11e23
~~~~
</td><td>
~~~~{.haskell}
NumLit "11.11e23"
~~~~
</td></tr>
</table>
#### general literals
##### character string literals
<table>
<tr><td>
~~~~{.sql}
'a regular string literal'
~~~~
</td><td>
~~~~{.haskell}
StringLit "a regular string literal"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'something' ' some more' 'and more'
~~~~
</td><td>
~~~~{.haskell}
StringLit "something some moreand more"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'something' 
 ' some more' 	 'and more'
~~~~
</td><td>
~~~~{.haskell}
StringLit "something some moreand more"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'something' -- a comment
 ' some more' /*another comment*/ 'and more'
~~~~
</td><td>
~~~~{.haskell}
StringLit "something some moreand more"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'a quote: '', stuff'
~~~~
</td><td>
~~~~{.haskell}
StringLit "a quote: ', stuff"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
''
~~~~
</td><td>
~~~~{.haskell}
StringLit ""
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
_francais 'français'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "_francais" ]) "fran\231ais"
~~~~
</td></tr>
</table>
##### national character string literals
<table>
<tr><td>
~~~~{.sql}
N'something'
~~~~
</td><td>
~~~~{.haskell}
CSStringLit "N" "something"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
n'something'
~~~~
</td><td>
~~~~{.haskell}
CSStringLit "n" "something"
~~~~
</td></tr>
</table>
##### unicode character string literals
<table>
<tr><td>
~~~~{.sql}
U&'something'
~~~~
</td><td>
~~~~{.haskell}
CSStringLit "U&" "something"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
u&'something' escape =
~~~~
</td><td>
~~~~{.haskell}
Escape (CSStringLit "u&" "something") '='
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
u&'something' uescape =
~~~~
</td><td>
~~~~{.haskell}
UEscape (CSStringLit "u&" "something") '='
~~~~
</td></tr>
</table>
##### binary string literals
<table>
<tr><td>
~~~~{.sql}
X'7f7f7f'
~~~~
</td><td>
~~~~{.haskell}
CSStringLit "X" "7f7f7f"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
X'7f7f7f' escape z
~~~~
</td><td>
~~~~{.haskell}
Escape (CSStringLit "X" "7f7f7f") 'z'
~~~~
</td></tr>
</table>
##### datetime literals
##### intervalLiterals literals
<table>
<tr><td>
~~~~{.sql}
interval '1'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "interval" ]) "1"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '1' day
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Nothing
  , ilLiteral = "1"
  , ilFrom = Itf "day" Nothing
  , ilTo = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '1' day(3)
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Nothing
  , ilLiteral = "1"
  , ilFrom = Itf "day" (Just ( 3 , Nothing ))
  , ilTo = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval + '1' day(3)
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Just True
  , ilLiteral = "1"
  , ilFrom = Itf "day" (Just ( 3 , Nothing ))
  , ilTo = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval - '1' second(2,2)
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Just False
  , ilLiteral = "1"
  , ilFrom = Itf "second" (Just ( 2 , Just 2 ))
  , ilTo = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '1' year to month
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Nothing
  , ilLiteral = "1"
  , ilFrom = Itf "year" Nothing
  , ilTo = Just (Itf "month" Nothing)
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '1' year(4) to second(2,3) 
~~~~
</td><td>
~~~~{.haskell}
IntervalLit
  { ilSign = Nothing
  , ilLiteral = "1"
  , ilFrom = Itf "year" (Just ( 4 , Nothing ))
  , ilTo = Just (Itf "second" (Just ( 2 , Just 3 )))
  }
~~~~
</td></tr>
</table>
##### boolean literals
<table>
<tr><td>
~~~~{.sql}
true
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "true" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
false
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "false" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
unknown
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "unknown" ]
~~~~
</td></tr>
</table>
### identifiers
<table>
<tr><td>
~~~~{.sql}
test
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "test" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
_test
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "_test" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
t1
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "t1" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a.b
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "a" , Name "b" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a.b.c
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "a" , Name "b" , Name "c" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
"quoted iden"
~~~~
</td><td>
~~~~{.haskell}
Iden [ QName "quoted iden" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
"quoted "" iden"
~~~~
</td><td>
~~~~{.haskell}
Iden [ QName "quoted \" iden" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
U&"quoted iden"
~~~~
</td><td>
~~~~{.haskell}
Iden [ UQName "quoted iden" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
U&"quoted "" iden"
~~~~
</td><td>
~~~~{.haskell}
Iden [ UQName "quoted \" iden" ]
~~~~
</td></tr>
</table>
### type names
<table>
<tr><td>
~~~~{.sql}
cast('test' as binary)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "binary" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "binary" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary varying)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "binary varying" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary varying 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "binary varying" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "character" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "character" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "char" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "char" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character varying)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "character varying" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character varying 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "character varying" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "char varying" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "char varying" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varbinary)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "varbinary" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varbinary 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "varbinary" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "varchar" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "varchar" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character large object)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (TypeName [ Name "character large object" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character large object 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "character large object" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char large object)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "char large object" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char large object 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "char large object" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as clob)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "clob" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
clob 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "clob" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "national character" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "national character" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "national char" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "national char" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "nchar" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "nchar" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character varying)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (TypeName [ Name "national character varying" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character varying 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "national character varying" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char varying)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "national char varying" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char varying 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "national char varying" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar varying)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "nchar varying" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar varying 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "nchar varying" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (TypeName [ Name "national character large object" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (TypeName [ Name "national character large object" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar large object)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "nchar large object" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar large object 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "nchar large object" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nclob)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "nclob" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nclob 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "nclob" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary large object)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "binary large object" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary large object 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "binary large object" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "blob" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "blob" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as numeric)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "numeric" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
numeric 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "numeric" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "decimal" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "decimal" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as dec)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "dec" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
dec 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "dec" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as smallint)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "smallint" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
smallint 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "smallint" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as integer)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "integer" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
integer 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "integer" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as int)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "int" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
int 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "int" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as bigint)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "bigint" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
bigint 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "bigint" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as float)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "float" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
float 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "float" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as real)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "real" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
real 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "real" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as double precision)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "double precision" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
double precision 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "double precision" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as boolean)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "boolean" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
boolean 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "boolean" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as date)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "date" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
date 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "date" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "time" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "time" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as timestamp)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TypeName [ Name "timestamp" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
timestamp 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName [ Name "timestamp" ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5))
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (PrecTypeName [ Name "char" ] 5)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (PrecTypeName [ Name "char" ] 5) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5))
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (PrecTypeName [ Name "char varying" ] 5)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (PrecTypeName [ Name "char varying" ] 5) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal(15,2))
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (PrecScaleTypeName [ Name "decimal" ] 15 2)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal(15,2) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (PrecScaleTypeName [ Name "decimal" ] 15 2) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(3 octets))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(3 octets) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar(50 characters))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName
     [ Name "varchar" ] 50 Nothing (Just PrecCharacters))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar(50 characters) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName
     [ Name "varchar" ] 50 Nothing (Just PrecCharacters))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3M))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3M) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3T))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3T) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3P))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3P) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(4M characters) )
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName
     [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(4M characters)  'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName
     [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(6G octets) )
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName
     [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(6G octets)  'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName
     [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object(7K) )
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (PrecLengthTypeName
     [ Name "national character large object" ] 7 (Just PrecK) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object(7K)  'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (PrecLengthTypeName
     [ Name "national character large object" ] 7 (Just PrecK) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time with time zone)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "test") (TimeTypeName [ Name "time" ] Nothing True)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time with time zone 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TimeTypeName [ Name "time" ] Nothing True) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as datetime(3) without time zone)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (TimeTypeName [ Name "datetime" ] (Just 3) False)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
datetime(3) without time zone 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TimeTypeName [ Name "datetime" ] (Just 3) False) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char varying" ]
     (Just 5)
     [ Name "something" ]
     [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char varying" ]
     (Just 5)
     [ Name "something" ]
     [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char" ]
     (Just 5)
     [ Name "something" ]
     [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char" ]
     (Just 5)
     [ Name "something" ]
     [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char varying" ]
     Nothing
     [ Name "something" ]
     [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char varying" ]
     Nothing
     [ Name "something" ]
     [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char" ]
     Nothing
     [ Name "something" ]
     [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char" ]
     Nothing
     [ Name "something" ]
     [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char varying" ]
     (Just 5)
     []
     [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char varying" ]
     (Just 5)
     []
     [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char varying" ]
     Nothing
     []
     [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char varying" ]
     Nothing
     []
     [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char collate something_insensitive)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char" ] Nothing [] [ Name "something_insensitive" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char collate something_insensitive 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char" ] Nothing [] [ Name "something_insensitive" ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char varying" ] (Just 5) [ Name "something" ] [])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char varying" ] (Just 5) [ Name "something" ] [])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] [])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] [])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char varying" ] Nothing [ Name "something" ] [])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char varying" ] Nothing [ Name "something" ] [])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName [ Name "char" ] Nothing [ Name "something" ] [])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName [ Name "char" ] Nothing [ Name "something" ] [])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (CharTypeName
     [ Name "char varying" ] Nothing [ Name "something" ] [])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (CharTypeName
     [ Name "char varying" ] Nothing [ Name "something" ] [])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ]) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int,b char))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (RowTypeName
     [ ( Name "a" , TypeName [ Name "int" ] )
     , ( Name "b" , TypeName [ Name "char" ] )
     ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int,b char) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (RowTypeName
     [ ( Name "a" , TypeName [ Name "int" ] )
     , ( Name "b" , TypeName [ Name "char" ] )
     ])
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (IntervalTypeName (Itf "year" Nothing) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (IntervalTypeName (Itf "year" Nothing) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(2))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(2) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval second(2,5))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval second(2,5) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year to month)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (IntervalTypeName
     (Itf "year" Nothing) (Just (Itf "month" Nothing)))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year to month 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (IntervalTypeName
     (Itf "year" Nothing) (Just (Itf "month" Nothing)))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(4) to second(2,3))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (IntervalTypeName
     (Itf "year" (Just ( 4 , Nothing )))
     (Just (Itf "second" (Just ( 2 , Just 3 )))))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(4) to second(2,3) 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (IntervalTypeName
     (Itf "year" (Just ( 4 , Nothing )))
     (Just (Itf "second" (Just ( 2 , Just 3 )))))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "binary" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "binary" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "binary" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "binary" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary varying array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "binary varying" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary varying array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "binary varying" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary varying array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "binary varying" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary varying array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "binary varying" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "character" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "character" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "character" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "character" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "char" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "char" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "char" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "char" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character varying array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "character varying" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character varying array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "character varying" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character varying array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "character varying" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character varying array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "character varying" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "char varying" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "char varying" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "char varying" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "char varying" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varbinary array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "varbinary" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varbinary array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "varbinary" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varbinary array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "varbinary" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varbinary array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "varbinary" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "varchar" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "varchar" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "varchar" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "varchar" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character large object array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TypeName [ Name "character large object" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character large object array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TypeName [ Name "character large object" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character large object array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TypeName [ Name "character large object" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character large object array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TypeName [ Name "character large object" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char large object array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "char large object" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char large object array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "char large object" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char large object array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "char large object" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char large object array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "char large object" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as clob array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "clob" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
clob array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "clob" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as clob array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "clob" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
clob array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "clob" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "national character" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "national character" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "national character" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "national character" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "national char" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "national char" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "national char" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "national char" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nchar" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "nchar" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nchar" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "nchar" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character varying array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TypeName [ Name "national character varying" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character varying array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TypeName [ Name "national character varying" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character varying array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TypeName [ Name "national character varying" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character varying array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TypeName [ Name "national character varying" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char varying array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "national char varying" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char varying array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "national char varying" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char varying array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TypeName [ Name "national char varying" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char varying array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TypeName [ Name "national char varying" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar varying array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nchar varying" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar varying array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "nchar varying" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar varying array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nchar varying" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar varying array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "nchar varying" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TypeName [ Name "national character large object" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TypeName [ Name "national character large object" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TypeName [ Name "national character large object" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TypeName [ Name "national character large object" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar large object array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nchar large object" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar large object array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "nchar large object" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar large object array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nchar large object" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar large object array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "nchar large object" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nclob array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nclob" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nclob array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "nclob" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nclob array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "nclob" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nclob array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "nclob" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary large object array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "binary large object" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary large object array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "binary large object" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary large object array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "binary large object" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary large object array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "binary large object" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "blob" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "blob" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "blob" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "blob" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as numeric array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "numeric" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
numeric array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "numeric" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as numeric array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "numeric" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
numeric array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "numeric" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "decimal" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "decimal" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "decimal" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "decimal" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as dec array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "dec" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
dec array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "dec" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as dec array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "dec" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
dec array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "dec" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as smallint array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "smallint" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
smallint array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "smallint" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as smallint array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "smallint" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
smallint array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "smallint" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as integer array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "integer" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
integer array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "integer" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as integer array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "integer" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
integer array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "integer" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as int array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "int" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
int array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "int" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as int array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "int" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
int array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "int" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as bigint array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "bigint" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
bigint array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "bigint" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as bigint array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "bigint" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
bigint array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "bigint" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as float array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "float" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
float array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "float" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as float array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "float" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
float array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "float" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as real array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "real" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
real array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "real" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as real array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "real" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
real array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "real" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as double precision array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "double precision" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
double precision array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "double precision" ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as double precision array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "double precision" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
double precision array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "double precision" ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as boolean array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "boolean" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
boolean array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "boolean" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as boolean array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "boolean" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
boolean array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "boolean" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as date array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "date" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
date array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "date" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as date array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "date" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
date array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "date" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "time" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "time" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "time" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (ArrayTypeName (TypeName [ Name "time" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as timestamp array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "timestamp" ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
timestamp array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "timestamp" ]) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as timestamp array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TypeName [ Name "timestamp" ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
timestamp array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TypeName [ Name "timestamp" ]) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (PrecTypeName [ Name "char" ] 5) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (PrecTypeName [ Name "char" ] 5) Nothing) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (PrecTypeName [ Name "char" ] 5) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (PrecTypeName [ Name "char" ] 5) (Just 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (PrecTypeName [ Name "char varying" ] 5) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (PrecTypeName [ Name "char varying" ] 5) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (PrecTypeName [ Name "char varying" ] 5) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (PrecTypeName [ Name "char varying" ] 5) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal(15,2) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (PrecScaleTypeName [ Name "decimal" ] 15 2) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal(15,2) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (PrecScaleTypeName [ Name "decimal" ] 15 2) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal(15,2) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecScaleTypeName [ Name "decimal" ] 15 2) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal(15,2) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecScaleTypeName [ Name "decimal" ] 15 2) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(3 octets) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets))
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(3 octets) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets))
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(3 octets) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets))
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(3 octets) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets))
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar(50 characters) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "varchar" ] 50 Nothing (Just PrecCharacters))
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar(50 characters) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "varchar" ] 50 Nothing (Just PrecCharacters))
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar(50 characters) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "varchar" ] 50 Nothing (Just PrecCharacters))
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar(50 characters) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "varchar" ] 50 Nothing (Just PrecCharacters))
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3M) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing)
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3M) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing)
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3M) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing)
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3M) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing)
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3T) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing)
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3T) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing)
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3T) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing)
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3T) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing)
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3P) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing)
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3P) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing)
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3P) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing)
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3P) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing)
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(4M characters)  array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters))
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(4M characters)  array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters))
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(4M characters)  array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters))
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(4M characters)  array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters))
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(6G octets)  array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets))
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(6G octets)  array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets))
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(6G octets)  array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets))
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(6G octets)  array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets))
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object(7K)  array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "national character large object" ] 7 (Just PrecK) Nothing)
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object(7K)  array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "national character large object" ] 7 (Just PrecK) Nothing)
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object(7K)  array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "national character large object" ] 7 (Just PrecK) Nothing)
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object(7K)  array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (PrecLengthTypeName
        [ Name "national character large object" ] 7 (Just PrecK) Nothing)
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time with time zone array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName (TimeTypeName [ Name "time" ] Nothing True) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time with time zone array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName (TimeTypeName [ Name "time" ] Nothing True) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time with time zone array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TimeTypeName [ Name "time" ] Nothing True) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time with time zone array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TimeTypeName [ Name "time" ] Nothing True) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as datetime(3) without time zone array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TimeTypeName [ Name "datetime" ] (Just 3) False) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
datetime(3) without time zone array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TimeTypeName [ Name "datetime" ] (Just 3) False) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as datetime(3) without time zone array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (TimeTypeName [ Name "datetime" ] (Just 3) False) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
datetime(3) without time zone array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (TimeTypeName [ Name "datetime" ] (Just 3) False) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        []
        [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        []
        [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        []
        [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        []
        [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        []
        [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        []
        [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        []
        [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        []
        [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char collate something_insensitive array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] Nothing [] [ Name "something_insensitive" ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char collate something_insensitive array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] Nothing [] [ Name "something_insensitive" ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char collate something_insensitive array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] Nothing [] [ Name "something_insensitive" ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char collate something_insensitive array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char" ] Nothing [] [ Name "something_insensitive" ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] (Just 5) [ Name "something" ] [])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] (Just 5) [ Name "something" ] [])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] (Just 5) [ Name "something" ] [])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] (Just 5) [ Name "something" ] [])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] [])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] [])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] [])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] [])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName [ Name "char" ] Nothing [ Name "something" ] [])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName [ Name "char" ] Nothing [ Name "something" ] [])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName [ Name "char" ] Nothing [ Name "something" ] [])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName [ Name "char" ] Nothing [ Name "something" ] [])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] [])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ]) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ]) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ]) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ]) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int,b char) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (RowTypeName
        [ ( Name "a" , TypeName [ Name "int" ] )
        , ( Name "b" , TypeName [ Name "char" ] )
        ])
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int,b char) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (RowTypeName
        [ ( Name "a" , TypeName [ Name "int" ] )
        , ( Name "b" , TypeName [ Name "char" ] )
        ])
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int,b char) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (RowTypeName
        [ ( Name "a" , TypeName [ Name "int" ] )
        , ( Name "b" , TypeName [ Name "char" ] )
        ])
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int,b char) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (RowTypeName
        [ ( Name "a" , TypeName [ Name "int" ] )
        , ( Name "b" , TypeName [ Name "char" ] )
        ])
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName (Itf "year" Nothing) Nothing) Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName (Itf "year" Nothing) Nothing) Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName (Itf "year" Nothing) Nothing) (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName (Itf "year" Nothing) Nothing) (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(2) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing)
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(2) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing)
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(2) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing)
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(2) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing)
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval second(2,5) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing)
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval second(2,5) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing)
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval second(2,5) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing)
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval second(2,5) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing)
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year to month array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" Nothing) (Just (Itf "month" Nothing)))
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year to month array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" Nothing) (Just (Itf "month" Nothing)))
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year to month array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" Nothing) (Just (Itf "month" Nothing)))
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year to month array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" Nothing) (Just (Itf "month" Nothing)))
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(4) to second(2,3) array)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" (Just ( 4 , Nothing )))
        (Just (Itf "second" (Just ( 2 , Just 3 )))))
     Nothing)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(4) to second(2,3) array 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" (Just ( 4 , Nothing )))
        (Just (Itf "second" (Just ( 2 , Just 3 )))))
     Nothing)
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(4) to second(2,3) array[5])
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" (Just ( 4 , Nothing )))
        (Just (Itf "second" (Just ( 2 , Just 3 )))))
     (Just 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(4) to second(2,3) array[5] 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (ArrayTypeName
     (IntervalTypeName
        (Itf "year" (Just ( 4 , Nothing )))
        (Just (Itf "second" (Just ( 2 , Just 3 )))))
     (Just 5))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "binary" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "binary" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary varying multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "binary varying" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary varying multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "binary varying" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "character" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "character" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "char" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "char" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character varying multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "character varying" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character varying multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "character varying" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "char varying" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "char varying" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varbinary multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "varbinary" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varbinary multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "varbinary" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "varchar" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "varchar" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as character large object multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "character large object" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
character large object multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "character large object" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char large object multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "char large object" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char large object multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "char large object" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as clob multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "clob" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
clob multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "clob" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "national character" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "national character" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "national char" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "national char" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "nchar" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "nchar" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character varying multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "national character varying" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character varying multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "national character varying" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national char varying multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "national char varying" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national char varying multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "national char varying" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar varying multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "nchar varying" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar varying multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "nchar varying" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (TypeName [ Name "national character large object" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (TypeName [ Name "national character large object" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nchar large object multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "nchar large object" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nchar large object multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "nchar large object" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as nclob multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "nclob" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
nclob multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "nclob" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as binary large object multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "binary large object" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
binary large object multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "binary large object" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "blob" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "blob" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as numeric multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "numeric" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
numeric multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "numeric" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "decimal" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "decimal" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as dec multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "dec" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
dec multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "dec" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as smallint multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "smallint" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
smallint multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "smallint" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as integer multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "integer" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
integer multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "integer" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as int multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "int" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
int multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "int" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as bigint multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "bigint" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
bigint multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "bigint" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as float multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "float" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
float multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "float" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as real multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "real" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
real multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "real" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as double precision multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "double precision" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
double precision multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TypeName [ Name "double precision" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as boolean multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "boolean" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
boolean multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "boolean" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as date multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "date" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
date multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "date" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test") (MultisetTypeName (TypeName [ Name "time" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "time" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as timestamp multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TypeName [ Name "timestamp" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
timestamp multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (TypeName [ Name "timestamp" ])) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (PrecTypeName [ Name "char" ] 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (MultisetTypeName (PrecTypeName [ Name "char" ] 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (PrecTypeName [ Name "char varying" ] 5))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (PrecTypeName [ Name "char varying" ] 5)) "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as decimal(15,2) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (PrecScaleTypeName [ Name "decimal" ] 15 2))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
decimal(15,2) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (PrecScaleTypeName [ Name "decimal" ] 15 2))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(3 octets) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets)))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(3 octets) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName [ Name "char" ] 3 Nothing (Just PrecOctets)))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as varchar(50 characters) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "varchar" ] 50 Nothing (Just PrecCharacters)))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
varchar(50 characters) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "varchar" ] 50 Nothing (Just PrecCharacters)))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3M) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3M) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecM) Nothing))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3T) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3T) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecT) Nothing))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(3P) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(3P) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName [ Name "blob" ] 3 (Just PrecP) Nothing))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(4M characters)  multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters)))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(4M characters)  multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 4 (Just PrecM) (Just PrecCharacters)))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as blob(6G octets)  multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets)))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
blob(6G octets)  multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "blob" ] 6 (Just PrecG) (Just PrecOctets)))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as national character large object(7K)  multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "national character large object" ] 7 (Just PrecK) Nothing))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
national character large object(7K)  multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (PrecLengthTypeName
        [ Name "national character large object" ] 7 (Just PrecK) Nothing))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as time with time zone multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (TimeTypeName [ Name "time" ] Nothing True))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
time with time zone multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (TimeTypeName [ Name "time" ] Nothing True))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as datetime(3) without time zone multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (TimeTypeName [ Name "datetime" ] (Just 3) False))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
datetime(3) without time zone multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (TimeTypeName [ Name "datetime" ] (Just 3) False))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ]
        (Just 5)
        [ Name "something" ]
        [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ]
        Nothing
        [ Name "something" ]
        [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        []
        [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        (Just 5)
        []
        [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ] (Just 5) [] [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        []
        [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ]
        Nothing
        []
        [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char collate something_insensitive multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ] Nothing [] [ Name "something_insensitive" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char collate something_insensitive multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char" ] Nothing [] [ Name "something_insensitive" ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying(5) character set something multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ] (Just 5) [ Name "something" ] []))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying(5) character set something multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ] (Just 5) [ Name "something" ] []))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char(5) character set something multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] []))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char(5) character set something multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName [ Name "char" ] (Just 5) [ Name "something" ] []))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] []))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] []))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char character set something multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName [ Name "char" ] Nothing [ Name "something" ] []))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char character set something multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName [ Name "char" ] Nothing [ Name "something" ] []))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as char varying character set something multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] []))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
char varying character set something multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (CharTypeName
        [ Name "char varying" ] Nothing [ Name "something" ] []))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (RowTypeName [ ( Name "a" , TypeName [ Name "int" ] ) ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as row(a int,b char) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (RowTypeName
        [ ( Name "a" , TypeName [ Name "int" ] )
        , ( Name "b" , TypeName [ Name "char" ] )
        ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(a int,b char) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (RowTypeName
        [ ( Name "a" , TypeName [ Name "int" ] )
        , ( Name "b" , TypeName [ Name "char" ] )
        ]))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName (IntervalTypeName (Itf "year" Nothing) Nothing))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName (IntervalTypeName (Itf "year" Nothing) Nothing))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(2) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(2) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (IntervalTypeName (Itf "year" (Just ( 2 , Nothing ))) Nothing))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval second(2,5) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval second(2,5) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (IntervalTypeName (Itf "second" (Just ( 2 , Just 5 ))) Nothing))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year to month multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (IntervalTypeName
        (Itf "year" Nothing) (Just (Itf "month" Nothing))))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year to month multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (IntervalTypeName
        (Itf "year" Nothing) (Just (Itf "month" Nothing))))
  "test"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('test' as interval year(4) to second(2,3) multiset)
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "test")
  (MultisetTypeName
     (IntervalTypeName
        (Itf "year" (Just ( 4 , Nothing )))
        (Just (Itf "second" (Just ( 2 , Just 3 ))))))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval year(4) to second(2,3) multiset 'test'
~~~~
</td><td>
~~~~{.haskell}
TypedLit
  (MultisetTypeName
     (IntervalTypeName
        (Itf "year" (Just ( 4 , Nothing )))
        (Just (Itf "second" (Just ( 2 , Just 3 ))))))
  "test"
~~~~
</td></tr>
</table>
### field definition
<table>
<tr><td>
~~~~{.sql}
cast('(1,2)' as row(a int,b char))
~~~~
</td><td>
~~~~{.haskell}
Cast
  (StringLit "(1,2)")
  (RowTypeName
     [ ( Name "a" , TypeName [ Name "int" ] )
     , ( Name "b" , TypeName [ Name "char" ] )
     ])
~~~~
</td></tr>
</table>
### value expressions
#### general value specification
<table>
<tr><td>
~~~~{.sql}
CURRENT_DEFAULT_TRANSFORM_GROUP
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "CURRENT_DEFAULT_TRANSFORM_GROUP" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
CURRENT_PATH
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "CURRENT_PATH" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
CURRENT_ROLE
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "CURRENT_ROLE" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
CURRENT_USER
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "CURRENT_USER" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SESSION_USER
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "SESSION_USER" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SYSTEM_USER
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "SYSTEM_USER" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
USER
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "USER" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
VALUE
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "VALUE" ]
~~~~
</td></tr>
</table>
#### parameter specification
<table>
<tr><td>
~~~~{.sql}
:hostparam
~~~~
</td><td>
~~~~{.haskell}
HostParameter "hostparam" Nothing
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
:hostparam indicator :another_host_param
~~~~
</td><td>
~~~~{.haskell}
HostParameter "hostparam" (Just "another_host_param")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
?
~~~~
</td><td>
~~~~{.haskell}
Parameter
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
:h[3]
~~~~
</td><td>
~~~~{.haskell}
Array (HostParameter "h" Nothing) [ NumLit "3" ]
~~~~
</td></tr>
</table>
#### contextually typed value specification
<table>
<tr><td>
~~~~{.sql}
null
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "null" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
array[]
~~~~
</td><td>
~~~~{.haskell}
Array (Iden [ Name "array" ]) []
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
multiset[]
~~~~
</td><td>
~~~~{.haskell}
MultisetCtor []
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
default
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "default" ]
~~~~
</td></tr>
</table>
#### identifier chain
<table>
<tr><td>
~~~~{.sql}
a.b
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "a" , Name "b" ]
~~~~
</td></tr>
</table>
#### column reference
<table>
<tr><td>
~~~~{.sql}
module.a.b
~~~~
</td><td>
~~~~{.haskell}
Iden [ Name "module" , Name "a" , Name "b" ]
~~~~
</td></tr>
</table>
#### set function specification
<table>
<tr><td>
~~~~{.sql}
SELECT SalesQuota, SUM(SalesYTD) TotalSalesYTD,
   GROUPING(SalesQuota) AS Grouping
FROM Sales.SalesPerson
GROUP BY ROLLUP(SalesQuota);
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "SalesQuota" ] , Nothing )
      , ( App [ Name "SUM" ] [ Iden [ Name "SalesYTD" ] ]
        , Just (Name "TotalSalesYTD")
        )
      , ( App [ Name "GROUPING" ] [ Iden [ Name "SalesQuota" ] ]
        , Just (Name "Grouping")
        )
      ]
  , qeFrom = [ TRSimple [ Name "Sales" , Name "SalesPerson" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ Rollup [ SimpleGroup (Iden [ Name "SalesQuota" ]) ] ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### window function
#### nested window function
#### case expression
#### cast specification
<table>
<tr><td>
~~~~{.sql}
cast(a as int)
~~~~
</td><td>
~~~~{.haskell}
Cast (Iden [ Name "a" ]) (TypeName [ Name "int" ])
~~~~
</td></tr>
</table>
#### next value expression
<table>
<tr><td>
~~~~{.sql}
next value for a.b
~~~~
</td><td>
~~~~{.haskell}
NextValueFor [ Name "a" , Name "b" ]
~~~~
</td></tr>
</table>
#### field reference
<table>
<tr><td>
~~~~{.sql}
f(something).a
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (App [ Name "f" ] [ Iden [ Name "something" ] ])
  [ Name "." ]
  (Iden [ Name "a" ])
~~~~
</td></tr>
</table>
#### array element reference
<table>
<tr><td>
~~~~{.sql}
something[3]
~~~~
</td><td>
~~~~{.haskell}
Array (Iden [ Name "something" ]) [ NumLit "3" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(something(a))[x]
~~~~
</td><td>
~~~~{.haskell}
Array
  (Parens (App [ Name "something" ] [ Iden [ Name "a" ] ]))
  [ Iden [ Name "x" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(something(a))[x][y] 
~~~~
</td><td>
~~~~{.haskell}
Array
  (Array
     (Parens (App [ Name "something" ] [ Iden [ Name "a" ] ]))
     [ Iden [ Name "x" ] ])
  [ Iden [ Name "y" ] ]
~~~~
</td></tr>
</table>
#### multisetElementReference
<table>
<tr><td>
~~~~{.sql}
element(something)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "element" ] [ Iden [ Name "something" ] ]
~~~~
</td></tr>
</table>
#### numeric value expression
<table>
<tr><td>
~~~~{.sql}
a + b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "+" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a - b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "-" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a * b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "*" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a / b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "/" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "+" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "-" ] (Iden [ Name "a" ])
~~~~
</td></tr>
</table>
#### numeric value function
#### string value expression
#### string value function
#### datetime value expression
##### datetime value function
#### datetime value function
#### interval value expression
#### interval value function
#### booleab value expression
<table>
<tr><td>
~~~~{.sql}
a or b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "or" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a and b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "and" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
not a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp [ Name "not" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is true
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is true" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is false
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is false" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is unknown
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is unknown" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not true
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is not true" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not false
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is not false" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not unknown
~~~~
</td><td>
~~~~{.haskell}
PostfixOp [ Name "is not unknown" ] (Iden [ Name "a" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(a or b)
~~~~
</td><td>
~~~~{.haskell}
Parens
  (BinOp (Iden [ Name "a" ]) [ Name "or" ] (Iden [ Name "b" ]))
~~~~
</td></tr>
</table>
#### array value expression
#### array value function
#### array value constructor
<table>
<tr><td>
~~~~{.sql}
array[1,2,3]
~~~~
</td><td>
~~~~{.haskell}
Array
  (Iden [ Name "array" ]) [ NumLit "1" , NumLit "2" , NumLit "3" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
array[a,b,c]
~~~~
</td><td>
~~~~{.haskell}
Array
  (Iden [ Name "array" ])
  [ Iden [ Name "a" ] , Iden [ Name "b" ] , Iden [ Name "c" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
array(select * from t)
~~~~
</td><td>
~~~~{.haskell}
ArrayCtor
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
array(select * from t order by a)
~~~~
</td><td>
~~~~{.haskell}
ArrayCtor
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy =
        [ SortSpec (Iden [ Name "a" ]) DirDefault NullsOrderDefault ]
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
#### multiset value expression
<table>
<tr><td>
~~~~{.sql}
a multiset union b
~~~~
</td><td>
~~~~{.haskell}
MultisetBinOp
  (Iden [ Name "a" ]) Union SQDefault (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a multiset union all b
~~~~
</td><td>
~~~~{.haskell}
MultisetBinOp (Iden [ Name "a" ]) Union All (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a multiset union distinct b
~~~~
</td><td>
~~~~{.haskell}
MultisetBinOp
  (Iden [ Name "a" ]) Union Distinct (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a multiset except b
~~~~
</td><td>
~~~~{.haskell}
MultisetBinOp
  (Iden [ Name "a" ]) Except SQDefault (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a multiset intersect b
~~~~
</td><td>
~~~~{.haskell}
MultisetBinOp
  (Iden [ Name "a" ]) Intersect SQDefault (Iden [ Name "b" ])
~~~~
</td></tr>
</table>
#### multiset value function
<table>
<tr><td>
~~~~{.sql}
set(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "set" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
</table>
#### multiset value constructor
<table>
<tr><td>
~~~~{.sql}
multiset[a,b,c]
~~~~
</td><td>
~~~~{.haskell}
MultisetCtor
  [ Iden [ Name "a" ] , Iden [ Name "b" ] , Iden [ Name "c" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
multiset(select * from t)
~~~~
</td><td>
~~~~{.haskell}
MultisetQueryCtor
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
table(select * from t)
~~~~
</td><td>
~~~~{.haskell}
MultisetQueryCtor
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
#### parenthesized value expression
<table>
<tr><td>
~~~~{.sql}
(3)
~~~~
</td><td>
~~~~{.haskell}
Parens (NumLit "3")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
((3))
~~~~
</td><td>
~~~~{.haskell}
Parens (Parens (NumLit "3"))
~~~~
</td></tr>
</table>
### query expressions
#### row value constructor
<table>
<tr><td>
~~~~{.sql}
(a,b)
~~~~
</td><td>
~~~~{.haskell}
SpecialOp
  [ Name "rowctor" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(1)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "row" ] [ NumLit "1" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
row(1,2)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "row" ] [ NumLit "1" , NumLit "2" ]
~~~~
</td></tr>
</table>
#### table value constructor
<table>
<tr><td>
~~~~{.sql}
values (1,2), (a+b,(select count(*) from t));
~~~~
</td><td>
~~~~{.haskell}
Values
  [ [ NumLit "1" , NumLit "2" ]
  , [ BinOp (Iden [ Name "a" ]) [ Name "+" ] (Iden [ Name "b" ])
    , SubQueryExpr
        SqSq
        Select
          { qeSetQuantifier = SQDefault
          , qeSelectList = [ ( App [ Name "count" ] [ Star ] , Nothing ) ]
          , qeFrom = [ TRSimple [ Name "t" ] ]
          , qeWhere = Nothing
          , qeGroupBy = []
          , qeHaving = Nothing
          , qeOrderBy = []
          , qeOffset = Nothing
          , qeFetchFirst = Nothing
          }
    ]
  ]
~~~~
</td></tr>
</table>
#### fromClause
<table>
<tr><td>
~~~~{.sql}
select * from tbl1,tbl2
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "tbl1" ] , TRSimple [ Name "tbl2" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### table reference
<table>
<tr><td>
~~~~{.sql}
select * from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias (TRSimple [ Name "t" ]) (Alias (Name "u") Nothing) ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t as u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias (TRSimple [ Name "t" ]) (Alias (Name "u") Nothing) ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t u(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRSimple [ Name "t" ])
          (Alias (Name "u") (Just [ Name "a" , Name "b" ]))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t as u(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRSimple [ Name "t" ])
          (Alias (Name "u") (Just [ Name "a" , Name "b" ]))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from (select * from t) u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRQueryExpr
             Select
               { qeSetQuantifier = SQDefault
               , qeSelectList = [ ( Star , Nothing ) ]
               , qeFrom = [ TRSimple [ Name "t" ] ]
               , qeWhere = Nothing
               , qeGroupBy = []
               , qeHaving = Nothing
               , qeOrderBy = []
               , qeOffset = Nothing
               , qeFetchFirst = Nothing
               })
          (Alias (Name "u") Nothing)
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from lateral t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRLateral (TRSimple [ Name "t" ]) ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from (a join b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRParens
          (TRJoin
             (TRSimple [ Name "a" ])
             False
             JInner
             (TRSimple [ Name "b" ])
             Nothing)
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from (a join b) u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRParens
             (TRJoin
                (TRSimple [ Name "a" ])
                False
                JInner
                (TRSimple [ Name "b" ])
                Nothing))
          (Alias (Name "u") Nothing)
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from ((a join b)) u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRParens
             (TRParens
                (TRJoin
                   (TRSimple [ Name "a" ])
                   False
                   JInner
                   (TRSimple [ Name "b" ])
                   Nothing)))
          (Alias (Name "u") Nothing)
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from ((a join b) u) u
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRAlias
          (TRParens
             (TRAlias
                (TRParens
                   (TRJoin
                      (TRSimple [ Name "a" ])
                      False
                      JInner
                      (TRSimple [ Name "b" ])
                      Nothing))
                (Alias (Name "u") Nothing)))
          (Alias (Name "u") Nothing)
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### joined table
<table>
<tr><td>
~~~~{.sql}
select * from a cross join b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JCross
          (TRSimple [ Name "b" ])
          Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a join b on true
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JInner
          (TRSimple [ Name "b" ])
          (Just (JoinOn (Iden [ Name "true" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a join b using (c)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JInner
          (TRSimple [ Name "b" ])
          (Just (JoinUsing [ Name "c" ]))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a inner join b on true
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JInner
          (TRSimple [ Name "b" ])
          (Just (JoinOn (Iden [ Name "true" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a left join b on true
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JLeft
          (TRSimple [ Name "b" ])
          (Just (JoinOn (Iden [ Name "true" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a left outer join b on true
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JLeft
          (TRSimple [ Name "b" ])
          (Just (JoinOn (Iden [ Name "true" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a right join b on true
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JRight
          (TRSimple [ Name "b" ])
          (Just (JoinOn (Iden [ Name "true" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a full join b on true
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ])
          False
          JFull
          (TRSimple [ Name "b" ])
          (Just (JoinOn (Iden [ Name "true" ])))
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a natural join b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ]) True JInner (TRSimple [ Name "b" ]) Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a natural inner join b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ]) True JInner (TRSimple [ Name "b" ]) Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a natural left join b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ]) True JLeft (TRSimple [ Name "b" ]) Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a natural left outer join b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ]) True JLeft (TRSimple [ Name "b" ]) Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a natural right join b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ]) True JRight (TRSimple [ Name "b" ]) Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from a natural full join b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom =
      [ TRJoin
          (TRSimple [ Name "a" ]) True JFull (TRSimple [ Name "b" ]) Nothing
      ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### where clause
<table>
<tr><td>
~~~~{.sql}
select * from t where a = 5
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere =
      Just (BinOp (Iden [ Name "a" ]) [ Name "=" ] (NumLit "5"))
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### group by clause
<table>
<tr><td>
~~~~{.sql}
select a,sum(x) from t group by a
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = [ SimpleGroup (Iden [ Name "a" ]) ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,sum(x) from t group by a collate c
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ SimpleGroup (Collate (Iden [ Name "a" ]) [ Name "c" ]) ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b,sum(x) from t group by a,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( Iden [ Name "b" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ SimpleGroup (Iden [ Name "a" ])
      , SimpleGroup (Iden [ Name "b" ])
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b,sum(x) from t group by rollup(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( Iden [ Name "b" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ Rollup
          [ SimpleGroup (Iden [ Name "a" ])
          , SimpleGroup (Iden [ Name "b" ])
          ]
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b,sum(x) from t group by cube(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( Iden [ Name "b" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ Cube
          [ SimpleGroup (Iden [ Name "a" ])
          , SimpleGroup (Iden [ Name "b" ])
          ]
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b,sum(x) from t group by grouping sets((),(a,b))
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( Iden [ Name "b" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy =
      [ GroupingSets
          [ GroupingParens []
          , GroupingParens
              [ SimpleGroup (Iden [ Name "a" ])
              , SimpleGroup (Iden [ Name "b" ])
              ]
          ]
      ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select sum(x) from t group by ()
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = [ GroupingParens [] ]
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### having clause
<table>
<tr><td>
~~~~{.sql}
select a,sum(x) from t group by a having sum(x) > 1000
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( App [ Name "sum" ] [ Iden [ Name "x" ] ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = [ SimpleGroup (Iden [ Name "a" ]) ]
  , qeHaving =
      Just
        (BinOp
           (App [ Name "sum" ] [ Iden [ Name "x" ] ])
           [ Name ">" ]
           (NumLit "1000"))
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### window clause
#### query specification
<table>
<tr><td>
~~~~{.sql}
select a from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select all a from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = All
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select distinct a from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = Distinct
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a.* from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( BinOp (Iden [ Name "a" ]) [ Name "." ] Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a b from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Just (Name "b") ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a as b from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Just (Name "b") ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b from t
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList =
      [ ( Iden [ Name "a" ] , Nothing )
      , ( Iden [ Name "b" ] , Nothing )
      ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
#### with query expression
#### set operation query expression
#### explicit table query expression
<table>
<tr><td>
~~~~{.sql}
table t
~~~~
</td><td>
~~~~{.haskell}
Table [ Name "t" ]
~~~~
</td></tr>
</table>
#### order, offset, fetch query expression
<table>
<tr><td>
~~~~{.sql}
select a from t order by a
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) DirDefault NullsOrderDefault ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t offset 5 row
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Just (NumLit "5")
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t offset 5 rows
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Just (NumLit "5")
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t fetch first 5 row only
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Just (NumLit "5")
  }
~~~~
</td></tr>
</table>
#### search or cycle clause
### scalar subquery
### predicates
#### comparison predicates
<table>
<tr><td>
~~~~{.sql}
a = b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "=" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a <> b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "<>" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a < b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "<" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a > b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name ">" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a <= b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name "<=" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a >= b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden [ Name "a" ]) [ Name ">=" ] (Iden [ Name "b" ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
ROW(a) = ROW(b)
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (App [ Name "ROW" ] [ Iden [ Name "a" ] ])
  [ Name "=" ]
  (App [ Name "ROW" ] [ Iden [ Name "b" ] ])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(a,b) = (c,d)
~~~~
</td><td>
~~~~{.haskell}
BinOp
  (SpecialOp
     [ Name "rowctor" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ])
  [ Name "=" ]
  (SpecialOp
     [ Name "rowctor" ] [ Iden [ Name "c" ] , Iden [ Name "d" ] ])
~~~~
</td></tr>
</table>
#### between predicate
#### in predicate
#### like predicate
#### similar predicate
#### regex like predicate
#### null predicate
#### quantified comparison predicate
<table>
<tr><td>
~~~~{.sql}
a = any (select * from t)
~~~~
</td><td>
~~~~{.haskell}
QuantifiedComparison
  (Iden [ Name "a" ])
  [ Name "=" ]
  CPAny
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a <= some (select * from t)
~~~~
</td><td>
~~~~{.haskell}
QuantifiedComparison
  (Iden [ Name "a" ])
  [ Name "<=" ]
  CPSome
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a > all (select * from t)
~~~~
</td><td>
~~~~{.haskell}
QuantifiedComparison
  (Iden [ Name "a" ])
  [ Name ">" ]
  CPAll
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(a,b) <> all (select * from t)
~~~~
</td><td>
~~~~{.haskell}
QuantifiedComparison
  (SpecialOp
     [ Name "rowctor" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ])
  [ Name "<>" ]
  CPAll
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
#### exists predicate
<table>
<tr><td>
~~~~{.sql}
exists(select * from t where a = 4)
~~~~
</td><td>
~~~~{.haskell}
SubQueryExpr
  SqExists
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere =
        Just (BinOp (Iden [ Name "a" ]) [ Name "=" ] (NumLit "4"))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
#### unique predicate
<table>
<tr><td>
~~~~{.sql}
unique(select * from t where a = 4)
~~~~
</td><td>
~~~~{.haskell}
SubQueryExpr
  SqUnique
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Star , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere =
        Just (BinOp (Iden [ Name "a" ]) [ Name "=" ] (NumLit "4"))
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
#### normalized predicate
#### match predicate
<table>
<tr><td>
~~~~{.sql}
a match (select a from t)
~~~~
</td><td>
~~~~{.haskell}
Match
  (Iden [ Name "a" ])
  False
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList = [ ( Iden [ Name "a" ] , Nothing ) ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(a,b) match (select a,b from t)
~~~~
</td><td>
~~~~{.haskell}
Match
  (SpecialOp
     [ Name "rowctor" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ])
  False
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "a" ] , Nothing )
        , ( Iden [ Name "b" ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(a,b) match unique (select a,b from t)
~~~~
</td><td>
~~~~{.haskell}
Match
  (SpecialOp
     [ Name "rowctor" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ])
  True
  Select
    { qeSetQuantifier = SQDefault
    , qeSelectList =
        [ ( Iden [ Name "a" ] , Nothing )
        , ( Iden [ Name "b" ] , Nothing )
        ]
    , qeFrom = [ TRSimple [ Name "t" ] ]
    , qeWhere = Nothing
    , qeGroupBy = []
    , qeHaving = Nothing
    , qeOrderBy = []
    , qeOffset = Nothing
    , qeFetchFirst = Nothing
    }
~~~~
</td></tr>
</table>
#### overlaps predicate
#### distinct predicate
#### member predicate
#### submultiset predicate
#### set predicate
#### period predicate
### interval qualifier
### collate clause
<table>
<tr><td>
~~~~{.sql}
a collate my_collation
~~~~
</td><td>
~~~~{.haskell}
Collate (Iden [ Name "a" ]) [ Name "my_collation" ]
~~~~
</td></tr>
</table>
### aggregate function
<table>
<tr><td>
~~~~{.sql}
count(*)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "count" ] [ Star ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(*) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "count" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Star ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "count" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "count" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(all a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "count" ]
  , aggDistinct = All
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(all a) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "count" ]
  , aggDistinct = All
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
avg(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "avg" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
avg(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "avg" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
max(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "max" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
max(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "max" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
min(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "min" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
min(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "min" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "sum" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "sum" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
every(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "every" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
every(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "every" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
any(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "any" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
any(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "any" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
some(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "some" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
some(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "some" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
stddev_pop(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "stddev_pop" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
stddev_pop(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "stddev_pop" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
stddev_samp(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "stddev_samp" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
stddev_samp(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "stddev_samp" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
var_samp(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "var_samp" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
var_samp(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "var_samp" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
var_pop(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "var_pop" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
var_pop(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "var_pop" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
collect(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "collect" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
collect(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "collect" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
fusion(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "fusion" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
fusion(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "fusion" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
intersection(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "intersection" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
intersection(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "intersection" ]
  , aggDistinct = Distinct
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy = []
  , aggFilter = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
COVAR_POP(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "COVAR_POP" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
COVAR_POP(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "COVAR_POP" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
COVAR_SAMP(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "COVAR_SAMP" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
COVAR_SAMP(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "COVAR_SAMP" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
CORR(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "CORR" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
CORR(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "CORR" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SLOPE(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_SLOPE" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SLOPE(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_SLOPE" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_INTERCEPT(a,b)
~~~~
</td><td>
~~~~{.haskell}
App
  [ Name "REGR_INTERCEPT" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_INTERCEPT(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_INTERCEPT" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_COUNT(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_COUNT" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_COUNT(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_COUNT" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_R2(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_R2" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_R2(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_R2" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_AVGX(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_AVGX" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_AVGX(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_AVGX" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_AVGY(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_AVGY" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_AVGY(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_AVGY" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SXX(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_SXX" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SXX(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_SXX" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SYY(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_SYY" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SYY(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_SYY" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SXY(a,b)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "REGR_SXY" ] [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
REGR_SXY(a,b) filter (where something > 5)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "REGR_SXY" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "b" ] ]
  , aggOrderBy = []
  , aggFilter =
      Just (BinOp (Iden [ Name "something" ]) [ Name ">" ] (NumLit "5"))
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
rank(a,c) within group (order by b)
~~~~
</td><td>
~~~~{.haskell}
AggregateAppGroup
  { aggName = [ Name "rank" ]
  , aggArgs = [ Iden [ Name "a" ] , Iden [ Name "c" ] ]
  , aggGroup =
      [ SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault ]
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
dense_rank(a) within group (order by b)
~~~~
</td><td>
~~~~{.haskell}
AggregateAppGroup
  { aggName = [ Name "dense_rank" ]
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggGroup =
      [ SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault ]
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
percent_rank(a) within group (order by b)
~~~~
</td><td>
~~~~{.haskell}
AggregateAppGroup
  { aggName = [ Name "percent_rank" ]
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggGroup =
      [ SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault ]
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cume_dist(a) within group (order by b)
~~~~
</td><td>
~~~~{.haskell}
AggregateAppGroup
  { aggName = [ Name "cume_dist" ]
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggGroup =
      [ SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault ]
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
percentile_cont(a) within group (order by b)
~~~~
</td><td>
~~~~{.haskell}
AggregateAppGroup
  { aggName = [ Name "percentile_cont" ]
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggGroup =
      [ SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault ]
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
percentile_disc(a) within group (order by b)
~~~~
</td><td>
~~~~{.haskell}
AggregateAppGroup
  { aggName = [ Name "percentile_disc" ]
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggGroup =
      [ SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault ]
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
array_agg(a)
~~~~
</td><td>
~~~~{.haskell}
App [ Name "array_agg" ] [ Iden [ Name "a" ] ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
array_agg(a order by z)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp
  { aggName = [ Name "array_agg" ]
  , aggDistinct = SQDefault
  , aggArgs = [ Iden [ Name "a" ] ]
  , aggOrderBy =
      [ SortSpec (Iden [ Name "z" ]) DirDefault NullsOrderDefault ]
  , aggFilter = Nothing
  }
~~~~
</td></tr>
</table>
### sort specification list
<table>
<tr><td>
~~~~{.sql}
select * from t order by a
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) DirDefault NullsOrderDefault ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t order by a,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) DirDefault NullsOrderDefault
      , SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t order by a asc,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) Asc NullsOrderDefault
      , SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t order by a desc,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (Iden [ Name "a" ]) Desc NullsOrderDefault
      , SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t order by a collate x desc,b
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec
          (Collate (Iden [ Name "a" ]) [ Name "x" ]) Desc NullsOrderDefault
      , SortSpec (Iden [ Name "b" ]) DirDefault NullsOrderDefault
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t order by 1,2
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy =
      [ SortSpec (NumLit "1") DirDefault NullsOrderDefault
      , SortSpec (NumLit "2") DirDefault NullsOrderDefault
      ]
  , qeOffset = Nothing
  , qeFetchFirst = Nothing
  }
~~~~
</td></tr>
</table>
## sql 2011 data manipulation tests
<table>
<tr><td>
~~~~{.sql}
delete from t
~~~~
</td><td>
~~~~{.haskell}
Delete [ Name "t" ] Nothing Nothing
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
delete from t as u
~~~~
</td><td>
~~~~{.haskell}
Delete [ Name "t" ] (Just (Name "u")) Nothing
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
delete from t where x = 5
~~~~
</td><td>
~~~~{.haskell}
Delete
  [ Name "t" ]
  Nothing
  (Just (BinOp (Iden [ Name "x" ]) [ Name "=" ] (NumLit "5")))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
delete from t as u where u.x = 5
~~~~
</td><td>
~~~~{.haskell}
Delete
  [ Name "t" ]
  (Just (Name "u"))
  (Just
     (BinOp (Iden [ Name "u" , Name "x" ]) [ Name "=" ] (NumLit "5")))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
truncate table t
~~~~
</td><td>
~~~~{.haskell}
Truncate [ Name "t" ] DefaultIdentityRestart
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
truncate table t continue identity
~~~~
</td><td>
~~~~{.haskell}
Truncate [ Name "t" ] ContinueIdentity
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
truncate table t restart identity
~~~~
</td><td>
~~~~{.haskell}
Truncate [ Name "t" ] RestartIdentity
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
insert into t select * from u
~~~~
</td><td>
~~~~{.haskell}
Insert
  [ Name "t" ]
  Nothing
  (InsertQuery
     Select
       { qeSetQuantifier = SQDefault
       , qeSelectList = [ ( Star , Nothing ) ]
       , qeFrom = [ TRSimple [ Name "u" ] ]
       , qeWhere = Nothing
       , qeGroupBy = []
       , qeHaving = Nothing
       , qeOrderBy = []
       , qeOffset = Nothing
       , qeFetchFirst = Nothing
       })
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
insert into t(a,b,c) select * from u
~~~~
</td><td>
~~~~{.haskell}
Insert
  [ Name "t" ]
  (Just [ Name "a" , Name "b" , Name "c" ])
  (InsertQuery
     Select
       { qeSetQuantifier = SQDefault
       , qeSelectList = [ ( Star , Nothing ) ]
       , qeFrom = [ TRSimple [ Name "u" ] ]
       , qeWhere = Nothing
       , qeGroupBy = []
       , qeHaving = Nothing
       , qeOrderBy = []
       , qeOffset = Nothing
       , qeFetchFirst = Nothing
       })
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
insert into t default values
~~~~
</td><td>
~~~~{.haskell}
Insert [ Name "t" ] Nothing DefaultInsertValues
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
insert into t values(1,2)
~~~~
</td><td>
~~~~{.haskell}
Insert
  [ Name "t" ]
  Nothing
  (InsertQuery (Values [ [ NumLit "1" , NumLit "2" ] ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
insert into t values (1,2),(3,4)
~~~~
</td><td>
~~~~{.haskell}
Insert
  [ Name "t" ]
  Nothing
  (InsertQuery
     (Values
        [ [ NumLit "1" , NumLit "2" ] , [ NumLit "3" , NumLit "4" ] ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
insert into t values (default,null,array[],multiset[])
~~~~
</td><td>
~~~~{.haskell}
Insert
  [ Name "t" ]
  Nothing
  (InsertQuery
     (Values
        [ [ Iden [ Name "default" ]
          , Iden [ Name "null" ]
          , Array (Iden [ Name "array" ]) []
          , MultisetCtor []
          ]
        ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
update t set a=b
~~~~
</td><td>
~~~~{.haskell}
Update
  [ Name "t" ]
  Nothing
  [ Set [ Name "a" ] (Iden [ Name "b" ]) ]
  Nothing
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
update t set a=b, c=5
~~~~
</td><td>
~~~~{.haskell}
Update
  [ Name "t" ]
  Nothing
  [ Set [ Name "a" ] (Iden [ Name "b" ])
  , Set [ Name "c" ] (NumLit "5")
  ]
  Nothing
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
update t set a=b where a>5
~~~~
</td><td>
~~~~{.haskell}
Update
  [ Name "t" ]
  Nothing
  [ Set [ Name "a" ] (Iden [ Name "b" ]) ]
  (Just (BinOp (Iden [ Name "a" ]) [ Name ">" ] (NumLit "5")))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
update t as u set a=b where u.a>5
~~~~
</td><td>
~~~~{.haskell}
Update
  [ Name "t" ]
  (Just (Name "u"))
  [ Set [ Name "a" ] (Iden [ Name "b" ]) ]
  (Just
     (BinOp (Iden [ Name "u" , Name "a" ]) [ Name ">" ] (NumLit "5")))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
update t set (a,b)=(3,5)
~~~~
</td><td>
~~~~{.haskell}
Update
  [ Name "t" ]
  Nothing
  [ SetMultiple
      [ [ Name "a" ] , [ Name "b" ] ] [ NumLit "3" , NumLit "5" ]
  ]
  Nothing
~~~~
</td></tr>
</table>
## sql 2011 schema tests
<table>
<tr><td>
~~~~{.sql}
create schema my_schema
~~~~
</td><td>
~~~~{.haskell}
CreateSchema [ Name "my_schema" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
drop schema my_schema
~~~~
</td><td>
~~~~{.haskell}
DropSchema [ Name "my_schema" ] DefaultDropBehaviour
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
drop schema my_schema cascade
~~~~
</td><td>
~~~~{.haskell}
DropSchema [ Name "my_schema" ] Cascade
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
drop schema my_schema restrict
~~~~
</td><td>
~~~~{.haskell}
DropSchema [ Name "my_schema" ] Restrict
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, b int);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableColumnDef
      (ColumnDef (Name "b") (TypeName [ Name "int" ]) Nothing [])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int not null);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef Nothing ColNotNullConstraint ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int constraint a_not_null not null);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             (Just [ Name "a_not_null" ]) ColNotNullConstraint
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int unique);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef Nothing ColUniqueConstraint ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int primary key);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef Nothing ColPrimaryKeyConstraint ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                DefaultReferenceMatch
                DefaultReferentialAction
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u(a));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                (Just (Name "a"))
                DefaultReferenceMatch
                DefaultReferentialAction
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u match full);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                MatchFull
                DefaultReferentialAction
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u match partial);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                MatchPartial
                DefaultReferentialAction
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u match simple);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                MatchSimple
                DefaultReferentialAction
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u on update cascade );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                DefaultReferenceMatch
                RefCascade
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u on update set null );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                DefaultReferenceMatch
                RefSetNull
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u on update set default );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                DefaultReferenceMatch
                RefSetDefault
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u on update no action );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                DefaultReferenceMatch
                RefNoAction
                DefaultReferentialAction)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u on delete cascade );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ]
                Nothing
                DefaultReferenceMatch
                DefaultReferentialAction
                RefCascade)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u on update cascade on delete restrict );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ] Nothing DefaultReferenceMatch RefCascade RefRestrict)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int references u on delete restrict on update cascade );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColReferencesConstraint
                [ Name "u" ] Nothing DefaultReferenceMatch RefCascade RefRestrict)
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int check (a>5));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         Nothing
         [ ColConstraintDef
             Nothing
             (ColCheckConstraint
                (BinOp (Iden [ Name "a" ]) [ Name ">" ] (NumLit "5")))
         ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int generated always as identity);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         (Just (IdentityColumnSpec GeneratedAlways []))
         [])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int generated by default as identity);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         (Just (IdentityColumnSpec GeneratedByDefault []))
         [])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int generated always as identity
  ( start with 5 increment by 5 maxvalue 500 minvalue 5 cycle ));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         (Just
            (IdentityColumnSpec
               GeneratedAlways
               [ SGOStartWith 5
               , SGOIncrementBy 5
               , SGOMaxValue 500
               , SGOMinValue 5
               , SGOCycle
               ]))
         [])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int generated always as identity
  ( start with -4 no maxvalue no minvalue no cycle ));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         (Just
            (IdentityColumnSpec
               GeneratedAlways
               [ SGOStartWith (-4)
               , SGONoMaxValue
               , SGONoMinValue
               , SGONoCycle
               ]))
         [])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, 
                a2 int generated always as (a * 2));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableColumnDef
      (ColumnDef
         (Name "a2")
         (TypeName [ Name "int" ])
         (Just
            (GenerationClause
               (BinOp (Iden [ Name "a" ]) [ Name "*" ] (NumLit "2"))))
         [])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int default 0);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef
         (Name "a")
         (TypeName [ Name "int" ])
         (Just (DefaultClause (NumLit "0")))
         [])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, unique (a));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef Nothing (TableUniqueConstraint [ Name "a" ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, constraint a_unique unique (a));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef
      (Just [ Name "a_unique" ]) (TableUniqueConstraint [ Name "a" ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, b int, unique (a,b));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableColumnDef
      (ColumnDef (Name "b") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef
      Nothing (TableUniqueConstraint [ Name "a" , Name "b" ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, b int, primary key (a,b));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableColumnDef
      (ColumnDef (Name "b") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef
      Nothing (TablePrimaryKeyConstraint [ Name "a" , Name "b" ])
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, b int,
                foreign key (a,b) references u(c,d) match full on update cascade on delete restrict );
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableColumnDef
      (ColumnDef (Name "b") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef
      Nothing
      (TableReferencesConstraint
         [ Name "a" , Name "b" ]
         [ Name "u" ]
         (Just [ Name "c" , Name "d" ])
         MatchFull
         RefCascade
         RefRestrict)
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int,
                constraint tfku1 foreign key (a) references u);
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef
      (Just [ Name "tfku1" ])
      (TableReferencesConstraint
         [ Name "a" ]
         [ Name "u" ]
         Nothing
         DefaultReferenceMatch
         DefaultReferentialAction
         DefaultReferentialAction)
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, b int, 
                check (a > b));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableColumnDef
      (ColumnDef (Name "b") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef
      Nothing
      (TableCheckConstraint
         (BinOp (Iden [ Name "a" ]) [ Name ">" ] (Iden [ Name "b" ])))
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
create table t (a int, b int, 
                constraint agtb check (a > b));
~~~~
</td><td>
~~~~{.haskell}
CreateTable
  [ Name "t" ]
  [ TableColumnDef
      (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing [])
  , TableColumnDef
      (ColumnDef (Name "b") (TypeName [ Name "int" ]) Nothing [])
  , TableConstraintDef
      (Just [ Name "agtb" ])
      (TableCheckConstraint
         (BinOp (Iden [ Name "a" ]) [ Name ">" ] (Iden [ Name "b" ])))
  ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t add column a int
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ]
  (AddColumnDef
     (ColumnDef (Name "a") (TypeName [ Name "int" ]) Nothing []))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t alter column c set default 0
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ] (AlterColumnSetDefault (Name "c") (NumLit "0"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t alter column c drop default
~~~~
</td><td>
~~~~{.haskell}
AlterTable [ Name "t" ] (AlterColumnDropDefault (Name "c"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t alter column c set not null
~~~~
</td><td>
~~~~{.haskell}
AlterTable [ Name "t" ] (AlterColumnSetNotNull (Name "c"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t alter column c drop not null
~~~~
</td><td>
~~~~{.haskell}
AlterTable [ Name "t" ] (AlterColumnDropNotNull (Name "c"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t alter column c set data type int;
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ]
  (AlterColumnSetDataType (Name "c") (TypeName [ Name "int" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t drop column c
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ] (DropColumn (Name "c") DefaultDropBehaviour)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t drop c cascade
~~~~
</td><td>
~~~~{.haskell}
AlterTable [ Name "t" ] (DropColumn (Name "c") Cascade)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t drop c restrict
~~~~
</td><td>
~~~~{.haskell}
AlterTable [ Name "t" ] (DropColumn (Name "c") Restrict)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t add constraint c unique (a,b)
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ]
  (AddTableConstraintDef
     (Just [ Name "c" ])
     (TableUniqueConstraint [ Name "a" , Name "b" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t add unique (a,b)
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ]
  (AddTableConstraintDef
     (Just [ Name "c" ])
     (TableUniqueConstraint [ Name "a" , Name "b" ]))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t drop constraint c
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ]
  (DropTableConstraintDef [ Name "c" ] DefaultDropBehaviour)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
alter table t drop constraint c restrict
~~~~
</td><td>
~~~~{.haskell}
AlterTable
  [ Name "t" ] (DropTableConstraintDef [ Name "c" ] Restrict)
~~~~
</td></tr>
</table>
## sql 2011 access control tests
## sql 2011 bits tests
## mysql dialect
### backtickQuotes
<table>
<tr><td>
~~~~{.sql}
`test`
~~~~
</td><td>
~~~~{.haskell}
Iden [ DQName "`" "`" "test" ]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
`test`
~~~~
</td><td>
~~~~{.haskell}
Left
  ParseError
    { peErrorString =
        "(line 1, column 1):\nunexpected '`'\nexpecting \"u&\", \"U&\", \"'\", \"\\\"\", \":\", \"--\", \"/*\", digit, \".\", \">=\", \"<=\", \"!=\", \"<>\", \"||\", \"+\", \"-\", \"^\", \"*\", \"/\", \"%\", \"~\", \"&\", \"|\", \"?\", \"<\", \">\", \"[\", \"]\", \"=\", \",\", \";\", \"(\", \")\" or end of input"
    , peFilename = ""
    , pePosition = ( 1 , 1 )
    , peFormattedError =
        ":1:1:\n`test`\n^\n(line 1, column 1):\nunexpected '`'\nexpecting \"u&\", \"U&\", \"'\", \"\\\"\", \":\", \"--\", \"/*\", digit, \".\", \">=\", \"<=\", \"!=\", \"<>\", \"||\", \"+\", \"-\", \"^\", \"*\", \"/\", \"%\", \"~\", \"&\", \"|\", \"?\", \"<\", \">\", \"[\", \"]\", \"=\", \",\", \";\", \"(\", \")\" or end of input"
    }
~~~~
</td></tr>
</table>
### queries
<table>
<tr><td>
~~~~{.sql}
select * from t limit 5
~~~~
</td><td>
~~~~{.haskell}
Select
  { qeSetQuantifier = SQDefault
  , qeSelectList = [ ( Star , Nothing ) ]
  , qeFrom = [ TRSimple [ Name "t" ] ]
  , qeWhere = Nothing
  , qeGroupBy = []
  , qeHaving = Nothing
  , qeOrderBy = []
  , qeOffset = Nothing
  , qeFetchFirst = Just (NumLit "5")
  }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t fetch next 10 rows only;
~~~~
</td><td>
~~~~{.haskell}
Left
  ParseError
    { peErrorString =
        "(line 1, column 17):\nunexpected ((\"\",1,17),Identifier \"fetch\")\nexpecting ., (, as, natural, cross, inner, left, right, full, join, ,, where, group by, having, order by, limit, offset, set operator, ; or end of input"
    , peFilename = ""
    , pePosition = ( 1 , 17 )
    , peFormattedError =
        ":1:17:\nselect a from t fetch next 10 rows only;\n                ^\n(line 1, column 17):\nunexpected ((\"\",1,17),Identifier \"fetch\")\nexpecting ., (, as, natural, cross, inner, left, right, full, join, ,, where, group by, having, order by, limit, offset, set operator, ; or end of input"
    }
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t limit 5
~~~~
</td><td>
~~~~{.haskell}
Left
  ParseError
    { peErrorString =
        "(line 1, column 23):\nunexpected ((\"\",1,23),SqlNumber \"5\")\nexpecting (, natural, cross, inner, left, right, full, join, ,, where, group by, having, order by, fetch, offset, set operator, ; or end of input"
    , peFilename = ""
    , pePosition = ( 1 , 23 )
    , peFormattedError =
        ":1:23:\nselect * from t limit 5\n                      ^\n(line 1, column 23):\nunexpected ((\"\",1,23),SqlNumber \"5\")\nexpecting (, natural, cross, inner, left, right, full, join, ,, where, group by, having, order by, fetch, offset, set operator, ; or end of input"
    }
~~~~
</td></tr>
</table>
