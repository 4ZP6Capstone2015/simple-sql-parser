# parserTest
## scalarExprTests
### literals
<table>
<tr><td>
~~~~{.sql}
3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.
~~~~
</td><td>
~~~~{.haskell}
NumLit "3."
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3.3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
.3
~~~~
</td><td>
~~~~{.haskell}
NumLit ".3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.e3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3.e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3.3e3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3.3e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
.3e3
~~~~
</td><td>
~~~~{.haskell}
NumLit ".3e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3e3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3e3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3e+3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3e+3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
3e-3
~~~~
</td><td>
~~~~{.haskell}
NumLit "3e-3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'string'
~~~~
</td><td>
~~~~{.haskell}
StringLit "string"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'string with a '' quote'
~~~~
</td><td>
~~~~{.haskell}
StringLit "string with a ' quote"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
'1'
~~~~
</td><td>
~~~~{.haskell}
StringLit "1"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '3' day
~~~~
</td><td>
~~~~{.haskell}
IntervalLit{ilLiteral = "3", ilUnits = "day",
            ilPrecision = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '3' day (3)
~~~~
</td><td>
~~~~{.haskell}
IntervalLit{ilLiteral = "3", ilUnits = "day", ilPrecision = Just 3}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
interval '3 weeks'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName "interval") "3 weeks"
~~~~
</td></tr>
</table>
### identifiers
<table>
<tr><td>
~~~~{.sql}
iden1
~~~~
</td><td>
~~~~{.haskell}
Iden (Name "iden1")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
"quoted identifier"
~~~~
</td><td>
~~~~{.haskell}
Iden (QName "quoted identifier")
~~~~
</td></tr>
</table>
### star
<table>
<tr><td>
~~~~{.sql}
*
~~~~
</td><td>
~~~~{.haskell}
Star
~~~~
</td></tr>
</table>
### dot
<table>
<tr><td>
~~~~{.sql}
t.a
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "t")) (Name ".") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
t.*
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "t")) (Name ".") Star
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a.b.c
~~~~
</td><td>
~~~~{.haskell}
BinOp (BinOp (Iden (Name "a")) (Name ".") (Iden (Name "b")))
  (Name ".")
  (Iden (Name "c"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
ROW(t.*,42)
~~~~
</td><td>
~~~~{.haskell}
App (Name "ROW")
  [BinOp (Iden (Name "t")) (Name ".") Star, NumLit "42"]
~~~~
</td></tr>
</table>
### app
<table>
<tr><td>
~~~~{.sql}
f()
~~~~
</td><td>
~~~~{.haskell}
App (Name "f") []
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
f(a)
~~~~
</td><td>
~~~~{.haskell}
App (Name "f") [Iden (Name "a")]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
f(a,b)
~~~~
</td><td>
~~~~{.haskell}
App (Name "f") [Iden (Name "a"), Iden (Name "b")]
~~~~
</td></tr>
</table>
### caseexp
<table>
<tr><td>
~~~~{.sql}
case a when 1 then 2 end
~~~~
</td><td>
~~~~{.haskell}
Case{caseTest = Just (Iden (Name "a")),
     caseWhens = [([NumLit "1"], NumLit "2")], caseElse = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case a when 1 then 2 when 3 then 4 end
~~~~
</td><td>
~~~~{.haskell}
Case{caseTest = Just (Iden (Name "a")),
     caseWhens =
       [([NumLit "1"], NumLit "2"), ([NumLit "3"], NumLit "4")],
     caseElse = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case a when 1 then 2 when 3 then 4 else 5 end
~~~~
</td><td>
~~~~{.haskell}
Case{caseTest = Just (Iden (Name "a")),
     caseWhens =
       [([NumLit "1"], NumLit "2"), ([NumLit "3"], NumLit "4")],
     caseElse = Just (NumLit "5")}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case when a=1 then 2 when a=3 then 4 else 5 end
~~~~
</td><td>
~~~~{.haskell}
Case{caseTest = Nothing,
     caseWhens =
       [([BinOp (Iden (Name "a")) (Name "=") (NumLit "1")], NumLit "2"),
        ([BinOp (Iden (Name "a")) (Name "=") (NumLit "3")], NumLit "4")],
     caseElse = Just (NumLit "5")}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
case a when 1,2 then 10 when 3,4 then 20 end
~~~~
</td><td>
~~~~{.haskell}
Case{caseTest = Just (Iden (Name "a")),
     caseWhens =
       [([NumLit "1", NumLit "2"], NumLit "10"),
        ([NumLit "3", NumLit "4"], NumLit "20")],
     caseElse = Nothing}
~~~~
</td></tr>
</table>
### operators
#### binaryOperators
<table>
<tr><td>
~~~~{.sql}
a + b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "+") (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a + b * c
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "+")
  (BinOp (Iden (Name "b")) (Name "*") (Iden (Name "c")))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a * b + c
~~~~
</td><td>
~~~~{.haskell}
BinOp (BinOp (Iden (Name "a")) (Name "*") (Iden (Name "b")))
  (Name "+")
  (Iden (Name "c"))
~~~~
</td></tr>
</table>
#### unaryOperators
<table>
<tr><td>
~~~~{.sql}
not a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp (Name "not") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
not not a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp (Name "not") (PrefixOp (Name "not") (Iden (Name "a")))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
+a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp (Name "+") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
-a
~~~~
</td><td>
~~~~{.haskell}
PrefixOp (Name "-") (Iden (Name "a"))
~~~~
</td></tr>
</table>
#### operators
<table>
<tr><td>
~~~~{.sql}
cast('1' as int)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (TypeName "int")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
int '3'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName "int") "3"
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('1' as double precision)
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (TypeName "double precision")
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('1' as float(8))
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (PrecTypeName "float" 8)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
cast('1' as decimal(15,2))
~~~~
</td><td>
~~~~{.haskell}
Cast (StringLit "1") (PrecScaleTypeName "decimal" 15 2)
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
double precision '3'
~~~~
</td><td>
~~~~{.haskell}
TypedLit (TypeName "double precision") "3"
~~~~
</td></tr>
</table>
#### unaryOperators
<table>
<tr><td>
~~~~{.sql}
a in (1,2,3)
~~~~
</td><td>
~~~~{.haskell}
In True (Iden (Name "a"))
  (InList [NumLit "1", NumLit "2", NumLit "3"])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a between b and c
~~~~
</td><td>
~~~~{.haskell}
SpecialOp (Name "between")
  [Iden (Name "a"), Iden (Name "b"), Iden (Name "c")]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a not between b and c
~~~~
</td><td>
~~~~{.haskell}
SpecialOp (Name "not between")
  [Iden (Name "a"), Iden (Name "b"), Iden (Name "c")]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is null
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is null") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not null
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is not null") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is true
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is true") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not true
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is not true") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is false
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is false") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not false
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is not false") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is unknown
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is unknown") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not unknown
~~~~
</td><td>
~~~~{.haskell}
PostfixOp (Name "is not unknown") (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is distinct from b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "is distinct from") (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not distinct from b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "is not distinct from")
  (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a like b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "like") (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a not like b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "not like") (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is similar to b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "is similar to") (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a is not similar to b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "is not similar to")
  (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a overlaps b
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "overlaps") (Iden (Name "b"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
extract(day from t)
~~~~
</td><td>
~~~~{.haskell}
SpecialOp (Name "extract") [Iden (Name "day"), Iden (Name "t")]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
substring(x from 1 for 2)
~~~~
</td><td>
~~~~{.haskell}
SpecialOp (Name "substring")
  [Iden (Name "x"), NumLit "1", NumLit "2"]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(1,2)
~~~~
</td><td>
~~~~{.haskell}
SpecialOp (Name "rowctor") [NumLit "1", NumLit "2"]
~~~~
</td></tr>
</table>
### parens
<table>
<tr><td>
~~~~{.sql}
(a)
~~~~
</td><td>
~~~~{.haskell}
Parens (Iden (Name "a"))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(a + b)
~~~~
</td><td>
~~~~{.haskell}
Parens (BinOp (Iden (Name "a")) (Name "+") (Iden (Name "b")))
~~~~
</td></tr>
</table>
### unaryOperators
<table>
<tr><td>
~~~~{.sql}
exists (select a from t)
~~~~
</td><td>
~~~~{.haskell}
SubQueryExpr SqExists
  (Select{qeDuplicates = All,
          qeSelectList = [(Nothing, Iden (Name "a"))],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
(select a from t)
~~~~
</td><td>
~~~~{.haskell}
SubQueryExpr SqSq
  (Select{qeDuplicates = All,
          qeSelectList = [(Nothing, Iden (Name "a"))],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a in (select a from t)
~~~~
</td><td>
~~~~{.haskell}
In True (Iden (Name "a"))
  (InQueryExpr
     (Select{qeDuplicates = All,
             qeSelectList = [(Nothing, Iden (Name "a"))],
             qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
             qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
             qeFetch = Nothing}))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a not in (select a from t)
~~~~
</td><td>
~~~~{.haskell}
In False (Iden (Name "a"))
  (InQueryExpr
     (Select{qeDuplicates = All,
             qeSelectList = [(Nothing, Iden (Name "a"))],
             qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
             qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
             qeFetch = Nothing}))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a > all (select a from t)
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name ">")
  (SubQueryExpr SqAll
     (Select{qeDuplicates = All,
             qeSelectList = [(Nothing, Iden (Name "a"))],
             qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
             qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
             qeFetch = Nothing}))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a = some (select a from t)
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "=")
  (SubQueryExpr SqSome
     (Select{qeDuplicates = All,
             qeSelectList = [(Nothing, Iden (Name "a"))],
             qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
             qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
             qeFetch = Nothing}))
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
a <= any (select a from t)
~~~~
</td><td>
~~~~{.haskell}
BinOp (Iden (Name "a")) (Name "<=")
  (SubQueryExpr SqAny
     (Select{qeDuplicates = All,
             qeSelectList = [(Nothing, Iden (Name "a"))],
             qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
             qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
             qeFetch = Nothing}))
~~~~
</td></tr>
</table>
### aggregates
<table>
<tr><td>
~~~~{.sql}
count(*)
~~~~
</td><td>
~~~~{.haskell}
App (Name "count") [Star]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a order by a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp{aggName = Name "sum", aggDistinct = Nothing,
             aggArgs = [Iden (Name "a")],
             aggOrderBy = [OrderField (Iden (Name "a")) Asc NullsOrderDefault]}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(all a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp{aggName = Name "sum", aggDistinct = Just All,
             aggArgs = [Iden (Name "a")], aggOrderBy = []}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(distinct a)
~~~~
</td><td>
~~~~{.haskell}
AggregateApp{aggName = Name "count", aggDistinct = Just Distinct,
             aggArgs = [Iden (Name "a")], aggOrderBy = []}
~~~~
</td></tr>
</table>
### windowFunctions
<table>
<tr><td>
~~~~{.sql}
max(a) over ()
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "max", wnArgs = [Iden (Name "a")],
          wnPartition = [], wnOrderBy = [], wnFrame = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
count(*) over ()
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "count", wnArgs = [Star], wnPartition = [],
          wnOrderBy = [], wnFrame = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
max(a) over (partition by b)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "max", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")], wnOrderBy = [], wnFrame = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
max(a) over (partition by b,c)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "max", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b"), Iden (Name "c")], wnOrderBy = [],
          wnFrame = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (order by b)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [],
          wnOrderBy = [OrderField (Iden (Name "b")) Asc NullsOrderDefault],
          wnFrame = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (order by b desc,c)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [],
          wnOrderBy =
            [OrderField (Iden (Name "b")) Desc NullsOrderDefault,
             OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")],
          wnOrderBy = [OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range unbounded preceding)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")],
          wnOrderBy = [OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame = Just (FrameFrom FrameRange UnboundedPreceding)}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range 5 preceding)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")],
          wnOrderBy = [OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame = Just (FrameFrom FrameRange (Preceding (NumLit "5")))}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range current row)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")],
          wnOrderBy = [OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame = Just (FrameFrom FrameRange Current)}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c rows 5 following)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")],
          wnOrderBy = [OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame = Just (FrameFrom FrameRows (Following (NumLit "5")))}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c range unbounded following)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")],
          wnOrderBy = [OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame = Just (FrameFrom FrameRange UnboundedFollowing)}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
sum(a) over (partition by b order by c 
range between 5 preceding and 5 following)
~~~~
</td><td>
~~~~{.haskell}
WindowApp{wnName = Name "sum", wnArgs = [Iden (Name "a")],
          wnPartition = [Iden (Name "b")],
          wnOrderBy = [OrderField (Iden (Name "c")) Asc NullsOrderDefault],
          wnFrame =
            Just
              (FrameBetween FrameRange (Preceding (NumLit "5"))
                 (Following (NumLit "5")))}
~~~~
</td></tr>
</table>
## queryExprComponentTests
### duplicates
<table>
<tr><td>
~~~~{.sql}
select a from t
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select all a from t
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select distinct a from t
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = Distinct,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
</table>
### selectLists
<table>
<tr><td>
~~~~{.sql}
select 1
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
       qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))], qeFrom = [],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Nothing, Iden (Name "a")), (Nothing, Iden (Name "b"))],
       qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select 1+2,3+4
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Nothing, BinOp (NumLit "1") (Name "+") (NumLit "2")),
          (Nothing, BinOp (NumLit "3") (Name "+") (NumLit "4"))],
       qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a as a, /*comment*/ b as b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Just (Name "a"), Iden (Name "a")),
          (Just (Name "b"), Iden (Name "b"))],
       qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a a, b b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Just (Name "a"), Iden (Name "a")),
          (Just (Name "b"), Iden (Name "b"))],
       qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
</table>
### whereClause
<table>
<tr><td>
~~~~{.sql}
select a from t where a = 5
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")],
       qeWhere = Just (BinOp (Iden (Name "a")) (Name "=") (NumLit "5")),
       qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
</table>
### having
<table>
<tr><td>
~~~~{.sql}
select a,sum(b) from t group by a having sum(b) > 5
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Nothing, Iden (Name "a")),
          (Nothing, App (Name "sum") [Iden (Name "b")])],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
       qeGroupBy = [SimpleGroup (Iden (Name "a"))],
       qeHaving =
         Just
           (BinOp (App (Name "sum") [Iden (Name "b")]) (Name ">")
              (NumLit "5")),
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
</table>
### orderBy
<table>
<tr><td>
~~~~{.sql}
select a from t order by a
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing,
       qeOrderBy = [OrderField (Iden (Name "a")) Asc NullsOrderDefault],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a, b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing,
       qeOrderBy =
         [OrderField (Iden (Name "a")) Asc NullsOrderDefault,
          OrderField (Iden (Name "b")) Asc NullsOrderDefault],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a asc
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing,
       qeOrderBy = [OrderField (Iden (Name "a")) Asc NullsOrderDefault],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a desc, b desc
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing,
       qeOrderBy =
         [OrderField (Iden (Name "a")) Desc NullsOrderDefault,
          OrderField (Iden (Name "b")) Desc NullsOrderDefault],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t order by a desc nulls first, b desc nulls last
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing,
       qeOrderBy =
         [OrderField (Iden (Name "a")) Desc NullsFirst,
          OrderField (Iden (Name "b")) Desc NullsLast],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
</table>
### offsetFetch
<table>
<tr><td>
~~~~{.sql}
select a from t offset 5 rows fetch next 10 rows only
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Just (NumLit "5"),
       qeFetch = Just (NumLit "10")}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t offset 5 rows;
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Just (NumLit "5"),
       qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t fetch next 10 row only;
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Just (NumLit "10")}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t offset 5 row fetch first 10 row only
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Just (NumLit "5"),
       qeFetch = Just (NumLit "10")}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t limit 10 offset 5
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Just (NumLit "5"),
       qeFetch = Just (NumLit "10")}
~~~~
</td></tr>
</table>
### combos
<table>
<tr><td>
~~~~{.sql}
select a from t union select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr{qe0 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "a"))],
                          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing},
                 qeCombOp = Union, qeDuplicates = All,
                 qeCorresponding = Respectively,
                 qe1 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "b"))],
                          qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing}}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t intersect select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr{qe0 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "a"))],
                          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing},
                 qeCombOp = Intersect, qeDuplicates = All,
                 qeCorresponding = Respectively,
                 qe1 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "b"))],
                          qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing}}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t except all select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr{qe0 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "a"))],
                          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing},
                 qeCombOp = Except, qeDuplicates = All,
                 qeCorresponding = Respectively,
                 qe1 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "b"))],
                          qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing}}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t union distinct corresponding select b from u
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr{qe0 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "a"))],
                          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing},
                 qeCombOp = Union, qeDuplicates = Distinct,
                 qeCorresponding = Corresponding,
                 qe1 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "b"))],
                          qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing}}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t union select a from t union select a from t
~~~~
</td><td>
~~~~{.haskell}
CombineQueryExpr{qe0 =
                   Select{qeDuplicates = All,
                          qeSelectList = [(Nothing, Iden (Name "a"))],
                          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing},
                 qeCombOp = Union, qeDuplicates = All,
                 qeCorresponding = Respectively,
                 qe1 =
                   CombineQueryExpr{qe0 =
                                      Select{qeDuplicates = All,
                                             qeSelectList = [(Nothing, Iden (Name "a"))],
                                             qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
                                             qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                             qeOffset = Nothing, qeFetch = Nothing},
                                    qeCombOp = Union, qeDuplicates = All,
                                    qeCorresponding = Respectively,
                                    qe1 =
                                      Select{qeDuplicates = All,
                                             qeSelectList = [(Nothing, Iden (Name "a"))],
                                             qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
                                             qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                             qeOffset = Nothing, qeFetch = Nothing}}}
~~~~
</td></tr>
</table>
### with queries
<table>
<tr><td>
~~~~{.sql}
with u as (select a from t) select a from u
~~~~
</td><td>
~~~~{.haskell}
With{qeWithRecursive = False,
     qeViews =
       [(Alias (Name "u") Nothing,
         Select{qeDuplicates = All,
                qeSelectList = [(Nothing, Iden (Name "a"))],
                qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                qeFetch = Nothing})],
     qeQueryExpression =
       Select{qeDuplicates = All,
              qeSelectList = [(Nothing, Iden (Name "a"))],
              qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
              qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
              qeFetch = Nothing}}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
with u(b) as (select a from t) select a from u
~~~~
</td><td>
~~~~{.haskell}
With{qeWithRecursive = False,
     qeViews =
       [(Alias (Name "u") (Just [Name "b"]),
         Select{qeDuplicates = All,
                qeSelectList = [(Nothing, Iden (Name "a"))],
                qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                qeFetch = Nothing})],
     qeQueryExpression =
       Select{qeDuplicates = All,
              qeSelectList = [(Nothing, Iden (Name "a"))],
              qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
              qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
              qeFetch = Nothing}}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
with x as (select a from t),
     u as (select a from x)
select a from u
~~~~
</td><td>
~~~~{.haskell}
With{qeWithRecursive = False,
     qeViews =
       [(Alias (Name "x") Nothing,
         Select{qeDuplicates = All,
                qeSelectList = [(Nothing, Iden (Name "a"))],
                qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                qeFetch = Nothing}),
        (Alias (Name "u") Nothing,
         Select{qeDuplicates = All,
                qeSelectList = [(Nothing, Iden (Name "a"))],
                qeFrom = [TRSimple (Name "x")], qeWhere = Nothing, qeGroupBy = [],
                qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                qeFetch = Nothing})],
     qeQueryExpression =
       Select{qeDuplicates = All,
              qeSelectList = [(Nothing, Iden (Name "a"))],
              qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
              qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
              qeFetch = Nothing}}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
with recursive u as (select a from t) select a from u
~~~~
</td><td>
~~~~{.haskell}
With{qeWithRecursive = True,
     qeViews =
       [(Alias (Name "u") Nothing,
         Select{qeDuplicates = All,
                qeSelectList = [(Nothing, Iden (Name "a"))],
                qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                qeFetch = Nothing})],
     qeQueryExpression =
       Select{qeDuplicates = All,
              qeSelectList = [(Nothing, Iden (Name "a"))],
              qeFrom = [TRSimple (Name "u")], qeWhere = Nothing, qeGroupBy = [],
              qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
              qeFetch = Nothing}}
~~~~
</td></tr>
</table>
### values
<table>
<tr><td>
~~~~{.sql}
values (1,2),(3,4)
~~~~
</td><td>
~~~~{.haskell}
Values [[NumLit "1", NumLit "2"], [NumLit "3", NumLit "4"]]
~~~~
</td></tr>
</table>
### tables
<table>
<tr><td>
~~~~{.sql}
table tbl
~~~~
</td><td>
~~~~{.haskell}
Table (Name "tbl")
~~~~
</td></tr>
</table>
## query exprs
<table>
<tr><td>
~~~~{.sql}
select 1
~~~~
</td><td>
~~~~{.haskell}
[Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
        qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
        qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select 1;
~~~~
</td><td>
~~~~{.haskell}
[Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
        qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
        qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select 1;select 1
~~~~
</td><td>
~~~~{.haskell}
[Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
        qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
        qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing},
 Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
        qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
        qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}]
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
 select 1;select 1; 
~~~~
</td><td>
~~~~{.haskell}
[Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
        qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
        qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing},
 Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
        qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
        qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}]
~~~~
</td></tr>
</table>
## tableRefTests
<table>
<tr><td>
~~~~{.sql}
select a from t
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from f(a)
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRFunction (Name "f") [Iden (Name "a")]],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t,u
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "t"), TRSimple (Name "u")],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from lateral a
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRLateral (TRSimple (Name "a"))], qeWhere = Nothing,
       qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from lateral a,b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRLateral (TRSimple (Name "a")), TRSimple (Name "b")],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from a, lateral b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom = [TRSimple (Name "a"), TRLateral (TRSimple (Name "b"))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from a natural join lateral b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "a")) JInner
            (TRLateral (TRSimple (Name "b")))
            (Just JoinNatural)],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from lateral a natural join lateral b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRLateral (TRSimple (Name "a"))) JInner
            (TRLateral (TRSimple (Name "b")))
            (Just JoinNatural)],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t inner join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JInner (TRSimple (Name "u"))
            (Just (JoinOn (Iden (Name "expr"))))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JInner (TRSimple (Name "u"))
            (Just (JoinOn (Iden (Name "expr"))))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t left join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JLeft (TRSimple (Name "u"))
            (Just (JoinOn (Iden (Name "expr"))))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t right join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JRight (TRSimple (Name "u"))
            (Just (JoinOn (Iden (Name "expr"))))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t full join u on expr
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JFull (TRSimple (Name "u"))
            (Just (JoinOn (Iden (Name "expr"))))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t cross join u
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JCross (TRSimple (Name "u"))
            Nothing],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t natural inner join u
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JInner (TRSimple (Name "u"))
            (Just JoinNatural)],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t inner join u using(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin (TRSimple (Name "t")) JInner (TRSimple (Name "u"))
            (Just (JoinUsing [Name "a", Name "b"]))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from (select a from t)
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRQueryExpr
            (Select{qeDuplicates = All,
                    qeSelectList = [(Nothing, Iden (Name "a"))],
                    qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                    qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                    qeFetch = Nothing})],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t as u
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRAlias (TRSimple (Name "t")) (Alias (Name "u") Nothing)],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t u
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRAlias (TRSimple (Name "t")) (Alias (Name "u") Nothing)],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t u(b)
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRAlias (TRSimple (Name "t"))
            (Alias (Name "u") (Just [Name "b"]))],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from (t cross join u) as u
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRAlias
            (TRParens
               (TRJoin (TRSimple (Name "t")) JCross (TRSimple (Name "u"))
                  Nothing))
            (Alias (Name "u") Nothing)],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a from t cross join u cross join v
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, Iden (Name "a"))],
       qeFrom =
         [TRJoin
            (TRJoin (TRSimple (Name "t")) JCross (TRSimple (Name "u")) Nothing)
            JCross
            (TRSimple (Name "v"))
            Nothing],
       qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
</table>
## groupByTests
### simpleGroupBy
<table>
<tr><td>
~~~~{.sql}
select a,sum(b) from t group by a
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Nothing, Iden (Name "a")),
          (Nothing, App (Name "sum") [Iden (Name "b")])],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
       qeGroupBy = [SimpleGroup (Iden (Name "a"))], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a,b,sum(c) from t group by a,b
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Nothing, Iden (Name "a")), (Nothing, Iden (Name "b")),
          (Nothing, App (Name "sum") [Iden (Name "c")])],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
       qeGroupBy =
         [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
</table>
### newGroupBy
<table>
<tr><td>
~~~~{.sql}
select * from t group by ()
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
       qeGroupBy = [GroupingParens []], qeHaving = Nothing,
       qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t group by grouping sets ((), (a))
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
       qeGroupBy =
         [GroupingSets
            [GroupingParens [],
             GroupingParens [SimpleGroup (Iden (Name "a"))]]],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t group by cube(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
       qeGroupBy =
         [Cube
            [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))]],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t group by rollup(a,b)
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
       qeGroupBy =
         [Rollup
            [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))]],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
</table>
### randomGroupBy
<table>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "a"))], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a))
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets [GroupingParens [SimpleGroup (Iden (Name "a"))]]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a,b,c
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
             SimpleGroup (Iden (Name "c"))],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c))
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c"))]]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(a,b)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b),
(a),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
                GroupingParens [SimpleGroup (Iden (Name "a"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(b,a)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "a"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((b,a),
(b),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "a"))],
                GroupingParens [SimpleGroup (Iden (Name "b"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY CUBE(a,b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Cube
               [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                SimpleGroup (Iden (Name "c"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a,c),
(b,c),
(a),
(b),
(c),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "c"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c"))],
                GroupingParens [SimpleGroup (Iden (Name "a"))],
                GroupingParens [SimpleGroup (Iden (Name "b"))],
                GroupingParens [SimpleGroup (Iden (Name "c"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(Province, County, City)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (Iden (Name "Province")),
                SimpleGroup (Iden (Name "County")),
                SimpleGroup (Iden (Name "City"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(Province, (County, City))
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (Iden (Name "Province")),
                GroupingParens
                  [SimpleGroup (Iden (Name "County")),
                   SimpleGroup (Iden (Name "City"))]]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(Province, (County, City))
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (Iden (Name "Province")),
                GroupingParens
                  [SimpleGroup (Iden (Name "County")),
                   SimpleGroup (Iden (Name "City"))]]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((Province, County, City),
(Province),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "Province")),
                   SimpleGroup (Iden (Name "County")),
                   SimpleGroup (Iden (Name "City"))],
                GroupingParens [SimpleGroup (Iden (Name "Province"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((Province, County, City),
(Province, County),
(Province),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "Province")),
                   SimpleGroup (Iden (Name "County")),
                   SimpleGroup (Iden (Name "City"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "Province")),
                   SimpleGroup (Iden (Name "County"))],
                GroupingParens [SimpleGroup (Iden (Name "Province"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a, ROLLUP(b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "a")),
             Rollup
               [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a) )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
                GroupingParens [SimpleGroup (Iden (Name "a"))]]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a, b, ROLLUP(c,d)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
             Rollup
               [SimpleGroup (Iden (Name "c")), SimpleGroup (Iden (Name "d"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c,d),
(a,b,c),
(a,b) )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c")), SimpleGroup (Iden (Name "d"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))]]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(a), ROLLUP(b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup [SimpleGroup (Iden (Name "a"))],
             Rollup
               [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a),
(b,c),
(b),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
                GroupingParens [SimpleGroup (Iden (Name "a"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c"))],
                GroupingParens [SimpleGroup (Iden (Name "b"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP(a), CUBE(b,c)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup [SimpleGroup (Iden (Name "a"))],
             Cube
               [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c),
(a,b),
(a,c),
(a),
(b,c),
(b),
(c),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "c"))],
                GroupingParens [SimpleGroup (Iden (Name "a"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c"))],
                GroupingParens [SimpleGroup (Iden (Name "b"))],
                GroupingParens [SimpleGroup (Iden (Name "c"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY CUBE(a,b), ROLLUP(c,d)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Cube
               [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
             Rollup
               [SimpleGroup (Iden (Name "c")), SimpleGroup (Iden (Name "d"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b,c,d),
(a,b,c),
(a,b),
(a,c,d),
(a,c),
(a),
(b,c,d),
(b,c),
(b),
(c,d),
(c),
() )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c")), SimpleGroup (Iden (Name "d"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b")),
                   SimpleGroup (Iden (Name "c"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "c")),
                   SimpleGroup (Iden (Name "d"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "c"))],
                GroupingParens [SimpleGroup (Iden (Name "a"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c")),
                   SimpleGroup (Iden (Name "d"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "b")), SimpleGroup (Iden (Name "c"))],
                GroupingParens [SimpleGroup (Iden (Name "b"))],
                GroupingParens
                  [SimpleGroup (Iden (Name "c")), SimpleGroup (Iden (Name "d"))],
                GroupingParens [SimpleGroup (Iden (Name "c"))],
                GroupingParens []]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY a, ROLLUP(a,b)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "a")),
             Rollup
               [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY GROUPING SETS((a,b),
(a) )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "a")), SimpleGroup (Iden (Name "b"))],
                GroupingParens [SimpleGroup (Iden (Name "a"))]]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY Region,
ROLLUP(Sales_Person, WEEK(Sales_Date)),
CUBE(YEAR(Sales_Date), MONTH (Sales_Date))
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "Region")),
             Rollup
               [SimpleGroup (Iden (Name "Sales_Person")),
                SimpleGroup (App (Name "WEEK") [Iden (Name "Sales_Date")])],
             Cube
               [SimpleGroup (App (Name "YEAR") [Iden (Name "Sales_Date")]),
                SimpleGroup (App (Name "MONTH") [Iden (Name "Sales_Date")])]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select * from t GROUP BY ROLLUP (Region, Sales_Person, WEEK(Sales_Date),
YEAR(Sales_Date), MONTH(Sales_Date) )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (Iden (Name "Region")),
                SimpleGroup (Iden (Name "Sales_Person")),
                SimpleGroup (App (Name "WEEK") [Iden (Name "Sales_Date")]),
                SimpleGroup (App (Name "YEAR") [Iden (Name "Sales_Date")]),
                SimpleGroup (App (Name "MONTH") [Iden (Name "Sales_Date")])]],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "WEEK"),
              App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "DAY_WEEK"),
              App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "SALES_PERSON")),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")],
          qeWhere =
            Just
              (BinOp (App (Name "WEEK") [Iden (Name "SALES_DATE")]) (Name "=")
                 (NumLit "13")),
          qeGroupBy =
            [SimpleGroup (App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             SimpleGroup (App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             SimpleGroup (Iden (Name "SALES_PERSON"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "DAY_WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "SALES_PERSON")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY GROUPING SETS ( (WEEK(SALES_DATE), SALES_PERSON),
(DAYOFWEEK(SALES_DATE), SALES_PERSON))
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "WEEK"),
              App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "DAY_WEEK"),
              App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "SALES_PERSON")),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")],
          qeWhere =
            Just
              (BinOp (App (Name "WEEK") [Iden (Name "SALES_DATE")]) (Name "=")
                 (NumLit "13")),
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (App (Name "WEEK") [Iden (Name "SALES_DATE")]),
                   SimpleGroup (Iden (Name "SALES_PERSON"))],
                GroupingParens
                  [SimpleGroup (App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
                   SimpleGroup (Iden (Name "SALES_PERSON"))]]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "DAY_WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "SALES_PERSON")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY ROLLUP ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON )
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "WEEK"),
              App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "DAY_WEEK"),
              App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "SALES_PERSON")),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")],
          qeWhere =
            Just
              (BinOp (App (Name "WEEK") [Iden (Name "SALES_DATE")]) (Name "=")
                 (NumLit "13")),
          qeGroupBy =
            [Rollup
               [SimpleGroup (App (Name "WEEK") [Iden (Name "SALES_DATE")]),
                SimpleGroup (App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
                SimpleGroup (Iden (Name "SALES_PERSON"))]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "DAY_WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "SALES_PERSON")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SALES_PERSON, SUM(SALES) AS UNITS_SOLD
FROM SALES
WHERE WEEK(SALES_DATE) = 13
GROUP BY CUBE ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON )
ORDER BY WEEK, DAY_WEEK, SALES_PERSON
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "WEEK"),
              App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "DAY_WEEK"),
              App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "SALES_PERSON")),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")],
          qeWhere =
            Just
              (BinOp (App (Name "WEEK") [Iden (Name "SALES_DATE")]) (Name "=")
                 (NumLit "13")),
          qeGroupBy =
            [Cube
               [SimpleGroup (App (Name "WEEK") [Iden (Name "SALES_DATE")]),
                SimpleGroup (App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
                SimpleGroup (Iden (Name "SALES_PERSON"))]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "DAY_WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "SALES_PERSON")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT SALES_PERSON,
MONTH(SALES_DATE) AS MONTH,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY GROUPING SETS ( (SALES_PERSON, MONTH(SALES_DATE)),
()
)
ORDER BY SALES_PERSON, MONTH
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "SALES_PERSON")),
             (Just (Name "MONTH"),
              App (Name "MONTH") [Iden (Name "SALES_DATE")]),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "SALES_PERSON")),
                   SimpleGroup (App (Name "MONTH") [Iden (Name "SALES_DATE")])],
                GroupingParens []]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "SALES_PERSON")) Asc NullsOrderDefault,
             OrderField (Iden (Name "MONTH")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY ROLLUP ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE) )
ORDER BY WEEK, DAY_WEEK
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "WEEK"),
              App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "DAY_WEEK"),
              App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (App (Name "WEEK") [Iden (Name "SALES_DATE")]),
                SimpleGroup (App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")])]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "DAY_WEEK")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT MONTH(SALES_DATE) AS MONTH,
REGION,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY ROLLUP ( MONTH(SALES_DATE), REGION )
ORDER BY MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "MONTH"),
              App (Name "MONTH") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "REGION")),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")], qeWhere = Nothing,
          qeGroupBy =
            [Rollup
               [SimpleGroup (App (Name "MONTH") [Iden (Name "SALES_DATE")]),
                SimpleGroup (Iden (Name "REGION"))]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "MONTH")) Asc NullsOrderDefault,
             OrderField (Iden (Name "REGION")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
MONTH(SALES_DATE) AS MONTH,
REGION,
SUM(SALES) AS UNITS_SOLD
FROM SALES
GROUP BY GROUPING SETS ( ROLLUP( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE) ),
ROLLUP( MONTH(SALES_DATE), REGION ) )
ORDER BY WEEK, DAY_WEEK, MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "WEEK"),
              App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "DAY_WEEK"),
              App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "MONTH"),
              App (Name "MONTH") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "REGION")),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom = [TRSimple (Name "SALES")], qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [Rollup
                  [SimpleGroup (App (Name "WEEK") [Iden (Name "SALES_DATE")]),
                   SimpleGroup (App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")])],
                Rollup
                  [SimpleGroup (App (Name "MONTH") [Iden (Name "SALES_DATE")]),
                   SimpleGroup (Iden (Name "REGION"))]]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "DAY_WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "MONTH")) Asc NullsOrderDefault,
             OrderField (Iden (Name "REGION")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT R1, R2,
WEEK(SALES_DATE) AS WEEK,
DAYOFWEEK(SALES_DATE) AS DAY_WEEK,
MONTH(SALES_DATE) AS MONTH,
REGION, SUM(SALES) AS UNITS_SOLD
FROM SALES,(VALUES('GROUP 1','GROUP 2')) AS X(R1,R2)
GROUP BY GROUPING SETS ((R1, ROLLUP(WEEK(SALES_DATE),
DAYOFWEEK(SALES_DATE))),
(R2,ROLLUP( MONTH(SALES_DATE), REGION ) ))
ORDER BY WEEK, DAY_WEEK, MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "R1")), (Nothing, Iden (Name "R2")),
             (Just (Name "WEEK"), App (Name "WEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "DAY_WEEK"),
              App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")]),
             (Just (Name "MONTH"),
              App (Name "MONTH") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "REGION")),
             (Just (Name "UNITS_SOLD"),
              App (Name "SUM") [Iden (Name "SALES")])],
          qeFrom =
            [TRSimple (Name "SALES"),
             TRAlias
               (TRQueryExpr (Values [[StringLit "GROUP 1", StringLit "GROUP 2"]]))
               (Alias (Name "X") (Just [Name "R1", Name "R2"]))],
          qeWhere = Nothing,
          qeGroupBy =
            [GroupingSets
               [GroupingParens
                  [SimpleGroup (Iden (Name "R1")),
                   Rollup
                     [SimpleGroup (App (Name "WEEK") [Iden (Name "SALES_DATE")]),
                      SimpleGroup (App (Name "DAYOFWEEK") [Iden (Name "SALES_DATE")])]],
                GroupingParens
                  [SimpleGroup (Iden (Name "R2")),
                   Rollup
                     [SimpleGroup (App (Name "MONTH") [Iden (Name "SALES_DATE")]),
                      SimpleGroup (Iden (Name "REGION"))]]]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "DAY_WEEK")) Asc NullsOrderDefault,
             OrderField (Iden (Name "MONTH")) Asc NullsOrderDefault,
             OrderField (Iden (Name "REGION")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT MONTH(SALES_DATE) AS MONTH,
REGION,
SUM(SALES) AS UNITS_SOLD,
MAX(SALES) AS BEST_SALE,
CAST(ROUND(AVG(DECIMAL(SALES)),2) AS DECIMAL(5,2)) AS AVG_UNITS_SOLD
FROM SALES
GROUP BY CUBE(MONTH(SALES_DATE),REGION)
ORDER BY MONTH, REGION
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "MONTH"),
              App (Name "MONTH") [Iden (Name "SALES_DATE")]),
             (Nothing, Iden (Name "REGION")),
             (Just (Name "UNITS_SOLD"), App (Name "SUM") [Iden (Name "SALES")]),
             (Just (Name "BEST_SALE"), App (Name "MAX") [Iden (Name "SALES")]),
             (Just (Name "AVG_UNITS_SOLD"),
              Cast
                (App (Name "ROUND")
                   [App (Name "AVG") [App (Name "DECIMAL") [Iden (Name "SALES")]],
                    NumLit "2"])
                (PrecScaleTypeName "DECIMAL" 5 2))],
          qeFrom = [TRSimple (Name "SALES")], qeWhere = Nothing,
          qeGroupBy =
            [Cube
               [SimpleGroup (App (Name "MONTH") [Iden (Name "SALES_DATE")]),
                SimpleGroup (Iden (Name "REGION"))]],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "MONTH")) Asc NullsOrderDefault,
             OrderField (Iden (Name "REGION")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
</table>
## queries
<table>
<tr><td>
~~~~{.sql}
select count(*) from t
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList = [(Nothing, App (Name "count") [Star])],
       qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
       qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
       qeFetch = Nothing}
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
select a, sum(c+d) as s
  from t,u
  where a > 5
  group by a
  having count(1) > 5
  order by s
~~~~
</td><td>
~~~~{.haskell}
Select{qeDuplicates = All,
       qeSelectList =
         [(Nothing, Iden (Name "a")),
          (Just (Name "s"),
           App (Name "sum")
             [BinOp (Iden (Name "c")) (Name "+") (Iden (Name "d"))])],
       qeFrom = [TRSimple (Name "t"), TRSimple (Name "u")],
       qeWhere = Just (BinOp (Iden (Name "a")) (Name ">") (NumLit "5")),
       qeGroupBy = [SimpleGroup (Iden (Name "a"))],
       qeHaving =
         Just
           (BinOp (App (Name "count") [NumLit "1"]) (Name ">") (NumLit "5")),
       qeOrderBy = [OrderField (Iden (Name "s")) Asc NullsOrderDefault],
       qeOffset = Nothing, qeFetch = Nothing}
~~~~
</td></tr>
</table>
## postgresTests
<table>
<tr><td>
~~~~{.sql}
SELECT name, (SELECT max(pop) FROM cities
 WHERE cities.state = states.name)
    FROM states;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "name")),
             (Nothing,
              SubQueryExpr SqSq
                (Select{qeDuplicates = All,
                        qeSelectList = [(Nothing, App (Name "max") [Iden (Name "pop")])],
                        qeFrom = [TRSimple (Name "cities")],
                        qeWhere =
                          Just
                            (BinOp
                               (BinOp (Iden (Name "cities")) (Name ".") (Iden (Name "state")))
                               (Name "=")
                               (BinOp (Iden (Name "states")) (Name ".") (Iden (Name "name")))),
                        qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                        qeOffset = Nothing, qeFetch = Nothing}))],
          qeFrom = [TRSimple (Name "states")], qeWhere = Nothing,
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(1,2.5,'this is a test');
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              App (Name "ROW")
                [NumLit "1", NumLit "2.5", StringLit "this is a test"])],
          qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(t.*, 42) FROM t;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              App (Name "ROW")
                [BinOp (Iden (Name "t")) (Name ".") Star, NumLit "42"])],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(t.f1, t.f2, 42) FROM t;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              App (Name "ROW")
                [BinOp (Iden (Name "t")) (Name ".") (Iden (Name "f1")),
                 BinOp (Iden (Name "t")) (Name ".") (Iden (Name "f2")),
                 NumLit "42"])],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              App (Name "getf1")
                [Cast
                   (App (Name "ROW")
                      [NumLit "11", StringLit "this is a test", NumLit "2.5"])
                   (TypeName "myrowtype")])],
          qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              BinOp
                (App (Name "ROW")
                   [NumLit "1", NumLit "2.5", StringLit "this is a test"])
                (Name "=")
                (App (Name "ROW")
                   [NumLit "1", NumLit "3", StringLit "not the same"]))],
          qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT ROW(table.*) IS NULL FROM table;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              PostfixOp (Name "is null")
                (App (Name "ROW") [BinOp (Iden (Name "table")) (Name ".") Star]))],
          qeFrom = [TRSimple (Name "table")], qeWhere = Nothing,
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT true OR somefunc();
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              BinOp (Iden (Name "true")) (Name "OR")
                (App (Name "somefunc") []))],
          qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT somefunc() OR true;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              BinOp (App (Name "somefunc") []) (Name "OR")
                (Iden (Name "true")))],
          qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 CROSS JOIN t2;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JCross (TRSimple (Name "t2"))
               Nothing],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JInner (TRSimple (Name "t2"))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "t1")) (Name ".") (Iden (Name "num")))
                        (Name "=")
                        (BinOp (Iden (Name "t2")) (Name ".") (Iden (Name "num"))))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 INNER JOIN t2 USING (num);
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JInner (TRSimple (Name "t2"))
               (Just (JoinUsing [Name "num"]))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 NATURAL INNER JOIN t2;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JInner (TRSimple (Name "t2"))
               (Just JoinNatural)],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JLeft (TRSimple (Name "t2"))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "t1")) (Name ".") (Iden (Name "num")))
                        (Name "=")
                        (BinOp (Iden (Name "t2")) (Name ".") (Iden (Name "num"))))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 USING (num);
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JLeft (TRSimple (Name "t2"))
               (Just (JoinUsing [Name "num"]))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JRight (TRSimple (Name "t2"))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "t1")) (Name ".") (Iden (Name "num")))
                        (Name "=")
                        (BinOp (Iden (Name "t2")) (Name ".") (Iden (Name "num"))))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JFull (TRSimple (Name "t2"))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "t1")) (Name ".") (Iden (Name "num")))
                        (Name "=")
                        (BinOp (Iden (Name "t2")) (Name ".") (Iden (Name "num"))))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JLeft (TRSimple (Name "t2"))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "t1")) (Name ".") (Iden (Name "num")))
                        (Name "=")
                        (BinOp
                           (BinOp
                              (BinOp (BinOp (Iden (Name "t2")) (Name ".") (Iden (Name "num")))
                                 (Name "AND")
                                 (Iden (Name "t2")))
                              (Name ".")
                              (Iden (Name "value")))
                           (Name "=")
                           (StringLit "xxx")))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin (TRSimple (Name "t1")) JLeft (TRSimple (Name "t2"))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "t1")) (Name ".") (Iden (Name "num")))
                        (Name "=")
                        (BinOp (Iden (Name "t2")) (Name ".") (Iden (Name "num"))))))],
          qeWhere =
            Just
              (BinOp (BinOp (Iden (Name "t2")) (Name ".") (Iden (Name "value")))
                 (Name "=")
                 (StringLit "xxx")),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM some_very_long_table_name s
JOIN another_fairly_long_name a ON s.id = a.num;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin
               (TRAlias (TRSimple (Name "some_very_long_table_name"))
                  (Alias (Name "s") Nothing))
               JInner
               (TRAlias (TRSimple (Name "another_fairly_long_name"))
                  (Alias (Name "a") Nothing))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "s")) (Name ".") (Iden (Name "id")))
                        (Name "=")
                        (BinOp (Iden (Name "a")) (Name ".") (Iden (Name "num"))))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM people AS mother JOIN people AS child
 ON mother.id = child.mother_id;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin
               (TRAlias (TRSimple (Name "people"))
                  (Alias (Name "mother") Nothing))
               JInner
               (TRAlias (TRSimple (Name "people")) (Alias (Name "child") Nothing))
               (Just
                  (JoinOn
                     (BinOp (BinOp (Iden (Name "mother")) (Name ".") (Iden (Name "id")))
                        (Name "=")
                        (BinOp (Iden (Name "child")) (Name ".")
                           (Iden (Name "mother_id"))))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM my_table AS a CROSS JOIN my_table AS b;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRJoin
               (TRAlias (TRSimple (Name "my_table")) (Alias (Name "a") Nothing))
               JCross
               (TRAlias (TRSimple (Name "my_table")) (Alias (Name "b") Nothing))
               Nothing],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRAlias
               (TRParens
                  (TRJoin
                     (TRAlias (TRSimple (Name "my_table")) (Alias (Name "a") Nothing))
                     JCross
                     (TRSimple (Name "my_table"))
                     Nothing))
               (Alias (Name "b") Nothing)],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM getfoo(1) AS t1;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRAlias (TRFunction (Name "getfoo") [NumLit "1"])
               (Alias (Name "t1") Nothing)],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "foo")],
          qeWhere =
            Just
              (In True (Iden (Name "foosubid"))
                 (InQueryExpr
                    (Select{qeDuplicates = All,
                            qeSelectList = [(Nothing, Iden (Name "foosubid"))],
                            qeFrom =
                              [TRAlias
                                 (TRFunction (Name "getfoo")
                                    [BinOp (Iden (Name "foo")) (Name ".") (Iden (Name "fooid"))])
                                 (Alias (Name "z") Nothing)],
                            qeWhere =
                              Just
                                (BinOp (BinOp (Iden (Name "z")) (Name ".") (Iden (Name "fooid")))
                                   (Name "=")
                                   (BinOp (Iden (Name "foo")) (Name ".") (Iden (Name "fooid")))),
                            qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                            qeOffset = Nothing, qeFetch = Nothing}))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRSimple (Name "foo"),
             TRLateral
               (TRAlias
                  (TRQueryExpr
                     (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                             qeFrom = [TRSimple (Name "bar")],
                             qeWhere =
                               Just
                                 (BinOp (BinOp (Iden (Name "bar")) (Name ".") (Iden (Name "id")))
                                    (Name "=")
                                    (BinOp (Iden (Name "foo")) (Name ".") (Iden (Name "bar_id")))),
                             qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                             qeOffset = Nothing, qeFetch = Nothing}))
                  (Alias (Name "ss") Nothing))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "foo"), TRSimple (Name "bar")],
          qeWhere =
            Just
              (BinOp (BinOp (Iden (Name "bar")) (Name ".") (Iden (Name "id")))
                 (Name "=")
                 (BinOp (Iden (Name "foo")) (Name ".") (Iden (Name "bar_id")))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              BinOp (Iden (Name "m")) (Name ".") (Iden (Name "name")))],
          qeFrom =
            [TRJoin
               (TRAlias (TRSimple (Name "manufacturers"))
                  (Alias (Name "m") Nothing))
               JLeft
               (TRLateral
                  (TRAlias
                     (TRFunction (Name "get_product_names")
                        [BinOp (Iden (Name "m")) (Name ".") (Iden (Name "id"))])
                     (Alias (Name "pname") Nothing)))
               (Just (JoinOn (Iden (Name "true"))))],
          qeWhere = Just (PostfixOp (Name "is null") (Iden (Name "pname"))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 > 5
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "fdt")],
          qeWhere = Just (BinOp (Iden (Name "c1")) (Name ">") (NumLit "5")),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 IN (1, 2, 3)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "fdt")],
          qeWhere =
            Just
              (In True (Iden (Name "c1"))
                 (InList [NumLit "1", NumLit "2", NumLit "3"])),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 IN (SELECT c1 FROM t2)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "fdt")],
          qeWhere =
            Just
              (In True (Iden (Name "c1"))
                 (InQueryExpr
                    (Select{qeDuplicates = All,
                            qeSelectList = [(Nothing, Iden (Name "c1"))],
                            qeFrom = [TRSimple (Name "t2")], qeWhere = Nothing, qeGroupBy = [],
                            qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                            qeFetch = Nothing}))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "fdt")],
          qeWhere =
            Just
              (In True (Iden (Name "c1"))
                 (InQueryExpr
                    (Select{qeDuplicates = All,
                            qeSelectList = [(Nothing, Iden (Name "c3"))],
                            qeFrom = [TRSimple (Name "t2")],
                            qeWhere =
                              Just
                                (BinOp (Iden (Name "c2")) (Name "=")
                                   (BinOp (BinOp (Iden (Name "fdt")) (Name ".") (Iden (Name "c1")))
                                      (Name "+")
                                      (NumLit "10"))),
                            qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                            qeOffset = Nothing, qeFetch = Nothing}))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE c1 BETWEEN 
    (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "fdt")],
          qeWhere =
            Just
              (SpecialOp (Name "between")
                 [Iden (Name "c1"),
                  SubQueryExpr SqSq
                    (Select{qeDuplicates = All,
                            qeSelectList = [(Nothing, Iden (Name "c3"))],
                            qeFrom = [TRSimple (Name "t2")],
                            qeWhere =
                              Just
                                (BinOp (Iden (Name "c2")) (Name "=")
                                   (BinOp (BinOp (Iden (Name "fdt")) (Name ".") (Iden (Name "c1")))
                                      (Name "+")
                                      (NumLit "10"))),
                            qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                            qeOffset = Nothing, qeFetch = Nothing}),
                  NumLit "100"]),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 > fdt.c1)
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "fdt")],
          qeWhere =
            Just
              (SubQueryExpr SqExists
                 (Select{qeDuplicates = All,
                         qeSelectList = [(Nothing, Iden (Name "c1"))],
                         qeFrom = [TRSimple (Name "t2")],
                         qeWhere =
                           Just
                             (BinOp (Iden (Name "c2")) (Name ">")
                                (BinOp (Iden (Name "fdt")) (Name ".") (Iden (Name "c1")))),
                         qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                         qeOffset = Nothing, qeFetch = Nothing})),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM test1;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "test1")], qeWhere = Nothing,
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x FROM test1 GROUP BY x;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList = [(Nothing, Iden (Name "x"))],
          qeFrom = [TRSimple (Name "test1")], qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "x"))], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x, sum(y) FROM test1 GROUP BY x;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "x")),
             (Nothing, App (Name "sum") [Iden (Name "y")])],
          qeFrom = [TRSimple (Name "test1")], qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "x"))], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "product_id")),
             (Nothing, BinOp (Iden (Name "p")) (Name ".") (Iden (Name "name"))),
             (Just (Name "sales"),
              Parens
                (BinOp
                   (App (Name "sum")
                      [BinOp (Iden (Name "s")) (Name ".") (Iden (Name "units"))])
                   (Name "*")
                   (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "price")))))],
          qeFrom =
            [TRJoin
               (TRAlias (TRSimple (Name "products")) (Alias (Name "p") Nothing))
               JLeft
               (TRAlias (TRSimple (Name "sales")) (Alias (Name "s") Nothing))
               (Just (JoinUsing [Name "product_id"]))],
          qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "product_id")),
             SimpleGroup
               (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "name"))),
             SimpleGroup
               (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "price")))],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "x")),
             (Nothing, App (Name "sum") [Iden (Name "y")])],
          qeFrom = [TRSimple (Name "test1")], qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "x"))],
          qeHaving =
            Just
              (BinOp (App (Name "sum") [Iden (Name "y")]) (Name ">")
                 (NumLit "3")),
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "x")),
             (Nothing, App (Name "sum") [Iden (Name "y")])],
          qeFrom = [TRSimple (Name "test1")], qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "x"))],
          qeHaving =
            Just (BinOp (Iden (Name "x")) (Name "<") (StringLit "c")),
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date > CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) > 5000;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "product_id")),
             (Nothing, BinOp (Iden (Name "p")) (Name ".") (Iden (Name "name"))),
             (Just (Name "profit"),
              Parens
                (BinOp
                   (App (Name "sum")
                      [BinOp (Iden (Name "s")) (Name ".") (Iden (Name "units"))])
                   (Name "*")
                   (Parens
                      (BinOp (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "price")))
                         (Name "-")
                         (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "cost")))))))],
          qeFrom =
            [TRJoin
               (TRAlias (TRSimple (Name "products")) (Alias (Name "p") Nothing))
               JLeft
               (TRAlias (TRSimple (Name "sales")) (Alias (Name "s") Nothing))
               (Just (JoinUsing [Name "product_id"]))],
          qeWhere =
            Just
              (BinOp (BinOp (Iden (Name "s")) (Name ".") (Iden (Name "date")))
                 (Name ">")
                 (BinOp (Iden (Name "CURRENT_DATE")) (Name "-")
                    (TypedLit (TypeName "INTERVAL") "4 weeks"))),
          qeGroupBy =
            [SimpleGroup (Iden (Name "product_id")),
             SimpleGroup
               (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "name"))),
             SimpleGroup
               (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "price"))),
             SimpleGroup
               (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "cost")))],
          qeHaving =
            Just
              (BinOp
                 (App (Name "sum")
                    [BinOp (BinOp (Iden (Name "p")) (Name ".") (Iden (Name "price")))
                       (Name "*")
                       (BinOp (Iden (Name "s")) (Name ".") (Iden (Name "units")))])
                 (Name ">")
                 (NumLit "5000")),
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT a, b, c FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "a")), (Nothing, Iden (Name "b")),
             (Nothing, Iden (Name "c"))],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT tbl1.a, tbl2.a, tbl1.b FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              BinOp (Iden (Name "tbl1")) (Name ".") (Iden (Name "a"))),
             (Nothing, BinOp (Iden (Name "tbl2")) (Name ".") (Iden (Name "a"))),
             (Nothing,
              BinOp (Iden (Name "tbl1")) (Name ".") (Iden (Name "b")))],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT tbl1.*, tbl2.a FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, BinOp (Iden (Name "tbl1")) (Name ".") Star),
             (Nothing,
              BinOp (Iden (Name "tbl2")) (Name ".") (Iden (Name "a")))],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT a AS value, b + c AS sum FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "value"), Iden (Name "a")),
             (Just (Name "sum"),
              BinOp (Iden (Name "b")) (Name "+") (Iden (Name "c")))],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT a "value", b + c AS sum FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (QName "value"), Iden (Name "a")),
             (Just (Name "sum"),
              BinOp (Iden (Name "b")) (Name "+") (Iden (Name "c")))],
          qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
          qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT DISTINCT select_list t
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = Distinct,
          qeSelectList = [(Just (Name "t"), Iden (Name "select_list"))],
          qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
VALUES (1, 'one'), (2, 'two'), (3, 'three');
~~~~
</td><td>
~~~~{.haskell}
Right
  (Values
     [[NumLit "1", StringLit "one"], [NumLit "2", StringLit "two"],
      [NumLit "3", StringLit "three"]])
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
~~~~
</td><td>
~~~~{.haskell}
Right
  (CombineQueryExpr{qe0 =
                      Select{qeDuplicates = All,
                             qeSelectList =
                               [(Just (Name "column1"), NumLit "1"),
                                (Just (Name "column2"), StringLit "one")],
                             qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
                             qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing},
                    qeCombOp = Union, qeDuplicates = All,
                    qeCorresponding = Respectively,
                    qe1 =
                      CombineQueryExpr{qe0 =
                                         Select{qeDuplicates = All,
                                                qeSelectList =
                                                  [(Nothing, NumLit "2"),
                                                   (Nothing, StringLit "two")],
                                                qeFrom = [], qeWhere = Nothing, qeGroupBy = [],
                                                qeHaving = Nothing, qeOrderBy = [],
                                                qeOffset = Nothing, qeFetch = Nothing},
                                       qeCombOp = Union, qeDuplicates = All,
                                       qeCorresponding = Respectively,
                                       qe1 =
                                         Select{qeDuplicates = All,
                                                qeSelectList =
                                                  [(Nothing, NumLit "3"),
                                                   (Nothing, StringLit "three")],
                                                qeFrom = [], qeWhere = Nothing, qeGroupBy = [],
                                                qeHaving = Nothing, qeOrderBy = [],
                                                qeOffset = Nothing, qeFetch = Nothing}}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom =
            [TRAlias
               (TRQueryExpr
                  (Values
                     [[NumLit "1", StringLit "one"], [NumLit "2", StringLit "two"],
                      [NumLit "3", StringLit "three"]]))
               (Alias (Name "t") (Just [Name "num", Name "letter"]))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
     )
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = False,
        qeViews =
          [(Alias (Name "regional_sales") Nothing,
            Select{qeDuplicates = All,
                   qeSelectList =
                     [(Nothing, Iden (Name "region")),
                      (Just (Name "total_sales"),
                       App (Name "SUM") [Iden (Name "amount")])],
                   qeFrom = [TRSimple (Name "orders")], qeWhere = Nothing,
                   qeGroupBy = [SimpleGroup (Iden (Name "region"))],
                   qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                   qeFetch = Nothing}),
           (Alias (Name "top_regions") Nothing,
            Select{qeDuplicates = All,
                   qeSelectList = [(Nothing, Iden (Name "region"))],
                   qeFrom = [TRSimple (Name "regional_sales")],
                   qeWhere =
                     Just
                       (BinOp (Iden (Name "total_sales")) (Name ">")
                          (SubQueryExpr SqSq
                             (Select{qeDuplicates = All,
                                     qeSelectList =
                                       [(Nothing,
                                         BinOp (App (Name "SUM") [Iden (Name "total_sales")])
                                           (Name "/")
                                           (NumLit "10"))],
                                     qeFrom = [TRSimple (Name "regional_sales")], qeWhere = Nothing,
                                     qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                     qeOffset = Nothing, qeFetch = Nothing}))),
                   qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                   qeOffset = Nothing, qeFetch = Nothing})],
        qeQueryExpression =
          Select{qeDuplicates = All,
                 qeSelectList =
                   [(Nothing, Iden (Name "region")), (Nothing, Iden (Name "product")),
                    (Just (Name "product_units"),
                     App (Name "SUM") [Iden (Name "quantity")]),
                    (Just (Name "product_sales"),
                     App (Name "SUM") [Iden (Name "amount")])],
                 qeFrom = [TRSimple (Name "orders")],
                 qeWhere =
                   Just
                     (In True (Iden (Name "region"))
                        (InQueryExpr
                           (Select{qeDuplicates = All,
                                   qeSelectList = [(Nothing, Iden (Name "region"))],
                                   qeFrom = [TRSimple (Name "top_regions")], qeWhere = Nothing,
                                   qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                   qeOffset = Nothing, qeFetch = Nothing}))),
                 qeGroupBy =
                   [SimpleGroup (Iden (Name "region")),
                    SimpleGroup (Iden (Name "product"))],
                 qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                 qeFetch = Nothing}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = True,
        qeViews =
          [(Alias (Name "t") (Just [Name "n"]),
            CombineQueryExpr{qe0 = Values [[NumLit "1"]], qeCombOp = Union,
                             qeDuplicates = All, qeCorresponding = Respectively,
                             qe1 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing,
                                          BinOp (Iden (Name "n")) (Name "+") (NumLit "1"))],
                                      qeFrom = [TRSimple (Name "t")],
                                      qeWhere =
                                        Just (BinOp (Iden (Name "n")) (Name "<") (NumLit "100")),
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing}})],
        qeQueryExpression =
          Select{qeDuplicates = All,
                 qeSelectList = [(Nothing, App (Name "sum") [Iden (Name "n")])],
                 qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                 qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                 qeFetch = Nothing}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = True,
        qeViews =
          [(Alias (Name "included_parts")
              (Just [Name "sub_part", Name "part", Name "quantity"]),
            CombineQueryExpr{qe0 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing, Iden (Name "sub_part")),
                                         (Nothing, Iden (Name "part")),
                                         (Nothing, Iden (Name "quantity"))],
                                      qeFrom = [TRSimple (Name "parts")],
                                      qeWhere =
                                        Just
                                          (BinOp (Iden (Name "part")) (Name "=")
                                             (StringLit "our_product")),
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing},
                             qeCombOp = Union, qeDuplicates = All,
                             qeCorresponding = Respectively,
                             qe1 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing,
                                          BinOp (Iden (Name "p")) (Name ".")
                                            (Iden (Name "sub_part"))),
                                         (Nothing,
                                          BinOp (Iden (Name "p")) (Name ".") (Iden (Name "part"))),
                                         (Nothing,
                                          BinOp (Iden (Name "p")) (Name ".")
                                            (Iden (Name "quantity")))],
                                      qeFrom =
                                        [TRAlias (TRSimple (Name "included_parts"))
                                           (Alias (Name "pr") Nothing),
                                         TRAlias (TRSimple (Name "parts"))
                                           (Alias (Name "p") Nothing)],
                                      qeWhere =
                                        Just
                                          (BinOp
                                             (BinOp (Iden (Name "p")) (Name ".")
                                                (Iden (Name "part")))
                                             (Name "=")
                                             (BinOp (Iden (Name "pr")) (Name ".")
                                                (Iden (Name "sub_part")))),
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing}})],
        qeQueryExpression =
          Select{qeDuplicates = All,
                 qeSelectList =
                   [(Nothing, Iden (Name "sub_part")),
                    (Just (Name "total_quantity"),
                     App (Name "SUM") [Iden (Name "quantity")])],
                 qeFrom = [TRSimple (Name "included_parts")], qeWhere = Nothing,
                 qeGroupBy = [SimpleGroup (Iden (Name "sub_part"))],
                 qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                 qeFetch = Nothing}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE search_graph(id, link, data, depth) AS (
        SELECT g.id, g.link, g.data, 1
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1
        FROM graph g, search_graph sg
        WHERE g.id = sg.link
)
SELECT * FROM search_graph;
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = True,
        qeViews =
          [(Alias (Name "search_graph")
              (Just [Name "id", Name "link", Name "data", Name "depth"]),
            CombineQueryExpr{qe0 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing,
                                          BinOp (Iden (Name "g")) (Name ".") (Iden (Name "id"))),
                                         (Nothing,
                                          BinOp (Iden (Name "g")) (Name ".") (Iden (Name "link"))),
                                         (Nothing,
                                          BinOp (Iden (Name "g")) (Name ".") (Iden (Name "data"))),
                                         (Nothing, NumLit "1")],
                                      qeFrom =
                                        [TRAlias (TRSimple (Name "graph"))
                                           (Alias (Name "g") Nothing)],
                                      qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
                                      qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing},
                             qeCombOp = Union, qeDuplicates = All,
                             qeCorresponding = Respectively,
                             qe1 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing,
                                          BinOp (Iden (Name "g")) (Name ".") (Iden (Name "id"))),
                                         (Nothing,
                                          BinOp (Iden (Name "g")) (Name ".") (Iden (Name "link"))),
                                         (Nothing,
                                          BinOp (Iden (Name "g")) (Name ".") (Iden (Name "data"))),
                                         (Nothing,
                                          BinOp
                                            (BinOp (Iden (Name "sg")) (Name ".")
                                               (Iden (Name "depth")))
                                            (Name "+")
                                            (NumLit "1"))],
                                      qeFrom =
                                        [TRAlias (TRSimple (Name "graph"))
                                           (Alias (Name "g") Nothing),
                                         TRAlias (TRSimple (Name "search_graph"))
                                           (Alias (Name "sg") Nothing)],
                                      qeWhere =
                                        Just
                                          (BinOp
                                             (BinOp (Iden (Name "g")) (Name ".") (Iden (Name "id")))
                                             (Name "=")
                                             (BinOp (Iden (Name "sg")) (Name ".")
                                                (Iden (Name "link")))),
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing}})],
        qeQueryExpression =
          Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                 qeFrom = [TRSimple (Name "search_graph")], qeWhere = Nothing,
                 qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                 qeOffset = Nothing, qeFetch = Nothing}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = True,
        qeViews =
          [(Alias (Name "t") (Just [Name "n"]),
            CombineQueryExpr{qe0 =
                               Select{qeDuplicates = All, qeSelectList = [(Nothing, NumLit "1")],
                                      qeFrom = [], qeWhere = Nothing, qeGroupBy = [],
                                      qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                                      qeFetch = Nothing},
                             qeCombOp = Union, qeDuplicates = All,
                             qeCorresponding = Respectively,
                             qe1 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing,
                                          BinOp (Iden (Name "n")) (Name "+") (NumLit "1"))],
                                      qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing}})],
        qeQueryExpression =
          Select{qeDuplicates = All,
                 qeSelectList = [(Nothing, Iden (Name "n"))],
                 qeFrom = [TRSimple (Name "t")], qeWhere = Nothing, qeGroupBy = [],
                 qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                 qeFetch = Just (NumLit "100")}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing,
              BinOp (Iden (Name "f")) (Name ".") (Iden (Name "title"))),
             (Nothing, BinOp (Iden (Name "f")) (Name ".") (Iden (Name "did"))),
             (Nothing, BinOp (Iden (Name "d")) (Name ".") (Iden (Name "name"))),
             (Nothing,
              BinOp (Iden (Name "f")) (Name ".") (Iden (Name "date_prod"))),
             (Nothing,
              BinOp (Iden (Name "f")) (Name ".") (Iden (Name "kind")))],
          qeFrom =
            [TRAlias (TRSimple (Name "distributors"))
               (Alias (Name "d") Nothing),
             TRAlias (TRSimple (Name "films")) (Alias (Name "f") Nothing)],
          qeWhere =
            Just
              (BinOp (BinOp (Iden (Name "f")) (Name ".") (Iden (Name "did")))
                 (Name "=")
                 (BinOp (Iden (Name "d")) (Name ".") (Iden (Name "did")))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) < interval '5 hours';
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "kind")),
             (Just (Name "total"), App (Name "sum") [Iden (Name "len")])],
          qeFrom = [TRSimple (Name "films")], qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "kind"))],
          qeHaving =
            Just
              (BinOp (App (Name "sum") [Iden (Name "len")]) (Name "<")
                 (TypedLit (TypeName "interval") "5 hours")),
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM distributors ORDER BY name;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "distributors")], qeWhere = Nothing,
          qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "name")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT * FROM distributors ORDER BY 2;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
          qeFrom = [TRSimple (Name "distributors")], qeWhere = Nothing,
          qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [OrderField (NumLit "2") Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';
~~~~
</td><td>
~~~~{.haskell}
Right
  (CombineQueryExpr{qe0 =
                      Select{qeDuplicates = All,
                             qeSelectList =
                               [(Nothing,
                                 BinOp (Iden (Name "distributors")) (Name ".")
                                   (Iden (Name "name")))],
                             qeFrom = [TRSimple (Name "distributors")],
                             qeWhere =
                               Just
                                 (BinOp
                                    (BinOp (Iden (Name "distributors")) (Name ".")
                                       (Iden (Name "name")))
                                    (Name "LIKE")
                                    (StringLit "W%")),
                             qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                             qeOffset = Nothing, qeFetch = Nothing},
                    qeCombOp = Union, qeDuplicates = All,
                    qeCorresponding = Respectively,
                    qe1 =
                      Select{qeDuplicates = All,
                             qeSelectList =
                               [(Nothing,
                                 BinOp (Iden (Name "actors")) (Name ".") (Iden (Name "name")))],
                             qeFrom = [TRSimple (Name "actors")],
                             qeWhere =
                               Just
                                 (BinOp
                                    (BinOp (Iden (Name "actors")) (Name ".") (Iden (Name "name")))
                                    (Name "LIKE")
                                    (StringLit "W%")),
                             qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                             qeOffset = Nothing, qeFetch = Nothing}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = False,
        qeViews =
          [(Alias (Name "t") Nothing,
            Select{qeDuplicates = All,
                   qeSelectList = [(Just (Name "x"), App (Name "random") [])],
                   qeFrom =
                     [TRFunction (Name "generate_series") [NumLit "1", NumLit "3"]],
                   qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
                   qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})],
        qeQueryExpression =
          CombineQueryExpr{qe0 =
                             Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                                    qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
                                    qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                    qeOffset = Nothing, qeFetch = Nothing},
                           qeCombOp = Union, qeDuplicates = All,
                           qeCorresponding = Respectively,
                           qe1 =
                             Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                                    qeFrom = [TRSimple (Name "t")], qeWhere = Nothing,
                                    qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                    qeOffset = Nothing, qeFetch = Nothing}}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = True,
        qeViews =
          [(Alias (Name "employee_recursive")
              (Just
                 [Name "distance", Name "employee_name", Name "manager_name"]),
            CombineQueryExpr{qe0 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing, NumLit "1"),
                                         (Nothing, Iden (Name "employee_name")),
                                         (Nothing, Iden (Name "manager_name"))],
                                      qeFrom = [TRSimple (Name "employee")],
                                      qeWhere =
                                        Just
                                          (BinOp (Iden (Name "manager_name")) (Name "=")
                                             (StringLit "Mary")),
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing},
                             qeCombOp = Union, qeDuplicates = All,
                             qeCorresponding = Respectively,
                             qe1 =
                               Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing,
                                          BinOp
                                            (BinOp (Iden (Name "er")) (Name ".")
                                               (Iden (Name "distance")))
                                            (Name "+")
                                            (NumLit "1")),
                                         (Nothing,
                                          BinOp (Iden (Name "e")) (Name ".")
                                            (Iden (Name "employee_name"))),
                                         (Nothing,
                                          BinOp (Iden (Name "e")) (Name ".")
                                            (Iden (Name "manager_name")))],
                                      qeFrom =
                                        [TRAlias (TRSimple (Name "employee_recursive"))
                                           (Alias (Name "er") Nothing),
                                         TRAlias (TRSimple (Name "employee"))
                                           (Alias (Name "e") Nothing)],
                                      qeWhere =
                                        Just
                                          (BinOp
                                             (BinOp (Iden (Name "er")) (Name ".")
                                                (Iden (Name "employee_name")))
                                             (Name "=")
                                             (BinOp (Iden (Name "e")) (Name ".")
                                                (Iden (Name "manager_name")))),
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing}})],
        qeQueryExpression =
          Select{qeDuplicates = All,
                 qeSelectList =
                   [(Nothing, Iden (Name "distance")),
                    (Nothing, Iden (Name "employee_name"))],
                 qeFrom = [TRSimple (Name "employee_recursive")], qeWhere = Nothing,
                 qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                 qeOffset = Nothing, qeFetch = Nothing}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "mname"),
              BinOp (Iden (Name "m")) (Name ".") (Iden (Name "name"))),
             (Nothing, Iden (Name "pname"))],
          qeFrom =
            [TRAlias (TRSimple (Name "manufacturers"))
               (Alias (Name "m") Nothing),
             TRLateral
               (TRAlias
                  (TRFunction (Name "get_product_names")
                     [BinOp (Iden (Name "m")) (Name ".") (Iden (Name "id"))])
                  (Alias (Name "pname") Nothing))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "mname"),
              BinOp (Iden (Name "m")) (Name ".") (Iden (Name "name"))),
             (Nothing, Iden (Name "pname"))],
          qeFrom =
            [TRJoin
               (TRAlias (TRSimple (Name "manufacturers"))
                  (Alias (Name "m") Nothing))
               JLeft
               (TRLateral
                  (TRAlias
                     (TRFunction (Name "get_product_names")
                        [BinOp (Iden (Name "m")) (Name ".") (Iden (Name "id"))])
                     (Alias (Name "pname") Nothing)))
               (Just (JoinOn (Iden (Name "true"))))],
          qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT 2+2;
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, BinOp (NumLit "2") (Name "+") (NumLit "2"))],
          qeFrom = [], qeWhere = Nothing, qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}
SELECT distributors.* WHERE distributors.name = 'Westward';
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, BinOp (Iden (Name "distributors")) (Name ".") Star)],
          qeFrom = [],
          qeWhere =
            Just
              (BinOp
                 (BinOp (Iden (Name "distributors")) (Name ".")
                    (Iden (Name "name")))
                 (Name "=")
                 (StringLit "Westward")),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
</table>
## parse tpch
<table>
<tr><td>
~~~~{.sql}

select
        l_returnflag,
        l_linestatus,
        sum(l_quantity) as sum_qty,
        sum(l_extendedprice) as sum_base_price,
        sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
        sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
        avg(l_quantity) as avg_qty,
        avg(l_extendedprice) as avg_price,
        avg(l_discount) as avg_disc,
        count(*) as count_order
from
        lineitem
where
        l_shipdate <= date '1998-12-01' - interval '63' day (3)
group by
        l_returnflag,
        l_linestatus
order by
        l_returnflag,
        l_linestatus
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "l_returnflag")),
             (Nothing, Iden (Name "l_linestatus")),
             (Just (Name "sum_qty"),
              App (Name "sum") [Iden (Name "l_quantity")]),
             (Just (Name "sum_base_price"),
              App (Name "sum") [Iden (Name "l_extendedprice")]),
             (Just (Name "sum_disc_price"),
              App (Name "sum")
                [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                   (Parens
                      (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))]),
             (Just (Name "sum_charge"),
              App (Name "sum")
                [BinOp
                   (BinOp (Iden (Name "l_extendedprice")) (Name "*")
                      (Parens
                         (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount")))))
                   (Name "*")
                   (Parens (BinOp (NumLit "1") (Name "+") (Iden (Name "l_tax"))))]),
             (Just (Name "avg_qty"),
              App (Name "avg") [Iden (Name "l_quantity")]),
             (Just (Name "avg_price"),
              App (Name "avg") [Iden (Name "l_extendedprice")]),
             (Just (Name "avg_disc"),
              App (Name "avg") [Iden (Name "l_discount")]),
             (Just (Name "count_order"), App (Name "count") [Star])],
          qeFrom = [TRSimple (Name "lineitem")],
          qeWhere =
            Just
              (BinOp (Iden (Name "l_shipdate")) (Name "<=")
                 (BinOp (TypedLit (TypeName "date") "1998-12-01") (Name "-")
                    (IntervalLit{ilLiteral = "63", ilUnits = "day",
                                 ilPrecision = Just 3}))),
          qeGroupBy =
            [SimpleGroup (Iden (Name "l_returnflag")),
             SimpleGroup (Iden (Name "l_linestatus"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "l_returnflag")) Asc NullsOrderDefault,
             OrderField (Iden (Name "l_linestatus")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
from
        part,
        supplier,
        partsupp,
        nation,
        region
where
        p_partkey = ps_partkey
        and s_suppkey = ps_suppkey
        and p_size = 15
        and p_type like '%BRASS'
        and s_nationkey = n_nationkey
        and n_regionkey = r_regionkey
        and r_name = 'EUROPE'
        and ps_supplycost = (
                select
                        min(ps_supplycost)
                from
                        partsupp,
                        supplier,
                        nation,
                        region
                where
                        p_partkey = ps_partkey
                        and s_suppkey = ps_suppkey
                        and s_nationkey = n_nationkey
                        and n_regionkey = r_regionkey
                        and r_name = 'EUROPE'
        )
order by
        s_acctbal desc,
        n_name,
        s_name,
        p_partkey
fetch first 100 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "s_acctbal")),
             (Nothing, Iden (Name "s_name")), (Nothing, Iden (Name "n_name")),
             (Nothing, Iden (Name "p_partkey")),
             (Nothing, Iden (Name "p_mfgr")),
             (Nothing, Iden (Name "s_address")),
             (Nothing, Iden (Name "s_phone")),
             (Nothing, Iden (Name "s_comment"))],
          qeFrom =
            [TRSimple (Name "part"), TRSimple (Name "supplier"),
             TRSimple (Name "partsupp"), TRSimple (Name "nation"),
             TRSimple (Name "region")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp
                       (BinOp
                          (BinOp
                             (BinOp
                                (BinOp
                                   (BinOp (Iden (Name "p_partkey")) (Name "=")
                                      (Iden (Name "ps_partkey")))
                                   (Name "and")
                                   (BinOp (Iden (Name "s_suppkey")) (Name "=")
                                      (Iden (Name "ps_suppkey"))))
                                (Name "and")
                                (BinOp (Iden (Name "p_size")) (Name "=") (NumLit "15")))
                             (Name "and")
                             (BinOp (Iden (Name "p_type")) (Name "like") (StringLit "%BRASS")))
                          (Name "and")
                          (BinOp (Iden (Name "s_nationkey")) (Name "=")
                             (Iden (Name "n_nationkey"))))
                       (Name "and")
                       (BinOp (Iden (Name "n_regionkey")) (Name "=")
                          (Iden (Name "r_regionkey"))))
                    (Name "and")
                    (BinOp (Iden (Name "r_name")) (Name "=") (StringLit "EUROPE")))
                 (Name "and")
                 (BinOp (Iden (Name "ps_supplycost")) (Name "=")
                    (SubQueryExpr SqSq
                       (Select{qeDuplicates = All,
                               qeSelectList =
                                 [(Nothing, App (Name "min") [Iden (Name "ps_supplycost")])],
                               qeFrom =
                                 [TRSimple (Name "partsupp"), TRSimple (Name "supplier"),
                                  TRSimple (Name "nation"), TRSimple (Name "region")],
                               qeWhere =
                                 Just
                                   (BinOp
                                      (BinOp
                                         (BinOp
                                            (BinOp
                                               (BinOp (Iden (Name "p_partkey")) (Name "=")
                                                  (Iden (Name "ps_partkey")))
                                               (Name "and")
                                               (BinOp (Iden (Name "s_suppkey")) (Name "=")
                                                  (Iden (Name "ps_suppkey"))))
                                            (Name "and")
                                            (BinOp (Iden (Name "s_nationkey")) (Name "=")
                                               (Iden (Name "n_nationkey"))))
                                         (Name "and")
                                         (BinOp (Iden (Name "n_regionkey")) (Name "=")
                                            (Iden (Name "r_regionkey"))))
                                      (Name "and")
                                      (BinOp (Iden (Name "r_name")) (Name "=")
                                         (StringLit "EUROPE"))),
                               qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                               qeOffset = Nothing, qeFetch = Nothing})))),
          qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "s_acctbal")) Desc NullsOrderDefault,
             OrderField (Iden (Name "n_name")) Asc NullsOrderDefault,
             OrderField (Iden (Name "s_name")) Asc NullsOrderDefault,
             OrderField (Iden (Name "p_partkey")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Just (NumLit "100")})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         l_orderkey,
         sum(l_extendedprice * (1 - l_discount)) as revenue,
         o_orderdate,
         o_shippriority
 from
         customer,
         orders,
         lineitem
 where
         c_mktsegment = 'MACHINERY'
         and c_custkey = o_custkey
         and l_orderkey = o_orderkey
         and o_orderdate < date '1995-03-21'
         and l_shipdate > date '1995-03-21'
 group by
         l_orderkey,
         o_orderdate,
         o_shippriority
 order by
         revenue desc,
         o_orderdate
 fetch first 10 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "l_orderkey")),
             (Just (Name "revenue"),
              App (Name "sum")
                [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                   (Parens
                      (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))]),
             (Nothing, Iden (Name "o_orderdate")),
             (Nothing, Iden (Name "o_shippriority"))],
          qeFrom =
            [TRSimple (Name "customer"), TRSimple (Name "orders"),
             TRSimple (Name "lineitem")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp
                       (BinOp
                          (BinOp (Iden (Name "c_mktsegment")) (Name "=")
                             (StringLit "MACHINERY"))
                          (Name "and")
                          (BinOp (Iden (Name "c_custkey")) (Name "=")
                             (Iden (Name "o_custkey"))))
                       (Name "and")
                       (BinOp (Iden (Name "l_orderkey")) (Name "=")
                          (Iden (Name "o_orderkey"))))
                    (Name "and")
                    (BinOp (Iden (Name "o_orderdate")) (Name "<")
                       (TypedLit (TypeName "date") "1995-03-21")))
                 (Name "and")
                 (BinOp (Iden (Name "l_shipdate")) (Name ">")
                    (TypedLit (TypeName "date") "1995-03-21"))),
          qeGroupBy =
            [SimpleGroup (Iden (Name "l_orderkey")),
             SimpleGroup (Iden (Name "o_orderdate")),
             SimpleGroup (Iden (Name "o_shippriority"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "revenue")) Desc NullsOrderDefault,
             OrderField (Iden (Name "o_orderdate")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Just (NumLit "10")})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         o_orderpriority,
         count(*) as order_count
 from
         orders
 where
         o_orderdate >= date '1996-03-01'
         and o_orderdate < date '1996-03-01' + interval '3' month
         and exists (
                 select
                         *
                 from
                         lineitem
                 where
                         l_orderkey = o_orderkey
                         and l_commitdate < l_receiptdate
         )
 group by
         o_orderpriority
 order by
         o_orderpriority
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "o_orderpriority")),
             (Just (Name "order_count"), App (Name "count") [Star])],
          qeFrom = [TRSimple (Name "orders")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp (Iden (Name "o_orderdate")) (Name ">=")
                       (TypedLit (TypeName "date") "1996-03-01"))
                    (Name "and")
                    (BinOp (Iden (Name "o_orderdate")) (Name "<")
                       (BinOp (TypedLit (TypeName "date") "1996-03-01") (Name "+")
                          (IntervalLit{ilLiteral = "3", ilUnits = "month",
                                       ilPrecision = Nothing}))))
                 (Name "and")
                 (SubQueryExpr SqExists
                    (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                            qeFrom = [TRSimple (Name "lineitem")],
                            qeWhere =
                              Just
                                (BinOp
                                   (BinOp (Iden (Name "l_orderkey")) (Name "=")
                                      (Iden (Name "o_orderkey")))
                                   (Name "and")
                                   (BinOp (Iden (Name "l_commitdate")) (Name "<")
                                      (Iden (Name "l_receiptdate")))),
                            qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                            qeOffset = Nothing, qeFetch = Nothing}))),
          qeGroupBy = [SimpleGroup (Iden (Name "o_orderpriority"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "o_orderpriority")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         n_name,
         sum(l_extendedprice * (1 - l_discount)) as revenue
 from
         customer,
         orders,
         lineitem,
         supplier,
         nation,
         region
 where
         c_custkey = o_custkey
         and l_orderkey = o_orderkey
         and l_suppkey = s_suppkey
         and c_nationkey = s_nationkey
         and s_nationkey = n_nationkey
         and n_regionkey = r_regionkey
         and r_name = 'EUROPE'
         and o_orderdate >= date '1997-01-01'
         and o_orderdate < date '1997-01-01' + interval '1' year
 group by
         n_name
 order by
         revenue desc
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "n_name")),
             (Just (Name "revenue"),
              App (Name "sum")
                [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                   (Parens
                      (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))])],
          qeFrom =
            [TRSimple (Name "customer"), TRSimple (Name "orders"),
             TRSimple (Name "lineitem"), TRSimple (Name "supplier"),
             TRSimple (Name "nation"), TRSimple (Name "region")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp
                       (BinOp
                          (BinOp
                             (BinOp
                                (BinOp
                                   (BinOp
                                      (BinOp (Iden (Name "c_custkey")) (Name "=")
                                         (Iden (Name "o_custkey")))
                                      (Name "and")
                                      (BinOp (Iden (Name "l_orderkey")) (Name "=")
                                         (Iden (Name "o_orderkey"))))
                                   (Name "and")
                                   (BinOp (Iden (Name "l_suppkey")) (Name "=")
                                      (Iden (Name "s_suppkey"))))
                                (Name "and")
                                (BinOp (Iden (Name "c_nationkey")) (Name "=")
                                   (Iden (Name "s_nationkey"))))
                             (Name "and")
                             (BinOp (Iden (Name "s_nationkey")) (Name "=")
                                (Iden (Name "n_nationkey"))))
                          (Name "and")
                          (BinOp (Iden (Name "n_regionkey")) (Name "=")
                             (Iden (Name "r_regionkey"))))
                       (Name "and")
                       (BinOp (Iden (Name "r_name")) (Name "=") (StringLit "EUROPE")))
                    (Name "and")
                    (BinOp (Iden (Name "o_orderdate")) (Name ">=")
                       (TypedLit (TypeName "date") "1997-01-01")))
                 (Name "and")
                 (BinOp (Iden (Name "o_orderdate")) (Name "<")
                    (BinOp (TypedLit (TypeName "date") "1997-01-01") (Name "+")
                       (IntervalLit{ilLiteral = "1", ilUnits = "year",
                                    ilPrecision = Nothing})))),
          qeGroupBy = [SimpleGroup (Iden (Name "n_name"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "revenue")) Desc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         sum(l_extendedprice * l_discount) as revenue
 from
         lineitem
 where
         l_shipdate >= date '1997-01-01'
         and l_shipdate < date '1997-01-01' + interval '1' year
         and l_discount between 0.07 - 0.01 and 0.07 + 0.01
         and l_quantity < 24
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "revenue"),
              App (Name "sum")
                [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                   (Iden (Name "l_discount"))])],
          qeFrom = [TRSimple (Name "lineitem")],
          qeWhere =
            Just
              (BinOp
                 (SpecialOp (Name "between")
                    [BinOp
                       (BinOp
                          (BinOp (Iden (Name "l_shipdate")) (Name ">=")
                             (TypedLit (TypeName "date") "1997-01-01"))
                          (Name "and")
                          (BinOp (Iden (Name "l_shipdate")) (Name "<")
                             (BinOp (TypedLit (TypeName "date") "1997-01-01") (Name "+")
                                (IntervalLit{ilLiteral = "1", ilUnits = "year",
                                             ilPrecision = Nothing}))))
                       (Name "and")
                       (Iden (Name "l_discount")),
                     BinOp (NumLit "0.07") (Name "-") (NumLit "0.01"),
                     BinOp (NumLit "0.07") (Name "+") (NumLit "0.01")])
                 (Name "and")
                 (BinOp (Iden (Name "l_quantity")) (Name "<") (NumLit "24"))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         supp_nation,
         cust_nation,
         l_year,
         sum(volume) as revenue
 from
         (
                 select
                         n1.n_name as supp_nation,
                         n2.n_name as cust_nation,
                         extract(year from l_shipdate) as l_year,
                         l_extendedprice * (1 - l_discount) as volume
                 from
                         supplier,
                         lineitem,
                         orders,
                         customer,
                         nation n1,
                         nation n2
                 where
                         s_suppkey = l_suppkey
                         and o_orderkey = l_orderkey
                         and c_custkey = o_custkey
                         and s_nationkey = n1.n_nationkey
                         and c_nationkey = n2.n_nationkey
                         and (
                                 (n1.n_name = 'PERU' and n2.n_name = 'IRAQ')
                                 or (n1.n_name = 'IRAQ' and n2.n_name = 'PERU')
                         )
                         and l_shipdate between date '1995-01-01' and date '1996-12-31'
         ) as shipping
 group by
         supp_nation,
         cust_nation,
         l_year
 order by
         supp_nation,
         cust_nation,
         l_year
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "supp_nation")),
             (Nothing, Iden (Name "cust_nation")),
             (Nothing, Iden (Name "l_year")),
             (Just (Name "revenue"), App (Name "sum") [Iden (Name "volume")])],
          qeFrom =
            [TRAlias
               (TRQueryExpr
                  (Select{qeDuplicates = All,
                          qeSelectList =
                            [(Just (Name "supp_nation"),
                              BinOp (Iden (Name "n1")) (Name ".") (Iden (Name "n_name"))),
                             (Just (Name "cust_nation"),
                              BinOp (Iden (Name "n2")) (Name ".") (Iden (Name "n_name"))),
                             (Just (Name "l_year"),
                              SpecialOp (Name "extract")
                                [Iden (Name "year"), Iden (Name "l_shipdate")]),
                             (Just (Name "volume"),
                              BinOp (Iden (Name "l_extendedprice")) (Name "*")
                                (Parens
                                   (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount")))))],
                          qeFrom =
                            [TRSimple (Name "supplier"), TRSimple (Name "lineitem"),
                             TRSimple (Name "orders"), TRSimple (Name "customer"),
                             TRAlias (TRSimple (Name "nation")) (Alias (Name "n1") Nothing),
                             TRAlias (TRSimple (Name "nation")) (Alias (Name "n2") Nothing)],
                          qeWhere =
                            Just
                              (SpecialOp (Name "between")
                                 [BinOp
                                    (BinOp
                                       (BinOp
                                          (BinOp
                                             (BinOp
                                                (BinOp
                                                   (BinOp (Iden (Name "s_suppkey")) (Name "=")
                                                      (Iden (Name "l_suppkey")))
                                                   (Name "and")
                                                   (BinOp (Iden (Name "o_orderkey")) (Name "=")
                                                      (Iden (Name "l_orderkey"))))
                                                (Name "and")
                                                (BinOp (Iden (Name "c_custkey")) (Name "=")
                                                   (Iden (Name "o_custkey"))))
                                             (Name "and")
                                             (BinOp (Iden (Name "s_nationkey")) (Name "=")
                                                (BinOp (Iden (Name "n1")) (Name ".")
                                                   (Iden (Name "n_nationkey")))))
                                          (Name "and")
                                          (BinOp (Iden (Name "c_nationkey")) (Name "=")
                                             (BinOp (Iden (Name "n2")) (Name ".")
                                                (Iden (Name "n_nationkey")))))
                                       (Name "and")
                                       (Parens
                                          (BinOp
                                             (Parens
                                                (BinOp
                                                   (BinOp
                                                      (BinOp (Iden (Name "n1")) (Name ".")
                                                         (Iden (Name "n_name")))
                                                      (Name "=")
                                                      (StringLit "PERU"))
                                                   (Name "and")
                                                   (BinOp
                                                      (BinOp (Iden (Name "n2")) (Name ".")
                                                         (Iden (Name "n_name")))
                                                      (Name "=")
                                                      (StringLit "IRAQ"))))
                                             (Name "or")
                                             (Parens
                                                (BinOp
                                                   (BinOp
                                                      (BinOp (Iden (Name "n1")) (Name ".")
                                                         (Iden (Name "n_name")))
                                                      (Name "=")
                                                      (StringLit "IRAQ"))
                                                   (Name "and")
                                                   (BinOp
                                                      (BinOp (Iden (Name "n2")) (Name ".")
                                                         (Iden (Name "n_name")))
                                                      (Name "=")
                                                      (StringLit "PERU")))))))
                                    (Name "and")
                                    (Iden (Name "l_shipdate")),
                                  TypedLit (TypeName "date") "1995-01-01",
                                  TypedLit (TypeName "date") "1996-12-31"]),
                          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                          qeOffset = Nothing, qeFetch = Nothing}))
               (Alias (Name "shipping") Nothing)],
          qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "supp_nation")),
             SimpleGroup (Iden (Name "cust_nation")),
             SimpleGroup (Iden (Name "l_year"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "supp_nation")) Asc NullsOrderDefault,
             OrderField (Iden (Name "cust_nation")) Asc NullsOrderDefault,
             OrderField (Iden (Name "l_year")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         o_year,
         sum(case
                 when nation = 'IRAQ' then volume
                 else 0
         end) / sum(volume) as mkt_share
 from
         (
                 select
                         extract(year from o_orderdate) as o_year,
                         l_extendedprice * (1 - l_discount) as volume,
                         n2.n_name as nation
                 from
                         part,
                         supplier,
                         lineitem,
                         orders,
                         customer,
                         nation n1,
                         nation n2,
                         region
                 where
                         p_partkey = l_partkey
                         and s_suppkey = l_suppkey
                         and l_orderkey = o_orderkey
                         and o_custkey = c_custkey
                         and c_nationkey = n1.n_nationkey
                         and n1.n_regionkey = r_regionkey
                         and r_name = 'MIDDLE EAST'
                         and s_nationkey = n2.n_nationkey
                         and o_orderdate between date '1995-01-01' and date '1996-12-31'
                         and p_type = 'STANDARD ANODIZED BRASS'
         ) as all_nations
 group by
         o_year
 order by
         o_year
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "o_year")),
             (Just (Name "mkt_share"),
              BinOp
                (App (Name "sum")
                   [Case{caseTest = Nothing,
                         caseWhens =
                           [([BinOp (Iden (Name "nation")) (Name "=") (StringLit "IRAQ")],
                             Iden (Name "volume"))],
                         caseElse = Just (NumLit "0")}])
                (Name "/")
                (App (Name "sum") [Iden (Name "volume")]))],
          qeFrom =
            [TRAlias
               (TRQueryExpr
                  (Select{qeDuplicates = All,
                          qeSelectList =
                            [(Just (Name "o_year"),
                              SpecialOp (Name "extract")
                                [Iden (Name "year"), Iden (Name "o_orderdate")]),
                             (Just (Name "volume"),
                              BinOp (Iden (Name "l_extendedprice")) (Name "*")
                                (Parens
                                   (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))),
                             (Just (Name "nation"),
                              BinOp (Iden (Name "n2")) (Name ".") (Iden (Name "n_name")))],
                          qeFrom =
                            [TRSimple (Name "part"), TRSimple (Name "supplier"),
                             TRSimple (Name "lineitem"), TRSimple (Name "orders"),
                             TRSimple (Name "customer"),
                             TRAlias (TRSimple (Name "nation")) (Alias (Name "n1") Nothing),
                             TRAlias (TRSimple (Name "nation")) (Alias (Name "n2") Nothing),
                             TRSimple (Name "region")],
                          qeWhere =
                            Just
                              (BinOp
                                 (SpecialOp (Name "between")
                                    [BinOp
                                       (BinOp
                                          (BinOp
                                             (BinOp
                                                (BinOp
                                                   (BinOp
                                                      (BinOp
                                                         (BinOp
                                                            (BinOp (Iden (Name "p_partkey"))
                                                               (Name "=")
                                                               (Iden (Name "l_partkey")))
                                                            (Name "and")
                                                            (BinOp (Iden (Name "s_suppkey"))
                                                               (Name "=")
                                                               (Iden (Name "l_suppkey"))))
                                                         (Name "and")
                                                         (BinOp (Iden (Name "l_orderkey"))
                                                            (Name "=")
                                                            (Iden (Name "o_orderkey"))))
                                                      (Name "and")
                                                      (BinOp (Iden (Name "o_custkey")) (Name "=")
                                                         (Iden (Name "c_custkey"))))
                                                   (Name "and")
                                                   (BinOp (Iden (Name "c_nationkey")) (Name "=")
                                                      (BinOp (Iden (Name "n1")) (Name ".")
                                                         (Iden (Name "n_nationkey")))))
                                                (Name "and")
                                                (BinOp
                                                   (BinOp (Iden (Name "n1")) (Name ".")
                                                      (Iden (Name "n_regionkey")))
                                                   (Name "=")
                                                   (Iden (Name "r_regionkey"))))
                                             (Name "and")
                                             (BinOp (Iden (Name "r_name")) (Name "=")
                                                (StringLit "MIDDLE EAST")))
                                          (Name "and")
                                          (BinOp (Iden (Name "s_nationkey")) (Name "=")
                                             (BinOp (Iden (Name "n2")) (Name ".")
                                                (Iden (Name "n_nationkey")))))
                                       (Name "and")
                                       (Iden (Name "o_orderdate")),
                                     TypedLit (TypeName "date") "1995-01-01",
                                     TypedLit (TypeName "date") "1996-12-31"])
                                 (Name "and")
                                 (BinOp (Iden (Name "p_type")) (Name "=")
                                    (StringLit "STANDARD ANODIZED BRASS"))),
                          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                          qeOffset = Nothing, qeFetch = Nothing}))
               (Alias (Name "all_nations") Nothing)],
          qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "o_year"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "o_year")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         nation,
         o_year,
         sum(amount) as sum_profit
 from
         (
                 select
                         n_name as nation,
                         extract(year from o_orderdate) as o_year,
                         l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
                 from
                         part,
                         supplier,
                         lineitem,
                         partsupp,
                         orders,
                         nation
                 where
                         s_suppkey = l_suppkey
                         and ps_suppkey = l_suppkey
                         and ps_partkey = l_partkey
                         and p_partkey = l_partkey
                         and o_orderkey = l_orderkey
                         and s_nationkey = n_nationkey
                         and p_name like '%antique%'
         ) as profit
 group by
         nation,
         o_year
 order by
         nation,
         o_year desc
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "nation")), (Nothing, Iden (Name "o_year")),
             (Just (Name "sum_profit"),
              App (Name "sum") [Iden (Name "amount")])],
          qeFrom =
            [TRAlias
               (TRQueryExpr
                  (Select{qeDuplicates = All,
                          qeSelectList =
                            [(Just (Name "nation"), Iden (Name "n_name")),
                             (Just (Name "o_year"),
                              SpecialOp (Name "extract")
                                [Iden (Name "year"), Iden (Name "o_orderdate")]),
                             (Just (Name "amount"),
                              BinOp
                                (BinOp (Iden (Name "l_extendedprice")) (Name "*")
                                   (Parens
                                      (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount")))))
                                (Name "-")
                                (BinOp (Iden (Name "ps_supplycost")) (Name "*")
                                   (Iden (Name "l_quantity"))))],
                          qeFrom =
                            [TRSimple (Name "part"), TRSimple (Name "supplier"),
                             TRSimple (Name "lineitem"), TRSimple (Name "partsupp"),
                             TRSimple (Name "orders"), TRSimple (Name "nation")],
                          qeWhere =
                            Just
                              (BinOp
                                 (BinOp
                                    (BinOp
                                       (BinOp
                                          (BinOp
                                             (BinOp
                                                (BinOp (Iden (Name "s_suppkey")) (Name "=")
                                                   (Iden (Name "l_suppkey")))
                                                (Name "and")
                                                (BinOp (Iden (Name "ps_suppkey")) (Name "=")
                                                   (Iden (Name "l_suppkey"))))
                                             (Name "and")
                                             (BinOp (Iden (Name "ps_partkey")) (Name "=")
                                                (Iden (Name "l_partkey"))))
                                          (Name "and")
                                          (BinOp (Iden (Name "p_partkey")) (Name "=")
                                             (Iden (Name "l_partkey"))))
                                       (Name "and")
                                       (BinOp (Iden (Name "o_orderkey")) (Name "=")
                                          (Iden (Name "l_orderkey"))))
                                    (Name "and")
                                    (BinOp (Iden (Name "s_nationkey")) (Name "=")
                                       (Iden (Name "n_nationkey"))))
                                 (Name "and")
                                 (BinOp (Iden (Name "p_name")) (Name "like")
                                    (StringLit "%antique%"))),
                          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                          qeOffset = Nothing, qeFetch = Nothing}))
               (Alias (Name "profit") Nothing)],
          qeWhere = Nothing,
          qeGroupBy =
            [SimpleGroup (Iden (Name "nation")),
             SimpleGroup (Iden (Name "o_year"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "nation")) Asc NullsOrderDefault,
             OrderField (Iden (Name "o_year")) Desc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         c_custkey,
         c_name,
         sum(l_extendedprice * (1 - l_discount)) as revenue,
         c_acctbal,
         n_name,
         c_address,
         c_phone,
         c_comment
 from
         customer,
         orders,
         lineitem,
         nation
 where
         c_custkey = o_custkey
         and l_orderkey = o_orderkey
         and o_orderdate >= date '1993-12-01'
         and o_orderdate < date '1993-12-01' + interval '3' month
         and l_returnflag = 'R'
         and c_nationkey = n_nationkey
 group by
         c_custkey,
         c_name,
         c_acctbal,
         c_phone,
         n_name,
         c_address,
         c_comment
 order by
         revenue desc
 fetch first 20 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "c_custkey")),
             (Nothing, Iden (Name "c_name")),
             (Just (Name "revenue"),
              App (Name "sum")
                [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                   (Parens
                      (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))]),
             (Nothing, Iden (Name "c_acctbal")),
             (Nothing, Iden (Name "n_name")),
             (Nothing, Iden (Name "c_address")),
             (Nothing, Iden (Name "c_phone")),
             (Nothing, Iden (Name "c_comment"))],
          qeFrom =
            [TRSimple (Name "customer"), TRSimple (Name "orders"),
             TRSimple (Name "lineitem"), TRSimple (Name "nation")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp
                       (BinOp
                          (BinOp
                             (BinOp (Iden (Name "c_custkey")) (Name "=")
                                (Iden (Name "o_custkey")))
                             (Name "and")
                             (BinOp (Iden (Name "l_orderkey")) (Name "=")
                                (Iden (Name "o_orderkey"))))
                          (Name "and")
                          (BinOp (Iden (Name "o_orderdate")) (Name ">=")
                             (TypedLit (TypeName "date") "1993-12-01")))
                       (Name "and")
                       (BinOp (Iden (Name "o_orderdate")) (Name "<")
                          (BinOp (TypedLit (TypeName "date") "1993-12-01") (Name "+")
                             (IntervalLit{ilLiteral = "3", ilUnits = "month",
                                          ilPrecision = Nothing}))))
                    (Name "and")
                    (BinOp (Iden (Name "l_returnflag")) (Name "=") (StringLit "R")))
                 (Name "and")
                 (BinOp (Iden (Name "c_nationkey")) (Name "=")
                    (Iden (Name "n_nationkey")))),
          qeGroupBy =
            [SimpleGroup (Iden (Name "c_custkey")),
             SimpleGroup (Iden (Name "c_name")),
             SimpleGroup (Iden (Name "c_acctbal")),
             SimpleGroup (Iden (Name "c_phone")),
             SimpleGroup (Iden (Name "n_name")),
             SimpleGroup (Iden (Name "c_address")),
             SimpleGroup (Iden (Name "c_comment"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "revenue")) Desc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Just (NumLit "20")})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         ps_partkey,
         sum(ps_supplycost * ps_availqty) as value
 from
         partsupp,
         supplier,
         nation
 where
         ps_suppkey = s_suppkey
         and s_nationkey = n_nationkey
         and n_name = 'CHINA'
 group by
         ps_partkey having
                 sum(ps_supplycost * ps_availqty) > (
                         select
                                 sum(ps_supplycost * ps_availqty) * 0.0001000000
                         from
                                 partsupp,
                                 supplier,
                                 nation
                         where
                                 ps_suppkey = s_suppkey
                                 and s_nationkey = n_nationkey
                                 and n_name = 'CHINA'
                 )
 order by
         value desc
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "ps_partkey")),
             (Just (Name "value"),
              App (Name "sum")
                [BinOp (Iden (Name "ps_supplycost")) (Name "*")
                   (Iden (Name "ps_availqty"))])],
          qeFrom =
            [TRSimple (Name "partsupp"), TRSimple (Name "supplier"),
             TRSimple (Name "nation")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp (Iden (Name "ps_suppkey")) (Name "=")
                       (Iden (Name "s_suppkey")))
                    (Name "and")
                    (BinOp (Iden (Name "s_nationkey")) (Name "=")
                       (Iden (Name "n_nationkey"))))
                 (Name "and")
                 (BinOp (Iden (Name "n_name")) (Name "=") (StringLit "CHINA"))),
          qeGroupBy = [SimpleGroup (Iden (Name "ps_partkey"))],
          qeHaving =
            Just
              (BinOp
                 (App (Name "sum")
                    [BinOp (Iden (Name "ps_supplycost")) (Name "*")
                       (Iden (Name "ps_availqty"))])
                 (Name ">")
                 (SubQueryExpr SqSq
                    (Select{qeDuplicates = All,
                            qeSelectList =
                              [(Nothing,
                                BinOp
                                  (App (Name "sum")
                                     [BinOp (Iden (Name "ps_supplycost")) (Name "*")
                                        (Iden (Name "ps_availqty"))])
                                  (Name "*")
                                  (NumLit "0.0001000000"))],
                            qeFrom =
                              [TRSimple (Name "partsupp"), TRSimple (Name "supplier"),
                               TRSimple (Name "nation")],
                            qeWhere =
                              Just
                                (BinOp
                                   (BinOp
                                      (BinOp (Iden (Name "ps_suppkey")) (Name "=")
                                         (Iden (Name "s_suppkey")))
                                      (Name "and")
                                      (BinOp (Iden (Name "s_nationkey")) (Name "=")
                                         (Iden (Name "n_nationkey"))))
                                   (Name "and")
                                   (BinOp (Iden (Name "n_name")) (Name "=") (StringLit "CHINA"))),
                            qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                            qeOffset = Nothing, qeFetch = Nothing}))),
          qeOrderBy =
            [OrderField (Iden (Name "value")) Desc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         l_shipmode,
         sum(case
                 when o_orderpriority = '1-URGENT'
                         or o_orderpriority = '2-HIGH'
                         then 1
                 else 0
         end) as high_line_count,
         sum(case
                 when o_orderpriority <> '1-URGENT'
                         and o_orderpriority <> '2-HIGH'
                         then 1
                 else 0
         end) as low_line_count
 from
         orders,
         lineitem
 where
         o_orderkey = l_orderkey
         and l_shipmode in ('AIR', 'RAIL')
         and l_commitdate < l_receiptdate
         and l_shipdate < l_commitdate
         and l_receiptdate >= date '1994-01-01'
         and l_receiptdate < date '1994-01-01' + interval '1' year
 group by
         l_shipmode
 order by
         l_shipmode
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "l_shipmode")),
             (Just (Name "high_line_count"),
              App (Name "sum")
                [Case{caseTest = Nothing,
                      caseWhens =
                        [([BinOp
                             (BinOp (Iden (Name "o_orderpriority")) (Name "=")
                                (StringLit "1-URGENT"))
                             (Name "or")
                             (BinOp (Iden (Name "o_orderpriority")) (Name "=")
                                (StringLit "2-HIGH"))],
                          NumLit "1")],
                      caseElse = Just (NumLit "0")}]),
             (Just (Name "low_line_count"),
              App (Name "sum")
                [Case{caseTest = Nothing,
                      caseWhens =
                        [([BinOp
                             (BinOp (Iden (Name "o_orderpriority")) (Name "<>")
                                (StringLit "1-URGENT"))
                             (Name "and")
                             (BinOp (Iden (Name "o_orderpriority")) (Name "<>")
                                (StringLit "2-HIGH"))],
                          NumLit "1")],
                      caseElse = Just (NumLit "0")}])],
          qeFrom = [TRSimple (Name "orders"), TRSimple (Name "lineitem")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp
                       (BinOp
                          (In True
                             (BinOp
                                (BinOp (Iden (Name "o_orderkey")) (Name "=")
                                   (Iden (Name "l_orderkey")))
                                (Name "and")
                                (Iden (Name "l_shipmode")))
                             (InList [StringLit "AIR", StringLit "RAIL"]))
                          (Name "and")
                          (BinOp (Iden (Name "l_commitdate")) (Name "<")
                             (Iden (Name "l_receiptdate"))))
                       (Name "and")
                       (BinOp (Iden (Name "l_shipdate")) (Name "<")
                          (Iden (Name "l_commitdate"))))
                    (Name "and")
                    (BinOp (Iden (Name "l_receiptdate")) (Name ">=")
                       (TypedLit (TypeName "date") "1994-01-01")))
                 (Name "and")
                 (BinOp (Iden (Name "l_receiptdate")) (Name "<")
                    (BinOp (TypedLit (TypeName "date") "1994-01-01") (Name "+")
                       (IntervalLit{ilLiteral = "1", ilUnits = "year",
                                    ilPrecision = Nothing})))),
          qeGroupBy = [SimpleGroup (Iden (Name "l_shipmode"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "l_shipmode")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         c_count,
         count(*) as custdist
 from
         (
                 select
                         c_custkey,
                         count(o_orderkey)
                 from
                         customer left outer join orders on
                                 c_custkey = o_custkey
                                 and o_comment not like '%pending%requests%'
                 group by
                         c_custkey
         ) as c_orders (c_custkey, c_count)
 group by
         c_count
 order by
         custdist desc,
         c_count desc
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "c_count")),
             (Just (Name "custdist"), App (Name "count") [Star])],
          qeFrom =
            [TRAlias
               (TRQueryExpr
                  (Select{qeDuplicates = All,
                          qeSelectList =
                            [(Nothing, Iden (Name "c_custkey")),
                             (Nothing, App (Name "count") [Iden (Name "o_orderkey")])],
                          qeFrom =
                            [TRJoin (TRSimple (Name "customer")) JLeft
                               (TRSimple (Name "orders"))
                               (Just
                                  (JoinOn
                                     (BinOp
                                        (BinOp (Iden (Name "c_custkey")) (Name "=")
                                           (Iden (Name "o_custkey")))
                                        (Name "and")
                                        (BinOp (Iden (Name "o_comment")) (Name "not like")
                                           (StringLit "%pending%requests%")))))],
                          qeWhere = Nothing,
                          qeGroupBy = [SimpleGroup (Iden (Name "c_custkey"))],
                          qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                          qeFetch = Nothing}))
               (Alias (Name "c_orders")
                  (Just [Name "c_custkey", Name "c_count"]))],
          qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "c_count"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "custdist")) Desc NullsOrderDefault,
             OrderField (Iden (Name "c_count")) Desc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         100.00 * sum(case
                 when p_type like 'PROMO%'
                         then l_extendedprice * (1 - l_discount)
                 else 0
         end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
 from
         lineitem,
         part
 where
         l_partkey = p_partkey
         and l_shipdate >= date '1994-12-01'
         and l_shipdate < date '1994-12-01' + interval '1' month
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "promo_revenue"),
              BinOp
                (BinOp (NumLit "100.00") (Name "*")
                   (App (Name "sum")
                      [Case{caseTest = Nothing,
                            caseWhens =
                              [([BinOp (Iden (Name "p_type")) (Name "like")
                                   (StringLit "PROMO%")],
                                BinOp (Iden (Name "l_extendedprice")) (Name "*")
                                  (Parens
                                     (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount")))))],
                            caseElse = Just (NumLit "0")}]))
                (Name "/")
                (App (Name "sum")
                   [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                      (Parens
                         (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))]))],
          qeFrom = [TRSimple (Name "lineitem"), TRSimple (Name "part")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp (Iden (Name "l_partkey")) (Name "=")
                       (Iden (Name "p_partkey")))
                    (Name "and")
                    (BinOp (Iden (Name "l_shipdate")) (Name ">=")
                       (TypedLit (TypeName "date") "1994-12-01")))
                 (Name "and")
                 (BinOp (Iden (Name "l_shipdate")) (Name "<")
                    (BinOp (TypedLit (TypeName "date") "1994-12-01") (Name "+")
                       (IntervalLit{ilLiteral = "1", ilUnits = "month",
                                    ilPrecision = Nothing})))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 /*create view revenue0 (supplier_no, total_revenue) as
         select
                 l_suppkey,
                 sum(l_extendedprice * (1 - l_discount))
         from
                 lineitem
         where
                 l_shipdate >= date '1995-06-01'
                 and l_shipdate < date '1995-06-01' + interval '3' month
         group by
                 l_suppkey;*/
 with
 revenue0 as
         (select
                 l_suppkey as supplier_no,
                 sum(l_extendedprice * (1 - l_discount)) as total_revenue
         from
                 lineitem
         where
                 l_shipdate >= date '1995-06-01'
                 and l_shipdate < date '1995-06-01' + interval '3' month
         group by
                 l_suppkey)
 select
         s_suppkey,
         s_name,
         s_address,
         s_phone,
         total_revenue
 from
         supplier,
         revenue0
 where
         s_suppkey = supplier_no
         and total_revenue = (
                 select
                         max(total_revenue)
                 from
                         revenue0
         )
 order by
         s_suppkey
~~~~
</td><td>
~~~~{.haskell}
Right
  (With{qeWithRecursive = False,
        qeViews =
          [(Alias (Name "revenue0") Nothing,
            Select{qeDuplicates = All,
                   qeSelectList =
                     [(Just (Name "supplier_no"), Iden (Name "l_suppkey")),
                      (Just (Name "total_revenue"),
                       App (Name "sum")
                         [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                            (Parens
                               (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))])],
                   qeFrom = [TRSimple (Name "lineitem")],
                   qeWhere =
                     Just
                       (BinOp
                          (BinOp (Iden (Name "l_shipdate")) (Name ">=")
                             (TypedLit (TypeName "date") "1995-06-01"))
                          (Name "and")
                          (BinOp (Iden (Name "l_shipdate")) (Name "<")
                             (BinOp (TypedLit (TypeName "date") "1995-06-01") (Name "+")
                                (IntervalLit{ilLiteral = "3", ilUnits = "month",
                                             ilPrecision = Nothing})))),
                   qeGroupBy = [SimpleGroup (Iden (Name "l_suppkey"))],
                   qeHaving = Nothing, qeOrderBy = [], qeOffset = Nothing,
                   qeFetch = Nothing})],
        qeQueryExpression =
          Select{qeDuplicates = All,
                 qeSelectList =
                   [(Nothing, Iden (Name "s_suppkey")),
                    (Nothing, Iden (Name "s_name")),
                    (Nothing, Iden (Name "s_address")),
                    (Nothing, Iden (Name "s_phone")),
                    (Nothing, Iden (Name "total_revenue"))],
                 qeFrom = [TRSimple (Name "supplier"), TRSimple (Name "revenue0")],
                 qeWhere =
                   Just
                     (BinOp
                        (BinOp (Iden (Name "s_suppkey")) (Name "=")
                           (Iden (Name "supplier_no")))
                        (Name "and")
                        (BinOp (Iden (Name "total_revenue")) (Name "=")
                           (SubQueryExpr SqSq
                              (Select{qeDuplicates = All,
                                      qeSelectList =
                                        [(Nothing, App (Name "max") [Iden (Name "total_revenue")])],
                                      qeFrom = [TRSimple (Name "revenue0")], qeWhere = Nothing,
                                      qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                      qeOffset = Nothing, qeFetch = Nothing})))),
                 qeGroupBy = [], qeHaving = Nothing,
                 qeOrderBy =
                   [OrderField (Iden (Name "s_suppkey")) Asc NullsOrderDefault],
                 qeOffset = Nothing, qeFetch = Nothing}})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         p_brand,
         p_type,
         p_size,
         count(distinct ps_suppkey) as supplier_cnt
 from
         partsupp,
         part
 where
         p_partkey = ps_partkey
         and p_brand <> 'Brand#15'
         and p_type not like 'MEDIUM BURNISHED%'
         and p_size in (39, 26, 18, 45, 19, 1, 3, 9)
         and ps_suppkey not in (
                 select
                         s_suppkey
                 from
                         supplier
                 where
                         s_comment like '%Customer%Complaints%'
         )
 group by
         p_brand,
         p_type,
         p_size
 order by
         supplier_cnt desc,
         p_brand,
         p_type,
         p_size
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "p_brand")), (Nothing, Iden (Name "p_type")),
             (Nothing, Iden (Name "p_size")),
             (Just (Name "supplier_cnt"),
              AggregateApp{aggName = Name "count", aggDistinct = Just Distinct,
                           aggArgs = [Iden (Name "ps_suppkey")], aggOrderBy = []})],
          qeFrom = [TRSimple (Name "partsupp"), TRSimple (Name "part")],
          qeWhere =
            Just
              (In False
                 (BinOp
                    (In True
                       (BinOp
                          (BinOp
                             (BinOp
                                (BinOp (Iden (Name "p_partkey")) (Name "=")
                                   (Iden (Name "ps_partkey")))
                                (Name "and")
                                (BinOp (Iden (Name "p_brand")) (Name "<>") (StringLit "Brand#15")))
                             (Name "and")
                             (BinOp (Iden (Name "p_type")) (Name "not like")
                                (StringLit "MEDIUM BURNISHED%")))
                          (Name "and")
                          (Iden (Name "p_size")))
                       (InList
                          [NumLit "39", NumLit "26", NumLit "18", NumLit "45", NumLit "19",
                           NumLit "1", NumLit "3", NumLit "9"]))
                    (Name "and")
                    (Iden (Name "ps_suppkey")))
                 (InQueryExpr
                    (Select{qeDuplicates = All,
                            qeSelectList = [(Nothing, Iden (Name "s_suppkey"))],
                            qeFrom = [TRSimple (Name "supplier")],
                            qeWhere =
                              Just
                                (BinOp (Iden (Name "s_comment")) (Name "like")
                                   (StringLit "%Customer%Complaints%")),
                            qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                            qeOffset = Nothing, qeFetch = Nothing}))),
          qeGroupBy =
            [SimpleGroup (Iden (Name "p_brand")),
             SimpleGroup (Iden (Name "p_type")),
             SimpleGroup (Iden (Name "p_size"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "supplier_cnt")) Desc NullsOrderDefault,
             OrderField (Iden (Name "p_brand")) Asc NullsOrderDefault,
             OrderField (Iden (Name "p_type")) Asc NullsOrderDefault,
             OrderField (Iden (Name "p_size")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         sum(l_extendedprice) / 7.0 as avg_yearly
 from
         lineitem,
         part
 where
         p_partkey = l_partkey
         and p_brand = 'Brand#52'
         and p_container = 'JUMBO CAN'
         and l_quantity < (
                 select
                         0.2 * avg(l_quantity)
                 from
                         lineitem
                 where
                         l_partkey = p_partkey
         )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "avg_yearly"),
              BinOp (App (Name "sum") [Iden (Name "l_extendedprice")]) (Name "/")
                (NumLit "7.0"))],
          qeFrom = [TRSimple (Name "lineitem"), TRSimple (Name "part")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp
                       (BinOp (Iden (Name "p_partkey")) (Name "=")
                          (Iden (Name "l_partkey")))
                       (Name "and")
                       (BinOp (Iden (Name "p_brand")) (Name "=") (StringLit "Brand#52")))
                    (Name "and")
                    (BinOp (Iden (Name "p_container")) (Name "=")
                       (StringLit "JUMBO CAN")))
                 (Name "and")
                 (BinOp (Iden (Name "l_quantity")) (Name "<")
                    (SubQueryExpr SqSq
                       (Select{qeDuplicates = All,
                               qeSelectList =
                                 [(Nothing,
                                   BinOp (NumLit "0.2") (Name "*")
                                     (App (Name "avg") [Iden (Name "l_quantity")]))],
                               qeFrom = [TRSimple (Name "lineitem")],
                               qeWhere =
                                 Just
                                   (BinOp (Iden (Name "l_partkey")) (Name "=")
                                      (Iden (Name "p_partkey"))),
                               qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                               qeOffset = Nothing, qeFetch = Nothing})))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         c_name,
         c_custkey,
         o_orderkey,
         o_orderdate,
         o_totalprice,
         sum(l_quantity)
 from
         customer,
         orders,
         lineitem
 where
         o_orderkey in (
                 select
                         l_orderkey
                 from
                         lineitem
                 group by
                         l_orderkey having
                                 sum(l_quantity) > 313
         )
         and c_custkey = o_custkey
         and o_orderkey = l_orderkey
 group by
         c_name,
         c_custkey,
         o_orderkey,
         o_orderdate,
         o_totalprice
 order by
         o_totalprice desc,
         o_orderdate
 fetch first 100 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "c_name")),
             (Nothing, Iden (Name "c_custkey")),
             (Nothing, Iden (Name "o_orderkey")),
             (Nothing, Iden (Name "o_orderdate")),
             (Nothing, Iden (Name "o_totalprice")),
             (Nothing, App (Name "sum") [Iden (Name "l_quantity")])],
          qeFrom =
            [TRSimple (Name "customer"), TRSimple (Name "orders"),
             TRSimple (Name "lineitem")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (In True (Iden (Name "o_orderkey"))
                       (InQueryExpr
                          (Select{qeDuplicates = All,
                                  qeSelectList = [(Nothing, Iden (Name "l_orderkey"))],
                                  qeFrom = [TRSimple (Name "lineitem")], qeWhere = Nothing,
                                  qeGroupBy = [SimpleGroup (Iden (Name "l_orderkey"))],
                                  qeHaving =
                                    Just
                                      (BinOp (App (Name "sum") [Iden (Name "l_quantity")])
                                         (Name ">")
                                         (NumLit "313")),
                                  qeOrderBy = [], qeOffset = Nothing, qeFetch = Nothing})))
                    (Name "and")
                    (BinOp (Iden (Name "c_custkey")) (Name "=")
                       (Iden (Name "o_custkey"))))
                 (Name "and")
                 (BinOp (Iden (Name "o_orderkey")) (Name "=")
                    (Iden (Name "l_orderkey")))),
          qeGroupBy =
            [SimpleGroup (Iden (Name "c_name")),
             SimpleGroup (Iden (Name "c_custkey")),
             SimpleGroup (Iden (Name "o_orderkey")),
             SimpleGroup (Iden (Name "o_orderdate")),
             SimpleGroup (Iden (Name "o_totalprice"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "o_totalprice")) Desc NullsOrderDefault,
             OrderField (Iden (Name "o_orderdate")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Just (NumLit "100")})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         sum(l_extendedprice* (1 - l_discount)) as revenue
 from
         lineitem,
         part
 where
         (
                 p_partkey = l_partkey
                 and p_brand = 'Brand#43'
                 and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
                 and l_quantity >= 3 and l_quantity <= 3 + 10
                 and p_size between 1 and 5
                 and l_shipmode in ('AIR', 'AIR REG')
                 and l_shipinstruct = 'DELIVER IN PERSON'
         )
         or
         (
                 p_partkey = l_partkey
                 and p_brand = 'Brand#25'
                 and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
                 and l_quantity >= 10 and l_quantity <= 10 + 10
                 and p_size between 1 and 10
                 and l_shipmode in ('AIR', 'AIR REG')
                 and l_shipinstruct = 'DELIVER IN PERSON'
         )
         or
         (
                 p_partkey = l_partkey
                 and p_brand = 'Brand#24'
                 and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
                 and l_quantity >= 22 and l_quantity <= 22 + 10
                 and p_size between 1 and 15
                 and l_shipmode in ('AIR', 'AIR REG')
                 and l_shipinstruct = 'DELIVER IN PERSON'
         )
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Just (Name "revenue"),
              App (Name "sum")
                [BinOp (Iden (Name "l_extendedprice")) (Name "*")
                   (Parens
                      (BinOp (NumLit "1") (Name "-") (Iden (Name "l_discount"))))])],
          qeFrom = [TRSimple (Name "lineitem"), TRSimple (Name "part")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (Parens
                       (BinOp
                          (In True
                             (BinOp
                                (SpecialOp (Name "between")
                                   [BinOp
                                      (BinOp
                                         (BinOp
                                            (In True
                                               (BinOp
                                                  (BinOp
                                                     (BinOp (Iden (Name "p_partkey")) (Name "=")
                                                        (Iden (Name "l_partkey")))
                                                     (Name "and")
                                                     (BinOp (Iden (Name "p_brand")) (Name "=")
                                                        (StringLit "Brand#43")))
                                                  (Name "and")
                                                  (Iden (Name "p_container")))
                                               (InList
                                                  [StringLit "SM CASE", StringLit "SM BOX",
                                                   StringLit "SM PACK", StringLit "SM PKG"]))
                                            (Name "and")
                                            (BinOp (Iden (Name "l_quantity")) (Name ">=")
                                               (NumLit "3")))
                                         (Name "and")
                                         (BinOp (Iden (Name "l_quantity")) (Name "<=")
                                            (BinOp (NumLit "3") (Name "+") (NumLit "10"))))
                                      (Name "and")
                                      (Iden (Name "p_size")),
                                    NumLit "1", NumLit "5"])
                                (Name "and")
                                (Iden (Name "l_shipmode")))
                             (InList [StringLit "AIR", StringLit "AIR REG"]))
                          (Name "and")
                          (BinOp (Iden (Name "l_shipinstruct")) (Name "=")
                             (StringLit "DELIVER IN PERSON"))))
                    (Name "or")
                    (Parens
                       (BinOp
                          (In True
                             (BinOp
                                (SpecialOp (Name "between")
                                   [BinOp
                                      (BinOp
                                         (BinOp
                                            (In True
                                               (BinOp
                                                  (BinOp
                                                     (BinOp (Iden (Name "p_partkey")) (Name "=")
                                                        (Iden (Name "l_partkey")))
                                                     (Name "and")
                                                     (BinOp (Iden (Name "p_brand")) (Name "=")
                                                        (StringLit "Brand#25")))
                                                  (Name "and")
                                                  (Iden (Name "p_container")))
                                               (InList
                                                  [StringLit "MED BAG", StringLit "MED BOX",
                                                   StringLit "MED PKG", StringLit "MED PACK"]))
                                            (Name "and")
                                            (BinOp (Iden (Name "l_quantity")) (Name ">=")
                                               (NumLit "10")))
                                         (Name "and")
                                         (BinOp (Iden (Name "l_quantity")) (Name "<=")
                                            (BinOp (NumLit "10") (Name "+") (NumLit "10"))))
                                      (Name "and")
                                      (Iden (Name "p_size")),
                                    NumLit "1", NumLit "10"])
                                (Name "and")
                                (Iden (Name "l_shipmode")))
                             (InList [StringLit "AIR", StringLit "AIR REG"]))
                          (Name "and")
                          (BinOp (Iden (Name "l_shipinstruct")) (Name "=")
                             (StringLit "DELIVER IN PERSON")))))
                 (Name "or")
                 (Parens
                    (BinOp
                       (In True
                          (BinOp
                             (SpecialOp (Name "between")
                                [BinOp
                                   (BinOp
                                      (BinOp
                                         (In True
                                            (BinOp
                                               (BinOp
                                                  (BinOp (Iden (Name "p_partkey")) (Name "=")
                                                     (Iden (Name "l_partkey")))
                                                  (Name "and")
                                                  (BinOp (Iden (Name "p_brand")) (Name "=")
                                                     (StringLit "Brand#24")))
                                               (Name "and")
                                               (Iden (Name "p_container")))
                                            (InList
                                               [StringLit "LG CASE", StringLit "LG BOX",
                                                StringLit "LG PACK", StringLit "LG PKG"]))
                                         (Name "and")
                                         (BinOp (Iden (Name "l_quantity")) (Name ">=")
                                            (NumLit "22")))
                                      (Name "and")
                                      (BinOp (Iden (Name "l_quantity")) (Name "<=")
                                         (BinOp (NumLit "22") (Name "+") (NumLit "10"))))
                                   (Name "and")
                                   (Iden (Name "p_size")),
                                 NumLit "1", NumLit "15"])
                             (Name "and")
                             (Iden (Name "l_shipmode")))
                          (InList [StringLit "AIR", StringLit "AIR REG"]))
                       (Name "and")
                       (BinOp (Iden (Name "l_shipinstruct")) (Name "=")
                          (StringLit "DELIVER IN PERSON"))))),
          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         s_name,
         s_address
 from
         supplier,
         nation
 where
         s_suppkey in (
                 select
                         ps_suppkey
                 from
                         partsupp
                 where
                         ps_partkey in (
                                 select
                                         p_partkey
                                 from
                                         part
                                 where
                                         p_name like 'lime%'
                         )
                         and ps_availqty > (
                                 select
                                         0.5 * sum(l_quantity)
                                 from
                                         lineitem
                                 where
                                         l_partkey = ps_partkey
                                         and l_suppkey = ps_suppkey
                                         and l_shipdate >= date '1994-01-01'
                                         and l_shipdate < date '1994-01-01' + interval '1' year
                         )
         )
         and s_nationkey = n_nationkey
         and n_name = 'VIETNAM'
 order by
         s_name
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "s_name")),
             (Nothing, Iden (Name "s_address"))],
          qeFrom = [TRSimple (Name "supplier"), TRSimple (Name "nation")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (In True (Iden (Name "s_suppkey"))
                       (InQueryExpr
                          (Select{qeDuplicates = All,
                                  qeSelectList = [(Nothing, Iden (Name "ps_suppkey"))],
                                  qeFrom = [TRSimple (Name "partsupp")],
                                  qeWhere =
                                    Just
                                      (BinOp
                                         (In True (Iden (Name "ps_partkey"))
                                            (InQueryExpr
                                               (Select{qeDuplicates = All,
                                                       qeSelectList =
                                                         [(Nothing, Iden (Name "p_partkey"))],
                                                       qeFrom = [TRSimple (Name "part")],
                                                       qeWhere =
                                                         Just
                                                           (BinOp (Iden (Name "p_name"))
                                                              (Name "like")
                                                              (StringLit "lime%")),
                                                       qeGroupBy = [], qeHaving = Nothing,
                                                       qeOrderBy = [], qeOffset = Nothing,
                                                       qeFetch = Nothing})))
                                         (Name "and")
                                         (BinOp (Iden (Name "ps_availqty")) (Name ">")
                                            (SubQueryExpr SqSq
                                               (Select{qeDuplicates = All,
                                                       qeSelectList =
                                                         [(Nothing,
                                                           BinOp (NumLit "0.5") (Name "*")
                                                             (App (Name "sum")
                                                                [Iden (Name "l_quantity")]))],
                                                       qeFrom = [TRSimple (Name "lineitem")],
                                                       qeWhere =
                                                         Just
                                                           (BinOp
                                                              (BinOp
                                                                 (BinOp
                                                                    (BinOp (Iden (Name "l_partkey"))
                                                                       (Name "=")
                                                                       (Iden (Name "ps_partkey")))
                                                                    (Name "and")
                                                                    (BinOp (Iden (Name "l_suppkey"))
                                                                       (Name "=")
                                                                       (Iden (Name "ps_suppkey"))))
                                                                 (Name "and")
                                                                 (BinOp (Iden (Name "l_shipdate"))
                                                                    (Name ">=")
                                                                    (TypedLit (TypeName "date")
                                                                       "1994-01-01")))
                                                              (Name "and")
                                                              (BinOp (Iden (Name "l_shipdate"))
                                                                 (Name "<")
                                                                 (BinOp
                                                                    (TypedLit (TypeName "date")
                                                                       "1994-01-01")
                                                                    (Name "+")
                                                                    (IntervalLit{ilLiteral = "1",
                                                                                 ilUnits = "year",
                                                                                 ilPrecision =
                                                                                   Nothing})))),
                                                       qeGroupBy = [], qeHaving = Nothing,
                                                       qeOrderBy = [], qeOffset = Nothing,
                                                       qeFetch = Nothing})))),
                                  qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                  qeOffset = Nothing, qeFetch = Nothing})))
                    (Name "and")
                    (BinOp (Iden (Name "s_nationkey")) (Name "=")
                       (Iden (Name "n_nationkey"))))
                 (Name "and")
                 (BinOp (Iden (Name "n_name")) (Name "=") (StringLit "VIETNAM"))),
          qeGroupBy = [], qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "s_name")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         s_name,
         count(*) as numwait
 from
         supplier,
         lineitem l1,
         orders,
         nation
 where
         s_suppkey = l1.l_suppkey
         and o_orderkey = l1.l_orderkey
         and o_orderstatus = 'F'
         and l1.l_receiptdate > l1.l_commitdate
         and exists (
                 select
                         *
                 from
                         lineitem l2
                 where
                         l2.l_orderkey = l1.l_orderkey
                         and l2.l_suppkey <> l1.l_suppkey
         )
         and not exists (
                 select
                         *
                 from
                         lineitem l3
                 where
                         l3.l_orderkey = l1.l_orderkey
                         and l3.l_suppkey <> l1.l_suppkey
                         and l3.l_receiptdate > l3.l_commitdate
         )
         and s_nationkey = n_nationkey
         and n_name = 'INDIA'
 group by
         s_name
 order by
         numwait desc,
         s_name
 fetch first 100 rows only
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "s_name")),
             (Just (Name "numwait"), App (Name "count") [Star])],
          qeFrom =
            [TRSimple (Name "supplier"),
             TRAlias (TRSimple (Name "lineitem")) (Alias (Name "l1") Nothing),
             TRSimple (Name "orders"), TRSimple (Name "nation")],
          qeWhere =
            Just
              (BinOp
                 (BinOp
                    (BinOp
                       (BinOp
                          (BinOp
                             (BinOp (Iden (Name "s_suppkey")) (Name "=")
                                (BinOp (Iden (Name "l1")) (Name ".") (Iden (Name "l_suppkey"))))
                             (Name "and")
                             (BinOp (Iden (Name "o_orderkey")) (Name "=")
                                (BinOp (Iden (Name "l1")) (Name ".") (Iden (Name "l_orderkey")))))
                          (Name "and")
                          (BinOp (Iden (Name "o_orderstatus")) (Name "=") (StringLit "F")))
                       (Name "and")
                       (BinOp
                          (BinOp (Iden (Name "l1")) (Name ".") (Iden (Name "l_receiptdate")))
                          (Name ">")
                          (BinOp (Iden (Name "l1")) (Name ".")
                             (Iden (Name "l_commitdate")))))
                    (Name "and")
                    (SubQueryExpr SqExists
                       (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                               qeFrom =
                                 [TRAlias (TRSimple (Name "lineitem")) (Alias (Name "l2") Nothing)],
                               qeWhere =
                                 Just
                                   (BinOp
                                      (BinOp
                                         (BinOp (Iden (Name "l2")) (Name ".")
                                            (Iden (Name "l_orderkey")))
                                         (Name "=")
                                         (BinOp (Iden (Name "l1")) (Name ".")
                                            (Iden (Name "l_orderkey"))))
                                      (Name "and")
                                      (BinOp
                                         (BinOp (Iden (Name "l2")) (Name ".")
                                            (Iden (Name "l_suppkey")))
                                         (Name "<>")
                                         (BinOp (Iden (Name "l1")) (Name ".")
                                            (Iden (Name "l_suppkey"))))),
                               qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                               qeOffset = Nothing, qeFetch = Nothing})))
                 (Name "and")
                 (PrefixOp (Name "not")
                    (BinOp
                       (BinOp
                          (SubQueryExpr SqExists
                             (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                                     qeFrom =
                                       [TRAlias (TRSimple (Name "lineitem"))
                                          (Alias (Name "l3") Nothing)],
                                     qeWhere =
                                       Just
                                         (BinOp
                                            (BinOp
                                               (BinOp
                                                  (BinOp (Iden (Name "l3")) (Name ".")
                                                     (Iden (Name "l_orderkey")))
                                                  (Name "=")
                                                  (BinOp (Iden (Name "l1")) (Name ".")
                                                     (Iden (Name "l_orderkey"))))
                                               (Name "and")
                                               (BinOp
                                                  (BinOp (Iden (Name "l3")) (Name ".")
                                                     (Iden (Name "l_suppkey")))
                                                  (Name "<>")
                                                  (BinOp (Iden (Name "l1")) (Name ".")
                                                     (Iden (Name "l_suppkey")))))
                                            (Name "and")
                                            (BinOp
                                               (BinOp (Iden (Name "l3")) (Name ".")
                                                  (Iden (Name "l_receiptdate")))
                                               (Name ">")
                                               (BinOp (Iden (Name "l3")) (Name ".")
                                                  (Iden (Name "l_commitdate"))))),
                                     qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                     qeOffset = Nothing, qeFetch = Nothing}))
                          (Name "and")
                          (BinOp (Iden (Name "s_nationkey")) (Name "=")
                             (Iden (Name "n_nationkey"))))
                       (Name "and")
                       (BinOp (Iden (Name "n_name")) (Name "=") (StringLit "INDIA"))))),
          qeGroupBy = [SimpleGroup (Iden (Name "s_name"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "numwait")) Desc NullsOrderDefault,
             OrderField (Iden (Name "s_name")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Just (NumLit "100")})
~~~~
</td></tr>
<tr><td>
~~~~{.sql}

 select
         cntrycode,
         count(*) as numcust,
         sum(c_acctbal) as totacctbal
 from
         (
                 select
                         substring(c_phone from 1 for 2) as cntrycode,
                         c_acctbal
                 from
                         customer
                 where
                         substring(c_phone from 1 for 2) in
                                 ('41', '28', '39', '21', '24', '29', '44')
                         and c_acctbal > (
                                 select
                                         avg(c_acctbal)
                                 from
                                         customer
                                 where
                                         c_acctbal > 0.00
                                         and substring(c_phone from 1 for 2) in
                                                 ('41', '28', '39', '21', '24', '29', '44')
                         )
                         and not exists (
                                 select
                                         *
                                 from
                                         orders
                                 where
                                         o_custkey = c_custkey
                         )
         ) as custsale
 group by
         cntrycode
 order by
         cntrycode
~~~~
</td><td>
~~~~{.haskell}
Right
  (Select{qeDuplicates = All,
          qeSelectList =
            [(Nothing, Iden (Name "cntrycode")),
             (Just (Name "numcust"), App (Name "count") [Star]),
             (Just (Name "totacctbal"),
              App (Name "sum") [Iden (Name "c_acctbal")])],
          qeFrom =
            [TRAlias
               (TRQueryExpr
                  (Select{qeDuplicates = All,
                          qeSelectList =
                            [(Just (Name "cntrycode"),
                              SpecialOp (Name "substring")
                                [Iden (Name "c_phone"), NumLit "1", NumLit "2"]),
                             (Nothing, Iden (Name "c_acctbal"))],
                          qeFrom = [TRSimple (Name "customer")],
                          qeWhere =
                            Just
                              (BinOp
                                 (BinOp
                                    (In True
                                       (SpecialOp (Name "substring")
                                          [Iden (Name "c_phone"), NumLit "1", NumLit "2"])
                                       (InList
                                          [StringLit "41", StringLit "28", StringLit "39",
                                           StringLit "21", StringLit "24", StringLit "29",
                                           StringLit "44"]))
                                    (Name "and")
                                    (BinOp (Iden (Name "c_acctbal")) (Name ">")
                                       (SubQueryExpr SqSq
                                          (Select{qeDuplicates = All,
                                                  qeSelectList =
                                                    [(Nothing,
                                                      App (Name "avg") [Iden (Name "c_acctbal")])],
                                                  qeFrom = [TRSimple (Name "customer")],
                                                  qeWhere =
                                                    Just
                                                      (In True
                                                         (BinOp
                                                            (BinOp (Iden (Name "c_acctbal"))
                                                               (Name ">")
                                                               (NumLit "0.00"))
                                                            (Name "and")
                                                            (SpecialOp (Name "substring")
                                                               [Iden (Name "c_phone"), NumLit "1",
                                                                NumLit "2"]))
                                                         (InList
                                                            [StringLit "41", StringLit "28",
                                                             StringLit "39", StringLit "21",
                                                             StringLit "24", StringLit "29",
                                                             StringLit "44"])),
                                                  qeGroupBy = [], qeHaving = Nothing,
                                                  qeOrderBy = [], qeOffset = Nothing,
                                                  qeFetch = Nothing}))))
                                 (Name "and")
                                 (PrefixOp (Name "not")
                                    (SubQueryExpr SqExists
                                       (Select{qeDuplicates = All, qeSelectList = [(Nothing, Star)],
                                               qeFrom = [TRSimple (Name "orders")],
                                               qeWhere =
                                                 Just
                                                   (BinOp (Iden (Name "o_custkey")) (Name "=")
                                                      (Iden (Name "c_custkey"))),
                                               qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                                               qeOffset = Nothing, qeFetch = Nothing})))),
                          qeGroupBy = [], qeHaving = Nothing, qeOrderBy = [],
                          qeOffset = Nothing, qeFetch = Nothing}))
               (Alias (Name "custsale") Nothing)],
          qeWhere = Nothing,
          qeGroupBy = [SimpleGroup (Iden (Name "cntrycode"))],
          qeHaving = Nothing,
          qeOrderBy =
            [OrderField (Iden (Name "cntrycode")) Asc NullsOrderDefault],
          qeOffset = Nothing, qeFetch = Nothing})
~~~~
</td></tr>
</table>
